{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1541",
    "id": 1684909184,
    "node_id": "PR_kwDOAN28mc5kbayA",
    "html_url": "https://github.com/bitcoin/bips/pull/1541",
    "diff_url": "https://github.com/bitcoin/bips/pull/1541.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1541.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1541/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
    "number": 1541,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "BIP431: Opt In Topologically Restricted Until Confirmation Transactions For More Robust Fee-bumping",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is a BIP for Topologically Restricted Until Confirmation (TRUC) Transactions. It's also called \"v3 transaction policy\" since the marker is `nVersion=3`.\r\n\r\nA specification is useful for coordination between node impls that want to implement the same policy and applications that want to use it. For those that are not interested in the details of v3 policy, this also serves as a writeup of the specific pinning problems we aim to address. There has been discussion of using this in other protocol design and multiple requests for its documentation to exist in the BIPs repository, so I'm opening a PR here.\r\n\r\nImplementation:\r\n- https://github.com/bitcoin/bitcoin/pull/28948\r\n- https://github.com/bitcoin/bitcoin/pull/29873\r\n- https://github.com/bitcoin/bitcoin/pull/29496\r\n\r\nExample usage and things built on top:\r\n- Package RBF\r\n  - https://github.com/bitcoin/bitcoin/pull/28984\r\n- Ephemeral Anchors\r\n  - https://github.com/bitcoin/bitcoin/pull/29001\r\n  - https://github.com/bitcoin/bips/pull/1524\r\n- LN commitment transactions\r\n  - https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418\r\n  - https://github.com/instagibbs/bolts/commits/zero_fee_commitment\r\n- LN-Symmetry\r\n  - https://delvingbitcoin.org/t/ln-symmetry-project-recap/359\r\n  - https://github.com/instagibbs/lightning/tree/eltoo_support\r\n\r\nDiscussion and history:\r\n- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html\r\n- https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff\r\n- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\r\n- https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340\r\n- https://github.com/bitcoin/bitcoin/pull/25038",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2024-01-18T14:01:13Z",
    "updated_at": "2024-07-16T21:40:53Z",
    "closed_at": "2024-05-29T02:50:57Z",
    "mergeable_state": "unknown",
    "merged_at": "2024-05-29T02:50:57Z",
    "merge_commit_sha": "10650becef658c63cae688ba565c66d69d515081",
    "assignee": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "glozow:2024-01-v3-prio",
      "ref": "2024-01-v3-prio",
      "sha": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 481603389,
        "node_id": "R_kgDOHLSvPQ",
        "name": "bips",
        "full_name": "glozow/bips",
        "owner": {
          "login": "glozow",
          "id": 25183001,
          "node_id": "MDQ6VXNlcjI1MTgzMDAx",
          "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/glozow",
          "html_url": "https://github.com/glozow",
          "followers_url": "https://api.github.com/users/glozow/followers",
          "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
          "organizations_url": "https://api.github.com/users/glozow/orgs",
          "repos_url": "https://api.github.com/users/glozow/repos",
          "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/glozow/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/glozow/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/glozow/bips",
        "archive_url": "https://api.github.com/repos/glozow/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/glozow/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/glozow/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/glozow/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/glozow/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/glozow/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/glozow/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/glozow/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/glozow/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/glozow/bips/contributors",
        "deployments_url": "https://api.github.com/repos/glozow/bips/deployments",
        "downloads_url": "https://api.github.com/repos/glozow/bips/downloads",
        "events_url": "https://api.github.com/repos/glozow/bips/events",
        "forks_url": "https://api.github.com/repos/glozow/bips/forks",
        "git_commits_url": "https://api.github.com/repos/glozow/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/glozow/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/glozow/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/glozow/bips.git",
        "issue_comment_url": "https://api.github.com/repos/glozow/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/glozow/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/glozow/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/glozow/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/glozow/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/glozow/bips/languages",
        "merges_url": "https://api.github.com/repos/glozow/bips/merges",
        "milestones_url": "https://api.github.com/repos/glozow/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/glozow/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/glozow/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/glozow/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:glozow/bips.git",
        "stargazers_url": "https://api.github.com/repos/glozow/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/glozow/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/glozow/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/glozow/bips/subscription",
        "tags_url": "https://api.github.com/repos/glozow/bips/tags",
        "teams_url": "https://api.github.com/repos/glozow/bips/teams",
        "trees_url": "https://api.github.com/repos/glozow/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/glozow/bips.git",
        "hooks_url": "https://api.github.com/repos/glozow/bips/hooks",
        "svn_url": "https://github.com/glozow/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 1,
        "stargazers_count": 2,
        "watchers_count": 2,
        "size": 14959,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-08T15:03:47Z",
        "created_at": "2022-04-14T12:52:36Z",
        "updated_at": "2023-06-12T10:57:22Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "e2f7481a132e1c5863f5ffcbff009964d7c2af20",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5312,
        "stargazers_count": 9142,
        "watchers_count": 9142,
        "size": 15428,
        "default_branch": "master",
        "open_issues_count": 41,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-16T00:37:56Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2024-07-16T02:10:46Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 298,
    "deletions": 0,
    "changed_files": 2,
    "commits": 1,
    "review_comments": 64,
    "comments": 25
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 11525945502,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAKu__ie",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11525945502",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-18T14:26:50Z"
    },
    {
      "event": "commented",
      "id": 1898819757,
      "node_id": "IC_kwDOAN28mc5xLbCt",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1898819757",
      "actor": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-18T16:31:32Z",
      "updated_at": "2024-01-18T16:31:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "FWIW, concept ACK :)",
      "user": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-1898819757",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "reviewed",
      "id": 1833321526,
      "node_id": "PRR_kwDOAN28mc5tRkQ2",
      "url": null,
      "actor": null,
      "commit_id": "4bd12d5698404e28c70d4486316f4e1cca356896",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 4bd12d5698404e28c70d4486316f4e1cca356896",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-1833321526",
      "submitted_at": "2024-01-19T18:09:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11554734832,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAKwt0Lw",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11554734832",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-22T10:29:07Z"
    },
    {
      "event": "commented",
      "id": 1903700074,
      "node_id": "IC_kwDOAN28mc5xeChq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1903700074",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-22T10:34:57Z",
      "updated_at": "2024-01-22T10:35:33Z",
      "author_association": "MEMBER",
      "body": "Thanks @murchandamus, took all your suggestions (4bd12d5...af8e903)",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-1903700074",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "mentioned",
      "id": 11554806752,
      "node_id": "MEE_lADOAN28mc58eb5UzwAAAAKwuFvg",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11554806752",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-22T10:34:57Z"
    },
    {
      "event": "subscribed",
      "id": 11554806776,
      "node_id": "SE_lADOAN28mc58eb5UzwAAAAKwuFv4",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11554806776",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-22T10:34:57Z"
    },
    {
      "event": "reviewed",
      "id": 1836176115,
      "node_id": "PRR_kwDOAN28mc5tcdLz",
      "url": null,
      "actor": null,
      "commit_id": "af8e9038e6142264b55d6bb2d2599fd9f5adbc43",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK ",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-1836176115",
      "submitted_at": "2024-01-22T11:45:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11555885898,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAKwyNNK",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11555885898",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-22T12:11:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11555971913,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAKwyiNJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11555971913",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-22T12:19:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11556145379,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAKwzMjj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11556145379",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-22T12:35:05Z"
    },
    {
      "event": "commented",
      "id": 1952789440,
      "node_id": "IC_kwDOAN28mc50ZTPA",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1952789440",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-19T16:12:11Z",
      "updated_at": "2024-02-19T16:12:11Z",
      "author_association": "MEMBER",
      "body": "@luke-jr this has been open for a month, would you mind taking a look?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-1952789440",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "mentioned",
      "id": 11851876664,
      "node_id": "MEE_lADOAN28mc58eb5UzwAAAALCbUk4",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11851876664",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-19T16:12:12Z"
    },
    {
      "event": "subscribed",
      "id": 11851876700,
      "node_id": "SE_lADOAN28mc58eb5UzwAAAALCbUlc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11851876700",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-19T16:12:12Z"
    },
    {
      "event": "commented",
      "id": 1953290125,
      "node_id": "IC_kwDOAN28mc50bNeN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1953290125",
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-19T23:56:37Z",
      "updated_at": "2024-02-19T23:56:37Z",
      "author_association": "MEMBER",
      "body": "I think this should document that 1000 vb child limit is experimental and it cannot be relied on by downstream projects.\r\nThis opt-in policy is not robust towards NTA pinning (cf. “The Good, The Bad, The Ugly” 2020 mail) and “loophole” pinning exposed in Core’s #28948. This can note that additional opt-in policy might be applied on top of nversion=3 see Core’s #29454.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-1953290125",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12216058631,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAALYIkMH",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12216058631",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-22T13:52:02Z"
    },
    {
      "event": "renamed",
      "id": 12216094435,
      "node_id": "RTE_lADOAN28mc58eb5UzwAAAALYIs7j",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12216094435",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-22T13:54:24Z",
      "rename": {
        "from": "Opt-In Policy For More Robust Fee-bumping",
        "to": "Opt In Topologically Restricted Until Confirmation Transactions For More Robust Fee-bumping"
      }
    },
    {
      "event": "reviewed",
      "id": 1955315690,
      "node_id": "PRR_kwDOAN28mc50i7_q",
      "url": null,
      "actor": null,
      "commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 63e8a7191f8ab2453e5971e62f709df613ae224c",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-1955315690",
      "submitted_at": "2024-03-22T18:32:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12246975830,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAALZ-gVW",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12246975830",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-26T09:37:24Z"
    },
    {
      "event": "reviewed",
      "id": 1959823589,
      "node_id": "PRR_kwDOAN28mc500Ijl",
      "url": null,
      "actor": null,
      "commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Thanks @murchandamus! Accepted your suggestions.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-1959823589",
      "submitted_at": "2024-03-26T09:37:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "labeled",
      "id": 12568636477,
      "node_id": "LE_lADOAN28mc58eb5UzwAAAALtJiw9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12568636477",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-23T03:40:27Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "reviewed",
      "id": 2017332470,
      "node_id": "PRR_kwDOAN28mc54Pgz2",
      "url": null,
      "actor": null,
      "commit_id": "158acdbbbf8ef13f6b345b6281a96e88e20d2cf9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2017332470",
      "submitted_at": "2024-04-23T14:27:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "commented",
      "id": 2073455048,
      "node_id": "IC_kwDOAN28mc57lmnI",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2073455048",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-23T21:13:41Z",
      "updated_at": "2024-04-23T21:13:41Z",
      "author_association": "MEMBER",
      "body": "As with #1524, node policy is not a standardizable subject matter in itself - every node decides its own policy. BIP 125 already defined a way for wallets to indicate they prefer RBF-like treatment of their transactions, and I don't see why the same signal can't be used for this.\r\n\r\n",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2073455048",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2073489494,
      "node_id": "IC_kwDOAN28mc57lvBW",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2073489494",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-23T21:29:36Z",
      "updated_at": "2024-04-23T21:29:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Every node deciding its own policy is not mutually exclusive with it being standardizable – each node decides which (if any) standards to follow. Policy standards make just as much sense as e.g. wallet standards or P2P protocol standards.",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2073489494",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2073507438,
      "node_id": "IC_kwDOAN28mc57lzZu",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2073507438",
      "actor": {
        "login": "Roasbeef",
        "id": 998190,
        "node_id": "MDQ6VXNlcjk5ODE5MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/998190?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Roasbeef",
        "html_url": "https://github.com/Roasbeef",
        "followers_url": "https://api.github.com/users/Roasbeef/followers",
        "following_url": "https://api.github.com/users/Roasbeef/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Roasbeef/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Roasbeef/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Roasbeef/subscriptions",
        "organizations_url": "https://api.github.com/users/Roasbeef/orgs",
        "repos_url": "https://api.github.com/users/Roasbeef/repos",
        "events_url": "https://api.github.com/users/Roasbeef/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Roasbeef/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-23T21:40:01Z",
      "updated_at": "2024-04-23T21:40:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "> BIP 125 already defined a way for wallets to indicate they prefer RBF-like treatment of their transactions, and I don't see why the same signal can't be used for this.\r\n\r\nBIP 125 defines a set of rules w.r.t transaction replacement. Some of those rules have edge cases that can [lead to defects where transactions that should otherwise be replaced, can't be replaced](https://github.com/bitcoin/bips/blob/158acdbbbf8ef13f6b345b6281a96e88e20d2cf9/bip-truc.mediawiki#user-content-RBF_pinning_through_Rule_3). This class of replacement defects loosely falls under the umbrella of \"transaction pinning\". The TRUC rules resolve those issues, creating a replacement semantics that better serve off-chain protocols, and address some known pinning vectors. For many off-chain protocols, TRUC will supersede base RBF. As the semantics are distinct, it cannot use the existing sequence fields carved out by BIP 125 (the rules are also incompatible). Instead, it uses transaction v3 (no longer non standard) as a way to signal replacement under a distinct set of rules. ",
      "user": {
        "login": "Roasbeef",
        "id": 998190,
        "node_id": "MDQ6VXNlcjk5ODE5MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/998190?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Roasbeef",
        "html_url": "https://github.com/Roasbeef",
        "followers_url": "https://api.github.com/users/Roasbeef/followers",
        "following_url": "https://api.github.com/users/Roasbeef/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Roasbeef/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Roasbeef/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Roasbeef/subscriptions",
        "organizations_url": "https://api.github.com/users/Roasbeef/orgs",
        "repos_url": "https://api.github.com/users/Roasbeef/repos",
        "events_url": "https://api.github.com/users/Roasbeef/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Roasbeef/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2073507438",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2073558982,
      "node_id": "IC_kwDOAN28mc57l__G",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2073558982",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-23T22:11:28Z",
      "updated_at": "2024-04-23T22:11:28Z",
      "author_association": "MEMBER",
      "body": "BIP 125 defines a signalling mechanism, not policy (which is again outside the scope of BIPs) even if it describes a particular policy. The intent of the signal is clear, and it can be implemented in other ways such as the one that seems to be desired here.",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2073558982",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2073567884,
      "node_id": "IC_kwDOAN28mc57mCKM",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2073567884",
      "actor": {
        "login": "Roasbeef",
        "id": 998190,
        "node_id": "MDQ6VXNlcjk5ODE5MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/998190?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Roasbeef",
        "html_url": "https://github.com/Roasbeef",
        "followers_url": "https://api.github.com/users/Roasbeef/followers",
        "following_url": "https://api.github.com/users/Roasbeef/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Roasbeef/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Roasbeef/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Roasbeef/subscriptions",
        "organizations_url": "https://api.github.com/users/Roasbeef/orgs",
        "repos_url": "https://api.github.com/users/Roasbeef/repos",
        "events_url": "https://api.github.com/users/Roasbeef/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Roasbeef/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-23T22:19:24Z",
      "updated_at": "2024-04-23T22:19:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "> BIP 125 defines a signalling mechanism, not policy\r\n\r\nIt clearly defines _both_: \r\n\r\n> The opt-in full Replace-by-Fee (opt-in full-RBF) signaling **policy** described here allows spenders to add a signal to a transaction indicating that they want to be able to replace that transaction in the future\r\n\r\n\r\n> This **policy** specifies two ways a transaction can signal that it is replaceable.\r\n\r\n\r\n> Inherited signaling: Transactions that don't explicitly signal replaceability are replaceable **under this policy** for as long as any one of their ancestors signals replaceability and remains unconfirmed.\r\n\r\n\r\n> Because descendant transactions may also be replaceable **under this policy** through inherited signaling, any method used to process opt-in full-RBF transactions should be inherited by any descendant transactions for as long as any ancestor opt-in full-RBF transactions remain unconfirmed.\r\n\r\nIt also defines [a precise set of rules for the policy](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki#implementation-details). If an implementation deviates from those rules, then it isn't BIP 125. From the OP, there's a clear need to define a new policy _and_ signalling mechanism, which this document does. ",
      "user": {
        "login": "Roasbeef",
        "id": 998190,
        "node_id": "MDQ6VXNlcjk5ODE5MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/998190?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Roasbeef",
        "html_url": "https://github.com/Roasbeef",
        "followers_url": "https://api.github.com/users/Roasbeef/followers",
        "following_url": "https://api.github.com/users/Roasbeef/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Roasbeef/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Roasbeef/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Roasbeef/subscriptions",
        "organizations_url": "https://api.github.com/users/Roasbeef/orgs",
        "repos_url": "https://api.github.com/users/Roasbeef/repos",
        "events_url": "https://api.github.com/users/Roasbeef/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Roasbeef/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2073567884",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2073598659,
      "node_id": "IC_kwDOAN28mc57mJrD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2073598659",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-23T22:45:41Z",
      "updated_at": "2024-04-23T22:45:41Z",
      "author_association": "MEMBER",
      "body": "It may be poorly worded, but that isn't the point.",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2073598659",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2073606476,
      "node_id": "IC_kwDOAN28mc57mLlM",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2073606476",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-23T22:50:35Z",
      "updated_at": "2024-04-23T22:50:35Z",
      "author_association": "MEMBER",
      "body": "(Note that BIP 125's relationship with policy *was* a matter of discussion back when it was submitted, and it was nearly rejected - the only reason it was accepted in the end, was as a signalling BIP. And even if you want to insist it defines policy, mistakes made in the past would not be a reason to repeat them in the future, and thus would actually work against accepting this proposal)",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2073606476",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12590063333,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAALubR7l",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12590063333",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T11:04:42Z"
    },
    {
      "event": "commented",
      "id": 2074753716,
      "node_id": "IC_kwDOAN28mc57qjq0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2074753716",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T11:45:16Z",
      "updated_at": "2024-04-24T11:45:16Z",
      "author_association": "MEMBER",
      "body": "Addressed @murchandamus's comments and slightly restructured the text.\r\n\r\n> As with https://github.com/bitcoin/bips/pull/1524, node policy is not a standardizable subject matter in itself - every node decides its own policy.\r\n\r\nI really don't see how the text in this BIP can be interpreted to mean that nodes can't decide their own policy. But I've added some language to the text to make it more clear that it's optional, that there are other ways to do this, policy is not consensus, and the details can be different.\r\n\r\n> BIP 125 already defined a way for wallets to indicate they prefer RBF-like treatment of their transactions, and I don't see why the same signal can't be used for this.\r\n\r\nThis policy restriction should be opt in to avoid breaking existing use cases. Also I don't agree that the same signal should be used for 2 different things just because they have a few things in common.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2074753716",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "mentioned",
      "id": 12590565875,
      "node_id": "MEE_lADOAN28mc58eb5UzwAAAALudMnz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12590565875",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T11:45:18Z"
    },
    {
      "event": "subscribed",
      "id": 12590565891,
      "node_id": "SE_lADOAN28mc58eb5UzwAAAALudMoD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12590565891",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T11:45:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12594327672,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAALurjB4",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12594327672",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T15:50:58Z"
    },
    {
      "event": "commented",
      "id": 2076522523,
      "node_id": "IC_kwDOAN28mc57xTgb",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2076522523",
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-25T07:12:56Z",
      "updated_at": "2024-04-25T07:15:09Z",
      "author_association": "MEMBER",
      "body": "> (Note that BIP 125's relationship with policy was a matter of discussion back when it was submitted, and it was nearly\r\n> rejected - the only reason it was accepted in the end, was as a signalling BIP. And even if you want to insist it defines\r\n> policy, mistakes made in the past would not be a reason to repeat them in the future, and thus would actually work against > accepting this proposal)\r\n\r\nIf I can make one suggestion it would be to split this BIP in two new BIP components:\r\n- the signaling mechanism (nversion=3)\r\n- the set of policy rules (i.e the TRUC)\r\n\r\nThis would certainly help to navigate more efficiently this kind of situation in the future.\r\n\r\n\"Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.”\r\n\r\nThis gives flexibility to have many signaling mechanism (e.g nversion / nsequence) committing to one set of policy rules and vice-versa have one signaling mechanism committing to many policy rules (bip125, 1000 vb child limit truc, etc). This can only give us more flexibility w.r.t coordinated upgrades across bitcoin layers.\r\n\r\nedited - to clarify the suggestion to split in 2 new BIP documents this current one.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2076522523",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "reviewed",
      "id": 2025913665,
      "node_id": "PRR_kwDOAN28mc54wP1B",
      "url": null,
      "actor": null,
      "commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "My concerns have been addressed, I just noticed a typo you could fix in case you need to touch this again.\r\n\r\nreACK f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2025913665",
      "submitted_at": "2024-04-26T21:42:57Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "labeled",
      "id": 12804356156,
      "node_id": "LE_lADOAN28mc58eb5UzwAAAAL7Mvg8",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12804356156",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-14T15:26:34Z",
      "label": {
        "name": "Process",
        "color": "19962E"
      }
    },
    {
      "event": "review_requested",
      "id": 12809849940,
      "node_id": "RRE_lADOAN28mc58eb5UzwAAAAL7hsxU",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12809849940",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T01:26:04Z",
      "requested_reviewer": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 2069649072,
      "node_id": "PRR_kwDOAN28mc57XFaw",
      "url": null,
      "actor": null,
      "commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Looks pretty close. Would need a README entry and a BIP number assignment, if deemed to be in-scope.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2069649072",
      "submitted_at": "2024-05-21T23:01:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "reviewed",
      "id": 2069795341,
      "node_id": "PRR_kwDOAN28mc57XpIN",
      "url": null,
      "actor": null,
      "commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2069795341",
      "submitted_at": "2024-05-21T23:36:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "commented",
      "id": 2124817400,
      "node_id": "IC_kwDOAN28mc5-piP4",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2124817400",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T13:35:32Z",
      "updated_at": "2024-05-22T13:35:32Z",
      "author_association": "MEMBER",
      "body": "Thanks for the review @jonatack! I'll wait for a number assignment.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2124817400",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "mentioned",
      "id": 12894674994,
      "node_id": "MEE_lADOAN28mc58eb5UzwAAAAMAlSAy",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12894674994",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T13:35:34Z"
    },
    {
      "event": "subscribed",
      "id": 12894675011,
      "node_id": "SE_lADOAN28mc58eb5UzwAAAAMAlSBD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12894675011",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T13:35:34Z"
    },
    {
      "event": "commented",
      "id": 2125415304,
      "node_id": "IC_kwDOAN28mc5-r0OI",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2125415304",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T17:47:19Z",
      "updated_at": "2024-05-22T17:47:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "Assigned number 431.\r\n\r\nPer BIP 2: `The BIP process exists for standardisation between independent projects.`  While policy is a per-node decision, R&D related to node relay policy and a degree of interop standardization have been and continue to be worked on to try to solve fundamental long-standing issues in bitcoin and across the LN implementations. This R&D documentation, along with signaling v3 transactions and opt-in interop standardization, seem in-scope here.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2125415304",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "unlabeled",
      "id": 12899167942,
      "node_id": "UNLE_lADOAN28mc58eb5UzwAAAAMA2a7G",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12899167942",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T18:36:22Z",
      "label": {
        "name": "Process",
        "color": "19962E"
      }
    },
    {
      "event": "labeled",
      "id": 12899167949,
      "node_id": "LE_lADOAN28mc58eb5UzwAAAAMA2a7N",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12899167949",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T18:36:22Z",
      "label": {
        "name": "PR Author action required",
        "color": "e99695"
      }
    },
    {
      "event": "reviewed",
      "id": 2072163244,
      "node_id": "PRR_kwDOAN28mc57grOs",
      "url": null,
      "actor": null,
      "commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "Dragankamil6@gmail.com",
      "user": {
        "login": "KamPuc86zg",
        "id": 124597058,
        "node_id": "U_kgDOB20zQg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124597058?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/KamPuc86zg",
        "html_url": "https://github.com/KamPuc86zg",
        "followers_url": "https://api.github.com/users/KamPuc86zg/followers",
        "following_url": "https://api.github.com/users/KamPuc86zg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/KamPuc86zg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/KamPuc86zg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/KamPuc86zg/subscriptions",
        "organizations_url": "https://api.github.com/users/KamPuc86zg/orgs",
        "repos_url": "https://api.github.com/users/KamPuc86zg/repos",
        "events_url": "https://api.github.com/users/KamPuc86zg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/KamPuc86zg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2072163244",
      "submitted_at": "2024-05-22T19:17:27Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "reviewed",
      "id": 2072185868,
      "node_id": "PRR_kwDOAN28mc57gwwM",
      "url": null,
      "actor": null,
      "commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "ProofOfKeags",
        "id": 4033651,
        "node_id": "MDQ6VXNlcjQwMzM2NTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4033651?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ProofOfKeags",
        "html_url": "https://github.com/ProofOfKeags",
        "followers_url": "https://api.github.com/users/ProofOfKeags/followers",
        "following_url": "https://api.github.com/users/ProofOfKeags/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ProofOfKeags/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ProofOfKeags/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ProofOfKeags/subscriptions",
        "organizations_url": "https://api.github.com/users/ProofOfKeags/orgs",
        "repos_url": "https://api.github.com/users/ProofOfKeags/repos",
        "events_url": "https://api.github.com/users/ProofOfKeags/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ProofOfKeags/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2072185868",
      "submitted_at": "2024-05-22T19:29:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12900017981,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAMA5qc9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12900017981",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T19:58:39Z"
    },
    {
      "event": "commented",
      "id": 2125647692,
      "node_id": "IC_kwDOAN28mc5-ss9M",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2125647692",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T20:00:56Z",
      "updated_at": "2024-05-22T20:00:56Z",
      "author_association": "MEMBER",
      "body": "Thanks @jonatack @murchandamus!\r\n\r\nI've added the number, and used that to update the file name, readme table, etc. Also took all of your suggestions.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2125647692",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "mentioned",
      "id": 12900040470,
      "node_id": "MEE_lADOAN28mc58eb5UzwAAAAMA5v8W",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12900040470",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T20:00:57Z"
    },
    {
      "event": "subscribed",
      "id": 12900040479,
      "node_id": "SE_lADOAN28mc58eb5UzwAAAAMA5v8f",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12900040479",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T20:00:57Z"
    },
    {
      "event": "mentioned",
      "id": 12900040500,
      "node_id": "MEE_lADOAN28mc58eb5UzwAAAAMA5v80",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12900040500",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T20:00:58Z"
    },
    {
      "event": "subscribed",
      "id": 12900040516,
      "node_id": "SE_lADOAN28mc58eb5UzwAAAAMA5v9E",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12900040516",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T20:00:58Z"
    },
    {
      "event": "renamed",
      "id": 12900105626,
      "node_id": "RTE_lADOAN28mc58eb5UzwAAAAMA5_2a",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12900105626",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T20:07:47Z",
      "rename": {
        "from": "Opt In Topologically Restricted Until Confirmation Transactions For More Robust Fee-bumping",
        "to": "BIP431: Opt In Topologically Restricted Until Confirmation Transactions For More Robust Fee-bumping"
      }
    },
    {
      "event": "unlabeled",
      "id": 12900108513,
      "node_id": "UNLE_lADOAN28mc58eb5UzwAAAAMA6Ajh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12900108513",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T20:08:05Z",
      "label": {
        "name": "PR Author action required",
        "color": "e99695"
      }
    },
    {
      "event": "reviewed",
      "id": 2072280386,
      "node_id": "PRR_kwDOAN28mc57hH1C",
      "url": null,
      "actor": null,
      "commit_id": "0fb58b40b9895a7c134628a041b3b8008460e914",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2072280386",
      "submitted_at": "2024-05-22T20:21:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12904399350,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAMBKYH2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12904399350",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T06:58:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12904496681,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAMBKv4p",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12904496681",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T07:07:38Z"
    },
    {
      "event": "reviewed",
      "id": 2073932335,
      "node_id": "PRR_kwDOAN28mc57nbIv",
      "url": null,
      "actor": null,
      "commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "ACK 32e4e44\r\n\r\nWith the tiny non-blocking nitpick that a few places in the doc use markdown `_` for italics (I think) where they should use `'' ` for [mediawiki italics](https://www.mediawiki.org/wiki/Help:Formatting#:~:text=You%20can%20format%20your%20text,apostrophes%20like%20''this''%20).",
      "user": {
        "login": "carlaKC",
        "id": 42311294,
        "node_id": "MDQ6VXNlcjQyMzExMjk0",
        "avatar_url": "https://avatars.githubusercontent.com/u/42311294?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/carlaKC",
        "html_url": "https://github.com/carlaKC",
        "followers_url": "https://api.github.com/users/carlaKC/followers",
        "following_url": "https://api.github.com/users/carlaKC/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/carlaKC/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/carlaKC/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/carlaKC/subscriptions",
        "organizations_url": "https://api.github.com/users/carlaKC/orgs",
        "repos_url": "https://api.github.com/users/carlaKC/repos",
        "events_url": "https://api.github.com/users/carlaKC/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/carlaKC/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2073932335",
      "submitted_at": "2024-05-23T13:12:47Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "reviewed",
      "id": 2073935501,
      "node_id": "PRR_kwDOAN28mc57nb6N",
      "url": null,
      "actor": null,
      "commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "This looks good to me and ready to go except for a couple nits (which I don’t think would need to hold up a merge) and a formatting issue:\r\n\r\n1. The JEDEC standard specifies that uppercase _K_ (kilo) refers to 1024¹ (and _M_ (mega), _G_ (giga) as 1024² and 1024³ respectively). However, since the numbers in your example are referring to a factor of 1000¹, they should be using lowercase _k_, the symbol of the [metric prefix kilo](https://en.wikipedia.org/wiki/Kilo-) referring to a factor of 1000¹. Therefore, it would be preferable if the units were updated to read \"kvB\" instead of \"KvB\", and \"ksats\" instead of \"Ksats\".\r\n\r\n2. AFAIU, technical writing standards generally recommend a space between the numerical value and unit symbol.\r\n\r\nE.g. using a space is recommended by the SI Standard,\r\n![image](https://github.com/bitcoin/bips/assets/4060799/68498d41-6b3a-4b7b-941e-62544d40dcb7) <sup>via https://www.nist.gov/pml/special-publication-330/sp-330-section-5</sup>\r\n\r\nby NIST,\r\n![image](https://github.com/bitcoin/bips/assets/4060799/9ec4913d-ef6f-4432-9ed1-bae719067573) <sup>via https://physics.nist.gov/cuu/Units/checklist.html</sup>\r\n\r\nas well as IEEE:\r\n![image](https://github.com/bitcoin/bips/assets/4060799/5c63b24d-27ed-45d5-a0c8-695ed977b3db) <sup>via https://academia.stackexchange.com/q/54885/8305</sup>\r\n\r\nMy personal preference is to separate the value and symbol with a [Narrow No-Break Space (U+202F)](https://www.compart.com/en/unicode/U+202F) as that provides the expected visual offset, renders as a smaller gap than a full length space, but still prevents unfortunate line breaks. My suggested changes already make use of NNBSPs.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2073935501",
      "submitted_at": "2024-05-23T13:46:47Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "reviewed",
      "id": 2074065659,
      "node_id": "PRR_kwDOAN28mc57n7r7",
      "url": null,
      "actor": null,
      "commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Oops, I overlooked a couple more values",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2074065659",
      "submitted_at": "2024-05-23T14:00:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12910461213,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAMBhgEd",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12910461213",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T14:27:52Z"
    },
    {
      "event": "reviewed",
      "id": 2074143209,
      "node_id": "PRR_kwDOAN28mc57oOnp",
      "url": null,
      "actor": null,
      "commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Thanks @carlaKC @murchandamus! I've fixed the italics, spacing, and \"k\".",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2074143209",
      "submitted_at": "2024-05-23T14:28:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "reviewed",
      "id": 2074255824,
      "node_id": "PRR_kwDOAN28mc57oqHQ",
      "url": null,
      "actor": null,
      "commit_id": "c0fb4172f3c40718a102897d34ce4c12562f6f68",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2074255824",
      "submitted_at": "2024-05-23T15:02:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDA0ZDNhMDYwOWI1NDg4MDVmYTJlYmFmNWQzYTQ5NWYxYjgxYTAwM2M",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "tree": {
        "sha": "7fd44122cb17711f084b415197dba2e882e8b9d7",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/7fd44122cb17711f084b415197dba2e882e8b9d7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/156e8aabe24c1253b38d61459791a939550a4b60",
          "sha": "156e8aabe24c1253b38d61459791a939550a4b60",
          "html_url": "https://github.com/bitcoin/bips/commit/156e8aabe24c1253b38d61459791a939550a4b60"
        }
      ],
      "message": "Define BIP431: TRUCs",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-05-23T15:33:00Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-01-15T16:26:55Z"
      },
      "sha": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12911426228,
      "node_id": "HRFPE_lADOAN28mc58eb5UzwAAAAMBlLq0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12911426228",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:33:23Z"
    },
    {
      "event": "reviewed",
      "id": 2077457981,
      "node_id": "PRR_kwDOAN28mc570349",
      "url": null,
      "actor": null,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "re-ACK 04d3a06 🤩 ",
      "user": {
        "login": "carlaKC",
        "id": 42311294,
        "node_id": "MDQ6VXNlcjQyMzExMjk0",
        "avatar_url": "https://avatars.githubusercontent.com/u/42311294?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/carlaKC",
        "html_url": "https://github.com/carlaKC",
        "followers_url": "https://api.github.com/users/carlaKC/followers",
        "following_url": "https://api.github.com/users/carlaKC/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/carlaKC/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/carlaKC/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/carlaKC/subscriptions",
        "organizations_url": "https://api.github.com/users/carlaKC/orgs",
        "repos_url": "https://api.github.com/users/carlaKC/repos",
        "events_url": "https://api.github.com/users/carlaKC/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/carlaKC/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2077457981",
      "submitted_at": "2024-05-24T17:10:40Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "commented",
      "id": 2134644059,
      "node_id": "IC_kwDOAN28mc5_PBVb",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2134644059",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T08:33:17Z",
      "updated_at": "2024-05-28T08:33:17Z",
      "author_association": "MEMBER",
      "body": "(I think this is ready, please lmk if there's anything left to do on my end)",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2134644059",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "assigned",
      "id": 12964468496,
      "node_id": "AE_lADOAN28mc58eb5UzwAAAAMEvhcQ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12964468496",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T00:42:32Z",
      "assignee": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 2084152024,
      "node_id": "PRR_kwDOAN28mc58OaLY",
      "url": null,
      "actor": null,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 04d3a0609b548805fa2ebaf5d3a495f1b81a003c\r\n\r\nRe-checked the RBF rules vs description headers.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#pullrequestreview-2084152024",
      "submitted_at": "2024-05-29T02:50:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
    },
    {
      "event": "merged",
      "id": 12965153132,
      "node_id": "ME_lADOAN28mc58eb5UzwAAAAMEyIls",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12965153132",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "10650becef658c63cae688ba565c66d69d515081",
      "commit_url": "https://api.github.com/repos/bitcoin/bips/commits/10650becef658c63cae688ba565c66d69d515081",
      "created_at": "2024-05-29T02:50:57Z"
    },
    {
      "event": "closed",
      "id": 12965153149,
      "node_id": "CE_lADOAN28mc58eb5UzwAAAAMEyIl9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12965153149",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T02:50:58Z"
    },
    {
      "event": "commented",
      "id": 2212153873,
      "node_id": "IC_kwDOAN28mc6D2soR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2212153873",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-07T01:21:37Z",
      "updated_at": "2024-07-07T01:21:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "This BIP is missing an explanation of how it is expected to work with future nVersion upgrades.\r\n\r\nEg if we add a third consensus critical transaction version, how should that interact with TRUC? Do we just add another version?\r\n\r\nObviously this is a serious drawback of mixing up mempool behavior and consensus code.",
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2212153873",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2214346473,
      "node_id": "IC_kwDOAN28mc6D_D7p",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2214346473",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T14:57:59Z",
      "updated_at": "2024-07-08T14:58:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "It seems to me that BIP 431 only applies to version 3 transactions. So, I’m not sure I understand your concern. If someone e.g. proposed giving meaning to version 4 in say a _BIP-v4_, it could propose how transactions with version 3 should interact with transactions of version 4 and then whoever implements BIP-v4 would follow those recommendations, while those that don’t implement it, would not.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2214346473",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2214366803,
      "node_id": "IC_kwDOAN28mc6D_I5T",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2214366803",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T15:02:37Z",
      "updated_at": "2024-07-08T15:02:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "TRUC behavior is not desirable for all transactions; it is not a clear upgrade.\r\n\r\nThus, the obvious question is how do we expect a future soft fork version upgrade to deal with this?\r\n\r\nFor example, consider what would have happened had we tried to introduce TRUC prior to v2 transactions.\r\n\r\nThis can of course be avoided by not using a version number to signal TRUC behavior. I do not see a reason why we actually need to do that, given how narrow the actual usage of TRUC is likely to be. Triggering it simply on zero fee transactions should be fine.\r\n\r\nOn July 8, 2024 4:58:22 PM GMT+02:00, murchandamus ***@***.***> wrote:\r\n>I’m not sure I understand your concern. If someone e.g. proposed giving meaning to version 4 in say a _BIP-v4_, it could propose how transactions with version 3 should interact with transactions of version 4 and then whoever implements BIP-v4 would follow those recommendations, while those that don’t implement it, would not.\r\n>\r\n",
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2214366803",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "head_ref_deleted",
      "id": 13425535921,
      "node_id": "HRDE_lADOAN28mc58eb5UzwAAAAMgOWux",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/13425535921",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T15:03:48Z"
    },
    {
      "event": "commented",
      "id": 2214444586,
      "node_id": "IC_kwDOAN28mc6D_b4q",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2214444586",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T15:27:52Z",
      "updated_at": "2024-07-08T15:27:52Z",
      "author_association": "MEMBER",
      "body": "I'd imagine that the author of a proposal that defines a new consensus rule under version=3 would consider what usage exists on the network, particularly if the rules described in this BIP are adopted by the network when that proposal is created. They would probably also want to explain why gating it on version=3 (or any version-related marker at all) is necessary.\r\n\r\nOf course, coordinating between all the many proposals may not be easy. Are you perhaps making an argument for why we should document proposed uses of version=3 in a central place to avoid creating and deploying conflicting uses?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2214444586",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2214509013,
      "node_id": "IC_kwDOAN28mc6D_rnV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2214509013",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T15:53:47Z",
      "updated_at": "2024-07-08T15:53:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "> TRUC behavior is not desirable for all transactions; it is not a clear upgrade. Thus, the obvious question is how do we expect a future soft fork version upgrade to deal with this? For example, consider what would have happened had we tried to introduce TRUC prior to v2 transactions.\r\n\r\nIt’s not clear to me where you see a problem. This BIP applies to transactions with version 3, not transactions signaling a version of 3 and higher.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2214509013",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2226227298,
      "node_id": "IC_kwDOAN28mc6EsYhi",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2226227298",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T19:25:09Z",
      "updated_at": "2024-07-12T19:25:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "So an obvious example of where TRUC's use of v3 transactions would cause a problem is if we had a situation similar to v2 transactions, where an upgrade happened that had wide applicability. Since TRUC is so limited, we'd need to have two different versions of the consensus upgrade for TRUC and non-TRUC transactions. Obviously, that would be a mess. This gets even worse when you consider that we all know that TRUC only mitigates pinning for a very narrow use-case, and people are already discussing extensions to TRUC with new version bits.\r\n\r\nMeanwhile, it would be quite easy for TRUC to achieve it's actual main goal of enabling empheral anchor outputs as quick fix by defining TRUC behavior as being enabled for zero-fee transactions.\r\n\r\nChoosing V3 didn't even do \"TRUC behavior\" cleanly as a bit: bin(3) = 0b11, two bits set.",
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2226227298",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2231389674,
      "node_id": "IC_kwDOAN28mc6FAE3q",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2231389674",
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T16:50:42Z",
      "updated_at": "2024-07-16T16:50:42Z",
      "author_association": "MEMBER",
      "body": "> Choosing V3 didn't even do \"TRUC behavior\" cleanly as a bit: bin(3) = 0b11, two bits set.\r\n\r\nLet’s say we have a hypothetical soft-fork in the future to clean all the pinning and transaction-relay jamming broken mess, nVersion is a 32-bit field, so we can still split it in two 16-bit halves: one set for truc-like policy behavior and one set for consensus validation.\r\n\r\nWithout an example, it’s quite theoretical as there are always other signaling options: the taproot annex, the input nsequence, the nlocktime field...",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2231389674",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    },
    {
      "event": "commented",
      "id": 2231872320,
      "node_id": "IC_kwDOAN28mc6FB6tA",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2231872320",
      "actor": {
        "login": "ProofOfKeags",
        "id": 4033651,
        "node_id": "MDQ6VXNlcjQwMzM2NTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4033651?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ProofOfKeags",
        "html_url": "https://github.com/ProofOfKeags",
        "followers_url": "https://api.github.com/users/ProofOfKeags/followers",
        "following_url": "https://api.github.com/users/ProofOfKeags/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ProofOfKeags/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ProofOfKeags/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ProofOfKeags/subscriptions",
        "organizations_url": "https://api.github.com/users/ProofOfKeags/orgs",
        "repos_url": "https://api.github.com/users/ProofOfKeags/repos",
        "events_url": "https://api.github.com/users/ProofOfKeags/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ProofOfKeags/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T21:40:53Z",
      "updated_at": "2024-07-16T21:40:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "> one set for truc-like policy behavior and one set for consensus validation.\r\n\r\nI do think that bifurcating things along consensus vs policy is likely a good idea. It would fully orthogonalize the problems. While consensus-invalid implies policy-invalid, I believe these are otherwise independent concerns and we should treat them as such in their signaling/encoding schemes.",
      "user": {
        "login": "ProofOfKeags",
        "id": 4033651,
        "node_id": "MDQ6VXNlcjQwMzM2NTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4033651?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ProofOfKeags",
        "html_url": "https://github.com/ProofOfKeags",
        "followers_url": "https://api.github.com/users/ProofOfKeags/followers",
        "following_url": "https://api.github.com/users/ProofOfKeags/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ProofOfKeags/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ProofOfKeags/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ProofOfKeags/subscriptions",
        "organizations_url": "https://api.github.com/users/ProofOfKeags/orgs",
        "repos_url": "https://api.github.com/users/ProofOfKeags/repos",
        "events_url": "https://api.github.com/users/ProofOfKeags/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ProofOfKeags/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1541#issuecomment-2231872320",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1541"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459403454",
      "pull_request_review_id": 1833321526,
      "id": 1459403454,
      "node_id": "PRRC_kwDOAN28mc5W_Lq-",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping abilities.",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 15,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "4bd12d5698404e28c70d4486316f4e1cca356896",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It’s not obvious to me what you are thinking of when you mention \"improved fee-bumping abilities\". Is that referring to the possibility of relaying a 0-fee transaction in a package? Otherwise, perhaps:\r\n\r\n```suggestion\r\nUsers can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping reliability.\r\n```",
      "created_at": "2024-01-19T17:29:48Z",
      "updated_at": "2024-01-19T18:09:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1459403454",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459403454"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459409445",
      "pull_request_review_id": 1833321526,
      "id": 1459409445,
      "node_id": "PRRC_kwDOAN28mc5W_NIl",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping abilities.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depends on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 41,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "4bd12d5698404e28c70d4486316f4e1cca356896",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nWhen the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\r\n```",
      "created_at": "2024-01-19T17:33:28Z",
      "updated_at": "2024-01-19T18:09:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1459409445",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459409445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459427035",
      "pull_request_review_id": 1833321526,
      "id": 1459427035,
      "node_id": "PRRC_kwDOAN28mc5W_Rbb",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping abilities.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depends on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the ancestor feerate of the descendant is too low to fee-bump B through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to replace 5 transactions and each has 21 or more descendants, the replacement will be rejected regardless of its fees.\n+\n+===RBF has no incentive compatibility requirement===\n+\n+There is currently no rule to enforce that a replacement transaction would be a better candidate for mining (Rule 6 is insufficient). A user could create a replacement transaction that pays more fees and is higher feerate, but would confirm slower than the original transaction.\n+\n+As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original. <ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Policy limits the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* A switch to cluster mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows *one more* child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Specification==\n+\n+This document describes one set of policy rules that can realistically be deployed today and is useful to today's applications. If mempool improvements enable more accurate rules or new application requirements emerge, it may be appropriate to implement a different set of policy rules to achieve the same goal.\n+<ref>Examples of potential changes:\n+* If increasing the maximum child size enables a new use case while still providing acceptable pinning bounds, we can loosen that rule.\n+* If [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393 cluster mempool] is implemented and some of the rules could be applied to all transactions instead of just v3, there is no need to specify them as additional rules.\n+* The implementation of things like \"replacement must be more incentive compatible\" could change.\n+</ref>\n+\n+===1 Parent with 1 Small Child===\n+\n+In addition to the node's other standardness and policy rules, the following rules apply to transactions with <code>nVersion</code> field set to 3 (\"v3 transaction\").\n+\n+1. A v3 transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any descendant of an unconfirmed v3 transaction must also be v3.\n+<ref>Rationale:\n+\n+Combined with Rule 1, this gives us the property of \"inherited signaling\" when descendants of unconfirmed transactions are created. Additionally, checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A v3 transaction can spend outputs from _confirmed_ non-v3 transactions.\n+\n+3. A v3 transaction's unconfirmed ancestors must all be v3.\n+<ref>Rationale:\n+\n+Ensure the ancestor feerate rule does not underestimate a to-be-replaced v3 mempool transaction's incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 103,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "4bd12d5698404e28c70d4486316f4e1cca356896",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The \"mempool\" here throws me off:\r\n\r\n```suggestion\r\nEnsure the ancestor feerate rule does not underestimate a to-be-replaced v3 transaction's incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.\r\n```",
      "created_at": "2024-01-19T17:41:49Z",
      "updated_at": "2024-01-19T18:09:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1459427035",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459427035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459437308",
      "pull_request_review_id": 1833321526,
      "id": 1459437308,
      "node_id": "PRRC_kwDOAN28mc5W_T78",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping abilities.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depends on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the ancestor feerate of the descendant is too low to fee-bump B through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to replace 5 transactions and each has 21 or more descendants, the replacement will be rejected regardless of its fees.\n+\n+===RBF has no incentive compatibility requirement===\n+\n+There is currently no rule to enforce that a replacement transaction would be a better candidate for mining (Rule 6 is insufficient). A user could create a replacement transaction that pays more fees and is higher feerate, but would confirm slower than the original transaction.\n+\n+As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original. <ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Policy limits the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* A switch to cluster mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows *one more* child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Specification==\n+\n+This document describes one set of policy rules that can realistically be deployed today and is useful to today's applications. If mempool improvements enable more accurate rules or new application requirements emerge, it may be appropriate to implement a different set of policy rules to achieve the same goal.\n+<ref>Examples of potential changes:\n+* If increasing the maximum child size enables a new use case while still providing acceptable pinning bounds, we can loosen that rule.\n+* If [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393 cluster mempool] is implemented and some of the rules could be applied to all transactions instead of just v3, there is no need to specify them as additional rules.\n+* The implementation of things like \"replacement must be more incentive compatible\" could change.\n+</ref>\n+\n+===1 Parent with 1 Small Child===\n+\n+In addition to the node's other standardness and policy rules, the following rules apply to transactions with <code>nVersion</code> field set to 3 (\"v3 transaction\").\n+\n+1. A v3 transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any descendant of an unconfirmed v3 transaction must also be v3.\n+<ref>Rationale:\n+\n+Combined with Rule 1, this gives us the property of \"inherited signaling\" when descendants of unconfirmed transactions are created. Additionally, checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A v3 transaction can spend outputs from _confirmed_ non-v3 transactions.\n+\n+3. A v3 transaction's unconfirmed ancestors must all be v3.\n+<ref>Rationale:\n+\n+Ensure the ancestor feerate rule does not underestimate a to-be-replaced v3 mempool transaction's incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.\n+</ref>\n+\n+4. A v3 transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to v3 transactions.\n+<ref>Rationale: The larger the descendant limit, the more transactions may need to be replaced. We want to address RBF Pinning with Rule 3 and Rule 5.\n+\n+Combined with the other rules, we have an effective cluster limit using the existing ancestor and descendant limits. We cannot increase the descendant limit any further without losing this bound on cluster size.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+5. A v3 transaction that has an unconfirmed v3 ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB bounds the potential fees by a factor of 100.",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 118,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "4bd12d5698404e28c70d4486316f4e1cca356896",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How about:\r\n\r\n```suggestion\r\n<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\r\n```",
      "created_at": "2024-01-19T17:47:51Z",
      "updated_at": "2024-01-19T18:09:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1459437308",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459437308"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459449494",
      "pull_request_review_id": 1833321526,
      "id": 1459449494,
      "node_id": "PRRC_kwDOAN28mc5W_W6W",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping abilities.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depends on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the ancestor feerate of the descendant is too low to fee-bump B through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to replace 5 transactions and each has 21 or more descendants, the replacement will be rejected regardless of its fees.\n+\n+===RBF has no incentive compatibility requirement===\n+\n+There is currently no rule to enforce that a replacement transaction would be a better candidate for mining (Rule 6 is insufficient). A user could create a replacement transaction that pays more fees and is higher feerate, but would confirm slower than the original transaction.\n+\n+As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original. <ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Policy limits the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* A switch to cluster mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows *one more* child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Specification==\n+\n+This document describes one set of policy rules that can realistically be deployed today and is useful to today's applications. If mempool improvements enable more accurate rules or new application requirements emerge, it may be appropriate to implement a different set of policy rules to achieve the same goal.\n+<ref>Examples of potential changes:\n+* If increasing the maximum child size enables a new use case while still providing acceptable pinning bounds, we can loosen that rule.\n+* If [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393 cluster mempool] is implemented and some of the rules could be applied to all transactions instead of just v3, there is no need to specify them as additional rules.\n+* The implementation of things like \"replacement must be more incentive compatible\" could change.\n+</ref>\n+\n+===1 Parent with 1 Small Child===\n+\n+In addition to the node's other standardness and policy rules, the following rules apply to transactions with <code>nVersion</code> field set to 3 (\"v3 transaction\").\n+\n+1. A v3 transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any descendant of an unconfirmed v3 transaction must also be v3.\n+<ref>Rationale:\n+\n+Combined with Rule 1, this gives us the property of \"inherited signaling\" when descendants of unconfirmed transactions are created. Additionally, checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A v3 transaction can spend outputs from _confirmed_ non-v3 transactions.\n+\n+3. A v3 transaction's unconfirmed ancestors must all be v3.\n+<ref>Rationale:\n+\n+Ensure the ancestor feerate rule does not underestimate a to-be-replaced v3 mempool transaction's incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.\n+</ref>\n+\n+4. A v3 transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to v3 transactions.\n+<ref>Rationale: The larger the descendant limit, the more transactions may need to be replaced. We want to address RBF Pinning with Rule 3 and Rule 5.\n+\n+Combined with the other rules, we have an effective cluster limit using the existing ancestor and descendant limits. We cannot increase the descendant limit any further without losing this bound on cluster size.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+5. A v3 transaction that has an unconfirmed v3 ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB bounds the potential fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the v3 child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+6. A v3 transaction cannot have more than 1 unconfirmed ancestor.\n+<ref>Rationale: Prevent the child of an unconfirmed v3 transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+Combined with the other rules, we have an effective cluster limit using the existing ancestor and descendant limits. We cannot increase the ancestor limit any further without losing this bound on cluster size.\n+</ref>\n+\n+7. An individual v3 transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes v3 transactions much easier to reason about, which enables implementing additional RBF features\n+<ref>\n+For example, [https://github.com/bitcoin/bitcoin/pull/28984 this implementation] of package RBF compares the replacement and to-be-replaced transaction(s) using their ancestor scores. This score is accurate for v3 transactions due to their limited cluster size.\n+</ref>.\n+\n+\n+Implementation: https://github.com/bitcoin/bitcoin/pull/28948 and https://github.com/bitcoin/bitcoin/pull/28984\n+\n+==Backward Compatibility==\n+\n+Transactions with <code>nVersion=3</code> were previously nonstandard. There are no known conflicts with previous usage.\n+\n+==Intended Usage==\n+\n+Generally, users with no interest in spending unconfirmed outputs from a transaction can use v3 for more robust RBF abilities.\n+\n+This proposal allows for a different solution to fee-bumping in LN, in which commitment transations are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\n+<ref>Proposals for changes to LN commitment transaction format using v3 and a single anchor:\n+* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]\n+* [https://github.com/instagibbs/bolts/commits/zero_fee_commitment bolts proposal branch]\n+* See \"Intended usage for LN\" section in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html \"New transaction policies (nVersion=3) for contracting protocols\"]\n+</ref>.\n+A similar fee-bumping model can also be used in other contracting protocols\n+<ref>Examples of non-LN protocols that have shown interest in, designed, or built fee-bumping using v3:\n+* A LN-Symmetry implementation using v3 and ephemeral anchors: [https://delvingbitcoin.org/t/ln-symmetry-project-recap/359 LN-Symmetry Project Recap] [https://github.com/instagibbs/lightning/tree/eltoo_support branch]\n+* See \"Managing Fees Safely\" mentioning ephemeral anchors in [https://jameso.be/vaults.pdf \"Vaults and Covenants\"]\n+</ref>.\n+\n+==Related Work==\n+\n+The [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki Ephemeral Anchors] proposal builds on top of this one to add more features.\n+It changes the anchor script to be anyone can spend, allowing anybody to add fees and reducing the onchain footprint and fee costs.\n+It also allows anchor outputs to have 0 value, eliminating the need to deduct anchor output amounts from the channel balance.\n+\n+The [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/7 Cluster Mempool] proposal makes deeper changes to mempool structure and policy rules, allowing for more incentive-compatible RBF rules for all transactions (not just ones with special topology restrictions like v3), among other things.\n+\n+Cluster Mempool provides a more wholistic solution to some of the problems listed (such as adding an incentive compatibility requirement to RBF and safely enabling package RBF for more complex topologies). However, it does not help resolve RBF Pinning through Rule 3 and Rule 5. Also, since Cluster Mempool removes CPFP Carve Out<ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>, a policy like v3 is a beneficial intermediate step for applications that rely on it.",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 171,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "4bd12d5698404e28c70d4486316f4e1cca356896",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nCluster Mempool provides a more holistic solution to some of the problems listed (such as adding an incentive compatibility requirement to RBF and safely enabling package RBF for more complex topologies). However, it does not help resolve RBF Pinning through Rule 3 and Rule 5. Also, since Cluster Mempool removes CPFP Carve Out<ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>, a policy like v3 is a beneficial intermediate step for applications that rely on it.\r\n```",
      "created_at": "2024-01-19T17:55:11Z",
      "updated_at": "2024-01-19T18:09:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1459449494",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459449494"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 171,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459469874",
      "pull_request_review_id": 1833321526,
      "id": 1459469874,
      "node_id": "PRRC_kwDOAN28mc5W_b4y",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping abilities.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depends on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the ancestor feerate of the descendant is too low to fee-bump B through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to replace 5 transactions and each has 21 or more descendants, the replacement will be rejected regardless of its fees.\n+\n+===RBF has no incentive compatibility requirement===\n+\n+There is currently no rule to enforce that a replacement transaction would be a better candidate for mining (Rule 6 is insufficient). A user could create a replacement transaction that pays more fees and is higher feerate, but would confirm slower than the original transaction.\n+\n+As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original. <ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Policy limits the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* A switch to cluster mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows *one more* child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Specification==\n+\n+This document describes one set of policy rules that can realistically be deployed today and is useful to today's applications. If mempool improvements enable more accurate rules or new application requirements emerge, it may be appropriate to implement a different set of policy rules to achieve the same goal.\n+<ref>Examples of potential changes:\n+* If increasing the maximum child size enables a new use case while still providing acceptable pinning bounds, we can loosen that rule.\n+* If [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393 cluster mempool] is implemented and some of the rules could be applied to all transactions instead of just v3, there is no need to specify them as additional rules.\n+* The implementation of things like \"replacement must be more incentive compatible\" could change.\n+</ref>\n+\n+===1 Parent with 1 Small Child===\n+\n+In addition to the node's other standardness and policy rules, the following rules apply to transactions with <code>nVersion</code> field set to 3 (\"v3 transaction\").\n+\n+1. A v3 transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any descendant of an unconfirmed v3 transaction must also be v3.\n+<ref>Rationale:\n+\n+Combined with Rule 1, this gives us the property of \"inherited signaling\" when descendants of unconfirmed transactions are created. Additionally, checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A v3 transaction can spend outputs from _confirmed_ non-v3 transactions.\n+\n+3. A v3 transaction's unconfirmed ancestors must all be v3.\n+<ref>Rationale:\n+\n+Ensure the ancestor feerate rule does not underestimate a to-be-replaced v3 mempool transaction's incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 103,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "4bd12d5698404e28c70d4486316f4e1cca356896",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The last sentence makes use of Rule 4 which is only defined below. Perhaps the order of these two rules should be swapped?",
      "created_at": "2024-01-19T18:07:58Z",
      "updated_at": "2024-01-19T18:09:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1459469874",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1459469874"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461663070",
      "pull_request_review_id": 1836154484,
      "id": 1461663070,
      "node_id": "PRRC_kwDOAN28mc5XHzVe",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping abilities.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depends on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the ancestor feerate of the descendant is too low to fee-bump B through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to replace 5 transactions and each has 21 or more descendants, the replacement will be rejected regardless of its fees.\n+\n+===RBF has no incentive compatibility requirement===\n+\n+There is currently no rule to enforce that a replacement transaction would be a better candidate for mining (Rule 6 is insufficient). A user could create a replacement transaction that pays more fees and is higher feerate, but would confirm slower than the original transaction.\n+\n+As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original. <ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Policy limits the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* A switch to cluster mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows *one more* child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Specification==\n+\n+This document describes one set of policy rules that can realistically be deployed today and is useful to today's applications. If mempool improvements enable more accurate rules or new application requirements emerge, it may be appropriate to implement a different set of policy rules to achieve the same goal.\n+<ref>Examples of potential changes:\n+* If increasing the maximum child size enables a new use case while still providing acceptable pinning bounds, we can loosen that rule.\n+* If [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393 cluster mempool] is implemented and some of the rules could be applied to all transactions instead of just v3, there is no need to specify them as additional rules.\n+* The implementation of things like \"replacement must be more incentive compatible\" could change.\n+</ref>\n+\n+===1 Parent with 1 Small Child===\n+\n+In addition to the node's other standardness and policy rules, the following rules apply to transactions with <code>nVersion</code> field set to 3 (\"v3 transaction\").\n+\n+1. A v3 transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any descendant of an unconfirmed v3 transaction must also be v3.\n+<ref>Rationale:\n+\n+Combined with Rule 1, this gives us the property of \"inherited signaling\" when descendants of unconfirmed transactions are created. Additionally, checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A v3 transaction can spend outputs from _confirmed_ non-v3 transactions.\n+\n+3. A v3 transaction's unconfirmed ancestors must all be v3.\n+<ref>Rationale:\n+\n+Ensure the ancestor feerate rule does not underestimate a to-be-replaced v3 mempool transaction's incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 103,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "4bd12d5698404e28c70d4486316f4e1cca356896",
      "in_reply_to_id": 1459469874,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Consolidated the rules a bit to be more understandable and not have these referencing problems.",
      "created_at": "2024-01-22T10:34:40Z",
      "updated_at": "2024-01-22T10:34:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1461663070",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461663070"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461680558",
      "pull_request_review_id": 1836176115,
      "id": 1461680558,
      "node_id": "PRRC_kwDOAN28mc5XH3mu",
      "diff_hunk": "@@ -0,0 +1,250 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping reliability.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the ancestor feerate of the descendant is too low to fee-bump B through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to replace 5 transactions and each has 21 or more descendants, the replacement will be rejected regardless of its fees.\n+\n+===RBF has no incentive compatibility requirement===\n+\n+There is currently no rule to enforce that a replacement transaction would be a better candidate for mining (Rule 6 is insufficient). A user could create a replacement transaction that pays more fees and is higher feerate, but would confirm slower than the original transaction.\n+\n+As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original. <ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Policy limits the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* A switch to cluster mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows *one more* child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Specification==\n+\n+This document describes one set of policy rules that can realistically be deployed today and is useful to today's applications. If mempool improvements enable more accurate rules or new application requirements emerge, it may be appropriate to implement a different set of policy rules to achieve the same goal.\n+<ref>Examples of potential changes:\n+* If increasing the maximum child size enables a new use case while still providing acceptable pinning bounds, we can loosen that rule.\n+* If [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393 cluster mempool] is implemented and some of the rules could be applied to all transactions instead of just v3, there is no need to specify them as additional rules.\n+* The implementation of things like \"replacement must be more incentive compatible\" could change.\n+</ref>\n+\n+===1 Parent with 1 Small Child===\n+\n+In addition to the node's other standardness and policy rules, the following rules apply to transactions with <code>nVersion</code> field set to 3 (\"v3 transaction\").\n+\n+1. A v3 transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. A v3 transaction's unconfirmed ancestors must all be v3. Any descendant of an unconfirmed v3 transaction must also be v3.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none v3 makes it possible to enforce v3 toplogy limits. For example, the v3 descendant limit would not be very meaningful if it could be bypassed by creating a non-v3 child.\n+* Combined with Rule 1, inheriting v3 gives us the property of \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A v3 transaction can spend outputs from _confirmed_ non-v3 transactions.\n+\n+3. An unconfirmed v3 transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed v3 transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to v3 transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed v3 transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A v3 transaction that has an unconfirmed v3 ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the v3 child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+5. An individual v3 transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes v3 transactions much easier to reason about, which enables implementing additional RBF features\n+<ref>\n+For example, [https://github.com/bitcoin/bitcoin/pull/28984 this implementation] of package RBF compares the replacement and to-be-replaced transaction(s) using their ancestor scores. This score is accurate for v3 transactions due to their limited cluster size.\n+</ref>.\n+\n+\n+Implementation: https://github.com/bitcoin/bitcoin/pull/28948 and https://github.com/bitcoin/bitcoin/pull/28984\n+\n+==Backward Compatibility==\n+\n+Transactions with <code>nVersion=3</code> were previously nonstandard. There are no known conflicts with previous usage.\n+\n+==Intended Usage==\n+\n+Generally, users with no interest in spending unconfirmed outputs from a transaction can use v3 for more robust RBF abilities.\n+\n+This proposal allows for a different solution to fee-bumping in LN, in which commitment transations are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\n+<ref>Proposals for changes to LN commitment transaction format using v3 and a single anchor:\n+* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 149,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "af8e9038e6142264b55d6bb2d2599fd9f5adbc43",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nThis proposal allows for a different solution to fee-bumping in LN, in which commitment transactions are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\r\n<ref>Proposals for changes to LN commitment transaction format using v3 and a single anchor:\r\n* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]\r\n```",
      "created_at": "2024-01-22T10:46:25Z",
      "updated_at": "2024-01-22T11:45:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1461680558",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461680558"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": 147,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461688616",
      "pull_request_review_id": 1836176115,
      "id": 1461688616,
      "node_id": "PRRC_kwDOAN28mc5XH5ko",
      "diff_hunk": "@@ -0,0 +1,250 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping reliability.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the ancestor feerate of the descendant is too low to fee-bump B through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to replace 5 transactions and each has 21 or more descendants, the replacement will be rejected regardless of its fees.\n+\n+===RBF has no incentive compatibility requirement===\n+\n+There is currently no rule to enforce that a replacement transaction would be a better candidate for mining (Rule 6 is insufficient). A user could create a replacement transaction that pays more fees and is higher feerate, but would confirm slower than the original transaction.\n+\n+As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original. <ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Policy limits the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* A switch to cluster mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows *one more* child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Specification==\n+\n+This document describes one set of policy rules that can realistically be deployed today and is useful to today's applications. If mempool improvements enable more accurate rules or new application requirements emerge, it may be appropriate to implement a different set of policy rules to achieve the same goal.\n+<ref>Examples of potential changes:\n+* If increasing the maximum child size enables a new use case while still providing acceptable pinning bounds, we can loosen that rule.\n+* If [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393 cluster mempool] is implemented and some of the rules could be applied to all transactions instead of just v3, there is no need to specify them as additional rules.\n+* The implementation of things like \"replacement must be more incentive compatible\" could change.\n+</ref>\n+\n+===1 Parent with 1 Small Child===\n+\n+In addition to the node's other standardness and policy rules, the following rules apply to transactions with <code>nVersion</code> field set to 3 (\"v3 transaction\").\n+\n+1. A v3 transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. A v3 transaction's unconfirmed ancestors must all be v3. Any descendant of an unconfirmed v3 transaction must also be v3.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none v3 makes it possible to enforce v3 toplogy limits. For example, the v3 descendant limit would not be very meaningful if it could be bypassed by creating a non-v3 child.\n+* Combined with Rule 1, inheriting v3 gives us the property of \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A v3 transaction can spend outputs from _confirmed_ non-v3 transactions.\n+\n+3. An unconfirmed v3 transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed v3 transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to v3 transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed v3 transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A v3 transaction that has an unconfirmed v3 ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the v3 child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+5. An individual v3 transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes v3 transactions much easier to reason about, which enables implementing additional RBF features\n+<ref>\n+For example, [https://github.com/bitcoin/bitcoin/pull/28984 this implementation] of package RBF compares the replacement and to-be-replaced transaction(s) using their ancestor scores. This score is accurate for v3 transactions due to their limited cluster size.\n+</ref>.\n+\n+\n+Implementation: https://github.com/bitcoin/bitcoin/pull/28948 and https://github.com/bitcoin/bitcoin/pull/28984\n+\n+==Backward Compatibility==\n+\n+Transactions with <code>nVersion=3</code> were previously nonstandard. There are no known conflicts with previous usage.\n+\n+==Intended Usage==\n+\n+Generally, users with no interest in spending unconfirmed outputs from a transaction can use v3 for more robust RBF abilities.\n+\n+This proposal allows for a different solution to fee-bumping in LN, in which commitment transations are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\n+<ref>Proposals for changes to LN commitment transaction format using v3 and a single anchor:\n+* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]\n+* [https://github.com/instagibbs/bolts/commits/zero_fee_commitment bolts proposal branch]\n+* See \"Intended usage for LN\" section in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html \"New transaction policies (nVersion=3) for contracting protocols\"]\n+</ref>.\n+A similar fee-bumping model can also be used in other contracting protocols\n+<ref>Examples of non-LN protocols that have shown interest in, designed, or built fee-bumping using v3:\n+* A LN-Symmetry implementation using v3 and ephemeral anchors: [https://delvingbitcoin.org/t/ln-symmetry-project-recap/359 LN-Symmetry Project Recap] [https://github.com/instagibbs/lightning/tree/eltoo_support branch]\n+* See \"Managing Fees Safely\" mentioning ephemeral anchors in [https://jameso.be/vaults.pdf \"Vaults and Covenants\"]\n+</ref>.\n+\n+==Related Work==\n+\n+The [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki Ephemeral Anchors] proposal builds on top of this one to add more features.\n+It changes the anchor script to be anyone can spend, allowing anybody to add fees and reducing the onchain footprint and fee costs.\n+It also allows anchor outputs to have 0 value, eliminating the need to deduct anchor output amounts from the channel balance.\n+\n+The [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/7 Cluster Mempool] proposal makes deeper changes to mempool structure and policy rules, allowing for more incentive-compatible RBF rules for all transactions (not just ones with special topology restrictions like v3), among other things.\n+\n+Cluster Mempool provides a more holistic solution to some of the problems listed (such as adding an incentive compatibility requirement to RBF and safely enabling package RBF for more complex topologies). However, it does not help resolve RBF Pinning through Rule 3 and Rule 5. Also, since Cluster Mempool removes CPFP Carve Out<ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>, a policy like v3 is a beneficial intermediate step for applications that rely on it.\n+\n+[https://bitcoinops.org/en/topics/package-relay Package Relay] includes changes in p2p protocol, transaction relay logic, and mempool policy to enable nodes to accept and relay packages of transactions. Much of this proposal's utility relies on the existence of package relay for 1 parent and 1 child (the package topology v3 supports).\n+\n+==Alternatives==\n+\n+Various alternatives have been proposed across multiple discussion threads\n+<ref>Proposals and discussions dedicated to improving RBF:\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff \"RBF Improvements\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html \"Improving RBF Policy\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+<br />Proposals and discussions dedicated to improving or creating new fee-bumping mechanisms:\n+* [https://github.com/lightning/bolts/pull/1036 \"Add option to sign commitments at various feerates\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019243.html \"A Stroll through Fee-Bumping Techniques : Input-Based vs Child-Pay-For-Parent\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html \"A Replacement for RBF and CPFP: Non-Destructive TXID Dependencies for Fee Sponsoring\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019879.html \"Thoughts on fee bumping\"]\n+</ref>.\n+Some alternatives work in conjunction with this proposal (see Related Work).\n+\n+A few popular ideas that were not incorporated into this work are summarized here.\n+\n+===Alternatives: add static incentive compatibility rule in RBF policy===\n+\n+Add incentive compatibility requirement to RBF policy using some existing score or static calculation\n+<ref>Examples of such proposals and suggestions:\n+* [https://github.com/bitcoin/bitcoin/pull/23121 \"check ancestor feerate in RBF, remove BIP125 Rule2\"]\n+* [https://github.com/bitcoin/bitcoin/pull/26451 \"Enforce incentive compatibility for all RBF replacements\"]\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019841.html\n+* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081349#gistcomment-4081349\n+</ref>.\n+\n+As the incentive compatibility \"score\" of a transaction must be dynamically calculated given the structure of mempools today, there is no satisfactory solution. A full calculation is too computationally expensive. Static values can overestimate or underestimate, leading to more pinning problems <ref>Four examples of static calculations and an example in which they are all inaccurate: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#mining-score-of-a-mempool-transaction</ref>.\n+The ability to calculate incentive compatibility scores efficiently is a primary feature and motivation for both v3 and cluster mempool.\n+\n+===Alternatives: replace by feerate===\n+\n+Instead of using Rule 3 and 4, allow replacements with a higher feerate.\n+One variation of this proposal is to apply this rule in certain exceptional scenarios or when the replacement would confirm \"soon\"\n+<ref>Examples of such proposals and suggestions:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#fees-in-next-block-and-feerate-for-the-rest-of-the-mempool]\n+</ref>.\n+\n+A general removal of Rule 3 and 4 is not feasible as it opens the door to DoS attacks. It seems unclear how to design and implement a useful and safe threshold at which the rules can be bypassed (the notion of confirming \"soon\" is messy and may be too complex to implement), if such a threshold exists at all\n+<ref>Concerns\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017020.html\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017002.html\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019879.html\n+* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4044451#gistcomment-4044451\n+</ref>.\n+As such, the v3 proposal just aims to help users avoid such scenarios as much as possible.\n+\n+===Alternatives: implement rate-limiting without fee rules===\n+Since Rule 3 and 4 are for rate-limiting, replace them with a mempool-wide or per-peer rate limits on replacements by outpoint and/or bandwidth\n+<ref>Examples of such proposals and suggestions:\n+* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081349#gistcomment-4081349\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019820.html\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017024.html\n+<br />Related proposal for changing the amount of bandwidth that replacement transations use:",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 225,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "af8e9038e6142264b55d6bb2d2599fd9f5adbc43",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n<br />Related proposal for changing the amount of bandwidth that replacement transactions use:\r\n```",
      "created_at": "2024-01-22T10:53:20Z",
      "updated_at": "2024-01-22T11:45:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1461688616",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461688616"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461702468",
      "pull_request_review_id": 1836176115,
      "id": 1461702468,
      "node_id": "PRRC_kwDOAN28mc5XH89E",
      "diff_hunk": "@@ -0,0 +1,250 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping reliability.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the ancestor feerate of the descendant is too low to fee-bump B through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to replace 5 transactions and each has 21 or more descendants, the replacement will be rejected regardless of its fees.\n+\n+===RBF has no incentive compatibility requirement===\n+\n+There is currently no rule to enforce that a replacement transaction would be a better candidate for mining (Rule 6 is insufficient). A user could create a replacement transaction that pays more fees and is higher feerate, but would confirm slower than the original transaction.\n+\n+As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original. <ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Policy limits the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* A switch to cluster mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows *one more* child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Specification==\n+\n+This document describes one set of policy rules that can realistically be deployed today and is useful to today's applications. If mempool improvements enable more accurate rules or new application requirements emerge, it may be appropriate to implement a different set of policy rules to achieve the same goal.\n+<ref>Examples of potential changes:\n+* If increasing the maximum child size enables a new use case while still providing acceptable pinning bounds, we can loosen that rule.\n+* If [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393 cluster mempool] is implemented and some of the rules could be applied to all transactions instead of just v3, there is no need to specify them as additional rules.\n+* The implementation of things like \"replacement must be more incentive compatible\" could change.\n+</ref>\n+\n+===1 Parent with 1 Small Child===\n+\n+In addition to the node's other standardness and policy rules, the following rules apply to transactions with <code>nVersion</code> field set to 3 (\"v3 transaction\").\n+\n+1. A v3 transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. A v3 transaction's unconfirmed ancestors must all be v3. Any descendant of an unconfirmed v3 transaction must also be v3.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none v3 makes it possible to enforce v3 toplogy limits. For example, the v3 descendant limit would not be very meaningful if it could be bypassed by creating a non-v3 child.\n+* Combined with Rule 1, inheriting v3 gives us the property of \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A v3 transaction can spend outputs from _confirmed_ non-v3 transactions.\n+\n+3. An unconfirmed v3 transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed v3 transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to v3 transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed v3 transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A v3 transaction that has an unconfirmed v3 ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the v3 child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+5. An individual v3 transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes v3 transactions much easier to reason about, which enables implementing additional RBF features\n+<ref>\n+For example, [https://github.com/bitcoin/bitcoin/pull/28984 this implementation] of package RBF compares the replacement and to-be-replaced transaction(s) using their ancestor scores. This score is accurate for v3 transactions due to their limited cluster size.",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 133,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "af8e9038e6142264b55d6bb2d2599fd9f5adbc43",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The implementation is now using the fee rate diagram for incentive compatibility check",
      "created_at": "2024-01-22T11:05:14Z",
      "updated_at": "2024-01-22T11:45:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1461702468",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461702468"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461859382",
      "pull_request_review_id": 1836465848,
      "id": 1461859382,
      "node_id": "PRRC_kwDOAN28mc5XIjQ2",
      "diff_hunk": "@@ -0,0 +1,250 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Opt-in Policy For More Robust Fee-bumping\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction (making it a \"v3 transaction\") to opt in to restrictions on spending unconfirmed outputs in exchange for improved fee-bumping reliability.\n+Mempools apply a different set of policies to these transactions, including topology restrictions that make it easier to assess their incentive compatibility.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, restricting package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the transaction that would be more profitable for a miner. RBF is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies that make trade-offs between incentive compatibility and DoS-resistance are not always perfect. In some cases, malicious actors may exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the ancestor feerate of the descendant is too low to fee-bump B through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to replace 5 transactions and each has 21 or more descendants, the replacement will be rejected regardless of its fees.\n+\n+===RBF has no incentive compatibility requirement===\n+\n+There is currently no rule to enforce that a replacement transaction would be a better candidate for mining (Rule 6 is insufficient). A user could create a replacement transaction that pays more fees and is higher feerate, but would confirm slower than the original transaction.\n+\n+As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original. <ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Policy limits the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* A switch to cluster mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows *one more* child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Specification==\n+\n+This document describes one set of policy rules that can realistically be deployed today and is useful to today's applications. If mempool improvements enable more accurate rules or new application requirements emerge, it may be appropriate to implement a different set of policy rules to achieve the same goal.\n+<ref>Examples of potential changes:\n+* If increasing the maximum child size enables a new use case while still providing acceptable pinning bounds, we can loosen that rule.\n+* If [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393 cluster mempool] is implemented and some of the rules could be applied to all transactions instead of just v3, there is no need to specify them as additional rules.\n+* The implementation of things like \"replacement must be more incentive compatible\" could change.\n+</ref>\n+\n+===1 Parent with 1 Small Child===\n+\n+In addition to the node's other standardness and policy rules, the following rules apply to transactions with <code>nVersion</code> field set to 3 (\"v3 transaction\").\n+\n+1. A v3 transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. A v3 transaction's unconfirmed ancestors must all be v3. Any descendant of an unconfirmed v3 transaction must also be v3.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none v3 makes it possible to enforce v3 toplogy limits. For example, the v3 descendant limit would not be very meaningful if it could be bypassed by creating a non-v3 child.\n+* Combined with Rule 1, inheriting v3 gives us the property of \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A v3 transaction can spend outputs from _confirmed_ non-v3 transactions.\n+\n+3. An unconfirmed v3 transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed v3 transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to v3 transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed v3 transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if v3 transactions can only have v3 ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A v3 transaction that has an unconfirmed v3 ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the v3 child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+5. An individual v3 transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes v3 transactions much easier to reason about, which enables implementing additional RBF features\n+<ref>\n+For example, [https://github.com/bitcoin/bitcoin/pull/28984 this implementation] of package RBF compares the replacement and to-be-replaced transaction(s) using their ancestor scores. This score is accurate for v3 transactions due to their limited cluster size.",
      "path": "bip-v3.mediawiki",
      "position": null,
      "original_position": 133,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "af8e9038e6142264b55d6bb2d2599fd9f5adbc43",
      "in_reply_to_id": 1461702468,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Made the language more ambiguous",
      "created_at": "2024-01-22T13:25:42Z",
      "updated_at": "2024-01-22T13:25:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1461859382",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1461859382"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535901739",
      "pull_request_review_id": 1955315690,
      "id": 1535901739,
      "node_id": "PRRC_kwDOAN28mc5bjAAr",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 15,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How about:\r\n\r\n```suggestion\r\nSenders can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation (TRUC) transactions) to achieve improved fee-bumping reliability. Nodes apply stricter mempool policies to these transactions. The resulting topological restrictions make it easier to assess the incentive compatibility of accepting or replacing them.\r\n```\r\n\r\nOr maybe:\r\n\r\n```suggestion\r\nUsers can set <code>nVersion=3</code> to voluntarily declare a transaction _Topologically Restricted Until Confirmation (TRUC)_. Nodes apply stricter mempool policies to TRUC transactions in form of limits on spending of their unconfirmed outputs. These restrictions improve fee-bumping reliability by simplifying assessing the incentive compatibility of accepting or replacing TRUC transactions.\r\n```\r\n",
      "created_at": "2024-03-22T16:58:24Z",
      "updated_at": "2024-03-22T18:32:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1535901739",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535901739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535969360",
      "pull_request_review_id": 1955315690,
      "id": 1535969360,
      "node_id": "PRRC_kwDOAN28mc5bjQhQ",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 24,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nInstead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\r\n```",
      "created_at": "2024-03-22T17:44:02Z",
      "updated_at": "2024-03-22T18:32:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1535969360",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535969360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535974533",
      "pull_request_review_id": 1955315690,
      "id": 1535974533,
      "node_id": "PRRC_kwDOAN28mc5bjRyF",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. As such, creating higher feerate double-spends (replacements) is often employed by users as a fee-bumping mechanism.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 28,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe:\r\n\r\n```suggestion\r\nto keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their payments.\r\n```",
      "created_at": "2024-03-22T17:48:32Z",
      "updated_at": "2024-03-22T18:32:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1535974533",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535974533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535986988",
      "pull_request_review_id": 1955315690,
      "id": 1535986988,
      "node_id": "PRRC_kwDOAN28mc5bjU0s",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. As such, creating higher feerate double-spends (replacements) is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 32,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nPinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\r\n```",
      "created_at": "2024-03-22T17:56:24Z",
      "updated_at": "2024-03-22T18:32:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1535986988",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535986988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535989159",
      "pull_request_review_id": 1955315690,
      "id": 1535989159,
      "node_id": "PRRC_kwDOAN28mc5bjVWn",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. As such, creating higher feerate double-spends (replacements) is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 40,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nWhen the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\r\n```",
      "created_at": "2024-03-22T17:58:32Z",
      "updated_at": "2024-03-22T18:32:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1535989159",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1535989159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538883898",
      "pull_request_review_id": 1959823589,
      "id": 1538883898,
      "node_id": "PRRC_kwDOAN28mc5buYE6",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. As such, creating higher feerate double-spends (replacements) is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is important to security.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 40,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": 1535989159,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "taken",
      "created_at": "2024-03-26T09:36:34Z",
      "updated_at": "2024-03-26T09:37:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1538883898",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538883898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538883989",
      "pull_request_review_id": 1959823589,
      "id": 1538883989,
      "node_id": "PRRC_kwDOAN28mc5buYGV",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. As such, creating higher feerate double-spends (replacements) is often employed by users as a fee-bumping mechanism.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is very relevant to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 32,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": 1535986988,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "taken",
      "created_at": "2024-03-26T09:36:37Z",
      "updated_at": "2024-03-26T09:37:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1538883989",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538883989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538884092",
      "pull_request_review_id": 1959823589,
      "id": 1538884092,
      "node_id": "PRRC_kwDOAN28mc5buYH8",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. As such, creating higher feerate double-spends (replacements) is often employed by users as a fee-bumping mechanism.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 28,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": 1535974533,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "taken",
      "created_at": "2024-03-26T09:36:42Z",
      "updated_at": "2024-03-26T09:37:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1538884092",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538884092"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538884172",
      "pull_request_review_id": 1959823589,
      "id": 1538884172,
      "node_id": "PRRC_kwDOAN28mc5buYJM",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first transaction, many mempools also have some kind of Replace by Fee (RBF) policy",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 24,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": 1535969360,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "taken",
      "created_at": "2024-03-26T09:36:45Z",
      "updated_at": "2024-03-26T09:37:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1538884172",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538884172"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538884767",
      "pull_request_review_id": 1959823589,
      "id": 1538884767,
      "node_id": "PRRC_kwDOAN28mc5buYSf",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Users can set <code>nVersion=3</code> on a transaction to opt in to restrictions on spending unconfirmed outputs (making them Topologically Restricted Until Confirmation or TRUC transactions) in exchange for improved fee-bumping reliability. Nodes apply a different set of mempool policies to these transactions. Namely, topological restrictions that make it easier to assess the incentive compatibility of accepting or replacing them.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 15,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "63e8a7191f8ab2453e5971e62f709df613ae224c",
      "in_reply_to_id": 1535901739,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "took some of this",
      "created_at": "2024-03-26T09:37:11Z",
      "updated_at": "2024-03-26T09:37:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1538884767",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1538884767"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1576299745",
      "pull_request_review_id": 2017332470,
      "id": 1576299745,
      "node_id": "PRRC_kwDOAN28mc5d9Gzh",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 4,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "158acdbbbf8ef13f6b345b6281a96e88e20d2cf9",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: The title is longer than 44 characters",
      "created_at": "2024-04-23T13:49:27Z",
      "updated_at": "2024-04-23T14:27:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1576299745",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1576299745"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1576321710",
      "pull_request_review_id": 2017332470,
      "id": 1576321710,
      "node_id": "PRRC_kwDOAN28mc5d9MKu",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 10,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "158acdbbbf8ef13f6b345b6281a96e88e20d2cf9",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Please add the \"Post-History\" header in the preamble and link to relevant mailing list threads and other discussions (e.g. delving).",
      "created_at": "2024-04-23T14:02:20Z",
      "updated_at": "2024-04-23T14:27:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1576321710",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1576321710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1577703389",
      "pull_request_review_id": 2019560525,
      "id": 1577703389,
      "node_id": "PRRC_kwDOAN28mc5eCdfd",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 10,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "158acdbbbf8ef13f6b345b6281a96e88e20d2cf9",
      "in_reply_to_id": 1576321710,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done, thanks",
      "created_at": "2024-04-24T11:05:13Z",
      "updated_at": "2024-04-24T11:05:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1577703389",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1577703389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1577703681",
      "pull_request_review_id": 2019561095,
      "id": 1577703681,
      "node_id": "PRRC_kwDOAN28mc5eCdkB",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topologically Restricted Until Confirmation Transactions",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 4,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "158acdbbbf8ef13f6b345b6281a96e88e20d2cf9",
      "in_reply_to_id": 1576299745,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "changed. 44 is not a lot of characters!",
      "created_at": "2024-04-24T11:05:32Z",
      "updated_at": "2024-04-24T11:05:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1577703681",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1577703681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1581564711",
      "pull_request_review_id": 2025913665,
      "id": 1581564711,
      "node_id": "PRRC_kwDOAN28mc5eRMMn",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 95,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nSenders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\r\n```",
      "created_at": "2024-04-26T21:41:46Z",
      "updated_at": "2024-04-26T21:42:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1581564711",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1581564711"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1608968660",
      "pull_request_review_id": 2069649072,
      "id": 1608968660,
      "node_id": "PRRC_kwDOAN28mc5f5unU",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 63,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool\"\r\n\r\nI'm having trouble parsing what this means, help :)",
      "created_at": "2024-05-21T21:23:12Z",
      "updated_at": "2024-05-21T23:01:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1608968660",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1608968660"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609012696",
      "pull_request_review_id": 2069649072,
      "id": 1609012696,
      "node_id": "PRRC_kwDOAN28mc5f55XY",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the toplogy limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 102,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\r\n```",
      "created_at": "2024-05-21T22:22:45Z",
      "updated_at": "2024-05-21T23:01:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1609012696",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609012696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609017496",
      "pull_request_review_id": 2069649072,
      "id": 1609017496,
      "node_id": "PRRC_kwDOAN28mc5f56iY",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the toplogy limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 117,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\r\n```\r\n\r\nor: \"than that of the package.\"",
      "created_at": "2024-05-21T22:29:47Z",
      "updated_at": "2024-05-21T23:01:54Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1609017496",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609017496"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609023219",
      "pull_request_review_id": 2069649072,
      "id": 1609023219,
      "node_id": "PRRC_kwDOAN28mc5f577z",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the toplogy limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 123,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is this section 4 related to https://github.com/bitcoin/bitcoin/pull/29873 (and potentially would need updating)?",
      "created_at": "2024-05-21T22:38:55Z",
      "updated_at": "2024-05-21T23:01:54Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1609023219",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609023219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609026069",
      "pull_request_review_id": 2069649072,
      "id": 1609026069,
      "node_id": "PRRC_kwDOAN28mc5f58oV",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the toplogy limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+5. An individual TRUC transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+====Implementation====\n+\n+- https://github.com/bitcoin/bitcoin/pull/28948\n+- https://github.com/bitcoin/bitcoin/pull/29496\n+\n+====Related Work====\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes the transactions much easier to reason about, which enables additional features like\n+feerate diagram comparisons\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29242 this PR] implements feerate diagram creation and comparison for sets of transactions in which the maximum cluster size is 2, e.g. all TRUC transactions.\n+</ref>,\n+package RBF\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/28984 this PR] implements package RBF, enforcing incentive compatibility by comparing the feerate diagrams of the mempool before and after replacement. The feerate diagrams are easy to build when the relevant clusters are of size 2 and below, so package RBF is restricted to those scenarios. As TRUC transactions always have this property, package RBF is enabled for TRUC transactions.\n+</ref>,\n+and sibling eviction\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29306 This PR] implements sibling eviction for TRUC transactions: if a new transaction would exceed a transaction's descendant limit, it considers evicting the existing descendant using replacement rules. Sibling eviction is feasible for TRUC transactions because there is no difficulty in identifying which descendant to evict (there can only be 1).\n+</ref>.\n+\n+The [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki Ephemeral Anchors] proposal builds on top of this one to add more features.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 159,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could now link to the BIP draft (https://github.com/bitcoin/bips/pull/1524) here instead?",
      "created_at": "2024-05-21T22:43:31Z",
      "updated_at": "2024-05-21T23:01:54Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1609026069",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609026069"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609032109",
      "pull_request_review_id": 2069649072,
      "id": 1609032109,
      "node_id": "PRRC_kwDOAN28mc5f5-Gt",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the toplogy limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+5. An individual TRUC transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+====Implementation====\n+\n+- https://github.com/bitcoin/bitcoin/pull/28948\n+- https://github.com/bitcoin/bitcoin/pull/29496\n+\n+====Related Work====\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes the transactions much easier to reason about, which enables additional features like\n+feerate diagram comparisons\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29242 this PR] implements feerate diagram creation and comparison for sets of transactions in which the maximum cluster size is 2, e.g. all TRUC transactions.\n+</ref>,\n+package RBF\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/28984 this PR] implements package RBF, enforcing incentive compatibility by comparing the feerate diagrams of the mempool before and after replacement. The feerate diagrams are easy to build when the relevant clusters are of size 2 and below, so package RBF is restricted to those scenarios. As TRUC transactions always have this property, package RBF is enabled for TRUC transactions.\n+</ref>,\n+and sibling eviction\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29306 This PR] implements sibling eviction for TRUC transactions: if a new transaction would exceed a transaction's descendant limit, it considers evicting the existing descendant using replacement rules. Sibling eviction is feasible for TRUC transactions because there is no difficulty in identifying which descendant to evict (there can only be 1).\n+</ref>.\n+\n+The [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki Ephemeral Anchors] proposal builds on top of this one to add more features.\n+It changes the anchor script to be anyone can spend, allowing anybody to add fees and reducing the onchain footprint and fee costs.\n+It also allows anchor outputs to have 0 value, eliminating the need to deduct value from the input amount in order to create anchors.\n+\n+The [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/7 Cluster Mempool] proposal makes fundamental changes to mempool structure and policy rules, enabling the accurate assessment of the incentive compatibility of accepting or removing a transaction, among other things. Notably, Cluster Mempool introduces a limit to all transactions' cluster size to make incentive compatibility calculations feasible. This cluster limit is similar to TRUC limits in that it bounds computation to enable improved policies, but is applied to all transactions (not just ones that opt in) and is much less restrictive than TRUC limits.\n+\n+Cluster Mempool provides a more holistic solution to some of the problems listed (such as adding an incentive compatibility requirement to RBF and safely enabling package RBF for more complex topologies). However, it does not help resolve all problems (such as RBF Pinning through Rule 3 and Rule 5). Also, since Cluster Mempool is incompatible with CPFP Carve Out<ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>, TRUC with sibling eviction and package RBF provide an alternative solution to applications that rely on it.\n+\n+Building on top of Cluster Mempool, there are also various ideas for extending TRUC transactions and creating another anti-pinning policy\n+<ref>https://delvingbitcoin.org/t/v3-and-some-possible-futures/523/3</ref>.\n+\n+[https://bitcoinops.org/en/topics/package-relay Package Relay] includes changes in p2p protocol, transaction relay logic, and mempool policy to enable nodes to accept and relay packages of transactions. Much of this proposal's utility relies on the existence of package relay for 1-parent-1-child packages (the topology TRUC supports).\n+\n+====Backward Compatibility====\n+\n+Transactions with <code>nVersion=3</code> were previously nonstandard. There are no known conflicts with previous usage.\n+\n+====Intended Usage====\n+\n+Generally, users with no interest in spending unconfirmed outputs from a transaction can make them TRUC transactions for more robust RBF abilities.\n+\n+This proposal allows for a different solution to fee-bumping in LN, in which commitment transactions are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\n+<ref>Proposals for changes to LN commitment transaction format using TRUC and a single anchor:\n+* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]\n+* [https://github.com/instagibbs/bolts/commits/zero_fee_commitment bolts proposal branch]\n+* See \"Intended usage for LN\" section in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html \"New transaction policies (nVersion=3) for contracting protocols\"]\n+</ref>.\n+A similar fee-bumping model can also be used in other contracting protocols\n+<ref>Examples of non-LN protocols that have shown interest in, designed, or built fee-bumping using TRUC:\n+* A LN-Symmetry implementation using TRUC and ephemeral anchors: [https://delvingbitcoin.org/t/ln-symmetry-project-recap/359 LN-Symmetry Project Recap] [https://github.com/instagibbs/lightning/tree/eltoo_support branch]\n+* See \"Managing Fees Safely\" mentioning ephemeral anchors in [https://jameso.be/vaults.pdf \"Vaults and Covenants\"]\n+</ref>.\n+\n+==Alternatives==\n+\n+Various alternatives for RBF\n+<ref>Proposals and discussions dedicated to improving RBF:\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff \"RBF Improvements\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html \"Improving RBF Policy\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+</ref>\n+and new fee-bumping mechanisms\n+<ref>\n+<br />Proposals and discussions dedicated to improving or creating new fee-bumping mechanisms:\n+* [https://github.com/lightning/bolts/pull/1036 \"Add option to sign commitments at various feerates\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019243.html \"A Stroll through Fee-Bumping Techniques : Input-Based vs Child-Pay-For-Parent\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html \"A Replacement for RBF and CPFP: Non-Destructive TXID Dependencies for Fee Sponsoring\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019879.html \"Thoughts on fee bumping\"]\n+</ref>\n+have been proposed across multiple discussion threads.\n+Most alternatives do not conflict with TRUC, and some work in conjunction with this proposal - see Related Work.\n+A few popular ideas that were not incorporated into this work are summarized here.\n+\n+===Alternatives: add static incentive compatibility rule in RBF policy===\n+\n+Add incentive compatibility requirement to RBF policy using some existing score or static calculation\n+<ref>Examples of incentive compatibility score proposals and suggestions:\n+* [https://github.com/bitcoin/bitcoin/pull/23121 \"check ancestor feerate in RBF, remove BIP125 Rule2\"]\n+* [https://github.com/bitcoin/bitcoin/pull/26451 \"Enforce incentive compatibility for all RBF replacements\"]\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019841.html\n+* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081349#gistcomment-4081349\n+</ref>.\n+\n+As the incentive compatibility \"score\" of a transaction must be dynamically calculated given the structure of mempools today, there is no satisfactory solution. A full calculation is too computationally expensive. Static values can overestimate or underestimate, leading to more pinning problems <ref>Four examples of static calculations and an example in which they are all inaccurate: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#mining-score-of-a-mempool-transaction</ref>.\n+The ability to calculate incentive compatibility scores efficiently is a primary feature and motivation for both TRUC transactions and Cluster Mempool.\n+\n+===Alternatives: replace by feerate===\n+\n+\"Instead of using Rule 3 and/or 4, allow replacements with a higher feerate.\"\n+\n+One variation of this proposal is to apply this rule in certain exceptional scenarios or when the replacement would confirm \"soon\"\n+<ref>Examples of Replace by Feerate proposals and suggestions:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#fees-in-next-block-and-feerate-for-the-rest-of-the-mempool]\n+* [https://petertodd.org/2024/one-shot-replace-by-fee-rate \"One-Shot Replace-by-Fee-Rate\"]\n+</ref>.\n+\n+The primary problem with these proposals is the potential for free relay and DDoS attacks.\n+\n+Removing Rule 3 and 4 in general would allow free relay\n+<ref>Examples of free relay with the removal of Rule 3 and/or 4:\n+<br/> Consider a rule where the fee can be decreased (remove Rule 3 and 4) but the feerate must double. In this scenario, a 100KvB transaction can be replaced by a 100vB transaction paying 200 sats. That's 200 sats to relay 100,200vB of transaction data, which is less than 0.002sat/vB. It becomes quite cheap to replace large portions of the mempool, decreasing both its average feerate and total absolute fees.\n+\n+<br/>Consider a rule where the fee can stay the same (keep Rule 3 but drop Rule 4) but the feerate must double. The attacker can start out with 100KvB transaction, paying 1sat/vB. A user can reduce its size over and over again, doubling the feerate each time until it gets too small, and end up paying 100Ksat for 100KvB(1 + 1/2 + 1/4 + ... log2(mintxsize)) -> approaches 200KvB. This means the attacker pays a\n+rate of 0.5sat/vB to relay transactions, which is below our \"free relay\" threshold of 1/sat/vB.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 243,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nrate of 0.5sat/vB to relay transactions, which is below our \"free relay\" threshold of 1sat/vB.\r\n```",
      "created_at": "2024-05-21T22:54:10Z",
      "updated_at": "2024-05-21T23:01:54Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1609032109",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609032109"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609057611",
      "pull_request_review_id": 2069795341,
      "id": 1609057611,
      "node_id": "PRRC_kwDOAN28mc5f6EVL",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 8,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Suggest `Informational` per https://github.com/bitcoin/bips/pull/1524#discussion_r1581577736.",
      "created_at": "2024-05-21T23:36:27Z",
      "updated_at": "2024-05-21T23:36:27Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1609057611",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1609057611"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610527890",
      "pull_request_review_id": 2072162968,
      "id": 1610527890,
      "node_id": "PRRC_kwDOAN28mc5f_rSS",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 8,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": 1609057611,
      "user": {
        "login": "KamPuc86zg",
        "id": 124597058,
        "node_id": "U_kgDOB20zQg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124597058?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/KamPuc86zg",
        "html_url": "https://github.com/KamPuc86zg",
        "followers_url": "https://api.github.com/users/KamPuc86zg/followers",
        "following_url": "https://api.github.com/users/KamPuc86zg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/KamPuc86zg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/KamPuc86zg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/KamPuc86zg/subscriptions",
        "organizations_url": "https://api.github.com/users/KamPuc86zg/orgs",
        "repos_url": "https://api.github.com/users/KamPuc86zg/repos",
        "events_url": "https://api.github.com/users/KamPuc86zg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/KamPuc86zg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "bip-truc.mediawiki",
      "created_at": "2024-05-22T19:17:15Z",
      "updated_at": "2024-05-22T20:22:06Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1610527890",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610527890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610541230",
      "pull_request_review_id": 2072185868,
      "id": 1610541230,
      "node_id": "PRRC_kwDOAN28mc5f_uiu",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the toplogy limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 123,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "ProofOfKeags",
        "id": 4033651,
        "node_id": "MDQ6VXNlcjQwMzM2NTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4033651?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ProofOfKeags",
        "html_url": "https://github.com/ProofOfKeags",
        "followers_url": "https://api.github.com/users/ProofOfKeags/followers",
        "following_url": "https://api.github.com/users/ProofOfKeags/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ProofOfKeags/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ProofOfKeags/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ProofOfKeags/subscriptions",
        "organizations_url": "https://api.github.com/users/ProofOfKeags/orgs",
        "repos_url": "https://api.github.com/users/ProofOfKeags/repos",
        "events_url": "https://api.github.com/users/ProofOfKeags/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ProofOfKeags/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is \"sigop-adjusted virtual size\" formally defined anywhere. I'm aware of the sigop limit and virtual size. I am unaware of how sigops may or may not \"adjust\" the virtual size.",
      "created_at": "2024-05-22T19:29:56Z",
      "updated_at": "2024-05-22T19:29:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1610541230",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610541230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610573864",
      "pull_request_review_id": 2072239638,
      "id": 1610573864,
      "node_id": "PRRC_kwDOAN28mc5f_2go",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the toplogy limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 123,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": 1610541230,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not really, apart from the code comments written in/since its introduction in https://github.com/bitcoin/bitcoin/pull/8365. This is one of the main reasons why I think policy ought to be documented more formally, as I and others have tripped on this quite a bit.\r\n\r\nAlso see https://github.com/bitcoin/bitcoin/pull/27591 (which I still need to get around to updating - up for grabs if you're interested).",
      "created_at": "2024-05-22T19:59:58Z",
      "updated_at": "2024-05-22T19:59:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1610573864",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610573864"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610597240",
      "pull_request_review_id": 2072280386,
      "id": 1610597240,
      "node_id": "PRRC_kwDOAN28mc5f_8N4",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 6,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "0fb58b40b9895a7c134628a041b3b8008460e914",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure, but I think the linter is balking because no link is provided here yet.",
      "created_at": "2024-05-22T20:21:20Z",
      "updated_at": "2024-05-22T20:21:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1610597240",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610597240"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 6,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610670047",
      "pull_request_review_id": 2072401266,
      "id": 1610670047,
      "node_id": "PRRC_kwDOAN28mc5gAN_f",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 6,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "0fb58b40b9895a7c134628a041b3b8008460e914",
      "in_reply_to_id": 1610597240,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Here's a diff that has `./scripts/buildtable.pl` running for me locally.\r\n\r\n```diff\r\n   Layer: Applications\r\n   Title: Topology Restrictions for Pinning\r\n   Author: Gloria Zhao <gloriajzhao@gmail.com>\r\n-  Comments-URI:\r\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\r\n   Status: Draft\r\n   Type: Informational\r\n   Created: 2024-01-10\r\n   License: BSD-3-Clause\r\n   Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\r\n-               2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\r\n-               2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\r\n-               2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\r\n-               2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\r\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\r\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\r\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\r\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\r\n </pre>\r\n```\r\n",
      "created_at": "2024-05-22T21:24:18Z",
      "updated_at": "2024-05-22T21:24:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1610670047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610670047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 6,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610747211",
      "pull_request_review_id": 2072521915,
      "id": 1610747211,
      "node_id": "PRRC_kwDOAN28mc5gAg1L",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the toplogy limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 123,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": 1610541230,
      "user": {
        "login": "ProofOfKeags",
        "id": 4033651,
        "node_id": "MDQ6VXNlcjQwMzM2NTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4033651?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ProofOfKeags",
        "html_url": "https://github.com/ProofOfKeags",
        "followers_url": "https://api.github.com/users/ProofOfKeags/followers",
        "following_url": "https://api.github.com/users/ProofOfKeags/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ProofOfKeags/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ProofOfKeags/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ProofOfKeags/subscriptions",
        "organizations_url": "https://api.github.com/users/ProofOfKeags/orgs",
        "repos_url": "https://api.github.com/users/ProofOfKeags/repos",
        "events_url": "https://api.github.com/users/ProofOfKeags/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ProofOfKeags/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Got it. Reading that link indicates that on a *policy* level Core attaches a vByte price to sigops when evaluating mempool/relay stuff. However, at the *consensus* level we just have a sigops limit as well as a minimum vByte threshold per sigop?",
      "created_at": "2024-05-22T22:36:04Z",
      "updated_at": "2024-05-22T22:36:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1610747211",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1610747211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611126862",
      "pull_request_review_id": 2073052611,
      "id": 1611126862,
      "node_id": "PRRC_kwDOAN28mc5gB9hO",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+<pre>\n+  BIP: ???\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:\n+  Status: Draft\n+  Type: ???\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+\t\t2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+\t\t2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+\t\t2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+\t\t2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that accepting a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Sepcifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the toplogy limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.",
      "path": "bip-truc.mediawiki",
      "position": null,
      "original_position": 123,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "f2d33b5cf01e04e190a3493a74c220fb64266ee8",
      "in_reply_to_id": 1610541230,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Correct. It's simplifying a 2D Knapsack problem by rolling both values into 1 score.\r\n\r\nI'm going to mark this thread as resolved as I don't think this  BIP would be the right place for defining it. Please feel free to comment on the above PR, open a stack exchange question, or DM me if you have further questions.",
      "created_at": "2024-05-23T07:13:51Z",
      "updated_at": "2024-05-23T07:13:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611126862",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611126862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611128090",
      "pull_request_review_id": 2073055607,
      "id": 1611128090,
      "node_id": "PRRC_kwDOAN28mc5gB90a",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI:",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 6,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "0fb58b40b9895a7c134628a041b3b8008460e914",
      "in_reply_to_id": 1610597240,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That fixed it, thanks!",
      "created_at": "2024-05-23T07:14:40Z",
      "updated_at": "2024-05-23T07:14:41Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611128090",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611128090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 6,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611672327",
      "pull_request_review_id": 2073935501,
      "id": 1611672327,
      "node_id": "PRRC_kwDOAN28mc5gECsH",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+6. An individual TRUC transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+====Implementation====\n+\n+- https://github.com/bitcoin/bitcoin/pull/28948\n+- https://github.com/bitcoin/bitcoin/pull/29873\n+- https://github.com/bitcoin/bitcoin/pull/29496",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 146,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The syntax for unordered lists in the mediawiki format uses asterisks:\r\n\r\n```suggestion\r\n* https://github.com/bitcoin/bitcoin/pull/28948\r\n* https://github.com/bitcoin/bitcoin/pull/29873\r\n* https://github.com/bitcoin/bitcoin/pull/29496\r\n```",
      "created_at": "2024-05-23T13:14:02Z",
      "updated_at": "2024-05-23T13:46:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611672327",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611672327"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611676401",
      "pull_request_review_id": 2073935501,
      "id": 1611676401,
      "node_id": "PRRC_kwDOAN28mc5gEDrx",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+6. An individual TRUC transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+====Implementation====\n+\n+- https://github.com/bitcoin/bitcoin/pull/28948\n+- https://github.com/bitcoin/bitcoin/pull/29873\n+- https://github.com/bitcoin/bitcoin/pull/29496\n+\n+====Related Work====\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes the transactions much easier to reason about, which enables additional features like\n+feerate diagram comparisons\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29242 this PR] implements feerate diagram creation and comparison for sets of transactions in which the maximum cluster size is 2, e.g. all TRUC transactions.\n+</ref>,\n+package RBF\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/28984 this PR] implements package RBF, enforcing incentive compatibility by comparing the feerate diagrams of the mempool before and after replacement. The feerate diagrams are easy to build when the relevant clusters are of size 2 and below, so package RBF is restricted to those scenarios. As TRUC transactions always have this property, package RBF is enabled for TRUC transactions.\n+</ref>,\n+and sibling eviction\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29306 This PR] implements sibling eviction for TRUC transactions: if a new transaction would exceed a transaction's descendant limit, it considers evicting the existing descendant using replacement rules. Sibling eviction is feasible for TRUC transactions because there is no difficulty in identifying which descendant to evict (there can only be 1).\n+</ref>.\n+\n+The [https://github.com/bitcoin/bips/pull/1524 Ephemeral Anchors] proposal builds on top of this one to add more features.\n+It changes the anchor script to be anyone can spend, allowing anybody to add fees and reducing the onchain footprint and fee costs.\n+It also allows anchor outputs to have 0 value, eliminating the need to deduct value from the input amount in order to create anchors.\n+\n+The [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/7 Cluster Mempool] proposal makes fundamental changes to mempool structure and policy rules, enabling the accurate assessment of the incentive compatibility of accepting or removing a transaction, among other things. Notably, Cluster Mempool introduces a limit to all transactions' cluster size to make incentive compatibility calculations feasible. This cluster limit is similar to TRUC limits in that it bounds computation to enable improved policies, but is applied to all transactions (not just ones that opt in) and is much less restrictive than TRUC limits.\n+\n+Cluster Mempool provides a more holistic solution to some of the problems listed (such as adding an incentive compatibility requirement to RBF and safely enabling package RBF for more complex topologies). However, it does not help resolve all problems (such as RBF Pinning through Rule 3 and Rule 5). Also, since Cluster Mempool is incompatible with CPFP Carve Out<ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>, TRUC with sibling eviction and package RBF provide an alternative solution to applications that rely on it.\n+\n+Building on top of Cluster Mempool, there are also various ideas for extending TRUC transactions and creating another anti-pinning policy\n+<ref>https://delvingbitcoin.org/t/v3-and-some-possible-futures/523/3</ref>.\n+\n+[https://bitcoinops.org/en/topics/package-relay Package Relay] includes changes in p2p protocol, transaction relay logic, and mempool policy to enable nodes to accept and relay packages of transactions. Much of this proposal's utility relies on the existence of package relay for 1-parent-1-child packages (the topology TRUC supports).\n+\n+====Backward Compatibility====\n+\n+Transactions with <code>nVersion=3</code> were previously nonstandard. There are no known conflicts with previous usage.\n+\n+====Intended Usage====\n+\n+Generally, users with no interest in spending unconfirmed outputs from a transaction can make them TRUC transactions for more robust RBF abilities.\n+\n+This proposal allows for a different solution to fee-bumping in LN, in which commitment transactions are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\n+<ref>Proposals for changes to LN commitment transaction format using TRUC and a single anchor:\n+* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]\n+* [https://github.com/instagibbs/bolts/commits/zero_fee_commitment bolts proposal branch]\n+* See \"Intended usage for LN\" section in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html \"New transaction policies (nVersion=3) for contracting protocols\"]\n+</ref>.\n+A similar fee-bumping model can also be used in other contracting protocols\n+<ref>Examples of non-LN protocols that have shown interest in, designed, or built fee-bumping using TRUC:\n+* A LN-Symmetry implementation using TRUC and ephemeral anchors: [https://delvingbitcoin.org/t/ln-symmetry-project-recap/359 LN-Symmetry Project Recap] [https://github.com/instagibbs/lightning/tree/eltoo_support branch]\n+* See \"Managing Fees Safely\" mentioning ephemeral anchors in [https://jameso.be/vaults.pdf \"Vaults and Covenants\"]\n+</ref>.\n+\n+==Alternatives==\n+\n+Various alternatives for RBF\n+<ref>Proposals and discussions dedicated to improving RBF:\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff \"RBF Improvements\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html \"Improving RBF Policy\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+</ref>\n+and new fee-bumping mechanisms\n+<ref>\n+<br />Proposals and discussions dedicated to improving or creating new fee-bumping mechanisms:\n+* [https://github.com/lightning/bolts/pull/1036 \"Add option to sign commitments at various feerates\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019243.html \"A Stroll through Fee-Bumping Techniques : Input-Based vs Child-Pay-For-Parent\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html \"A Replacement for RBF and CPFP: Non-Destructive TXID Dependencies for Fee Sponsoring\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019879.html \"Thoughts on fee bumping\"]\n+</ref>\n+have been proposed across multiple discussion threads.\n+Most alternatives do not conflict with TRUC, and some work in conjunction with this proposal - see Related Work.\n+A few popular ideas that were not incorporated into this work are summarized here.\n+\n+===Alternatives: add static incentive compatibility rule in RBF policy===\n+\n+Add incentive compatibility requirement to RBF policy using some existing score or static calculation\n+<ref>Examples of incentive compatibility score proposals and suggestions:\n+* [https://github.com/bitcoin/bitcoin/pull/23121 \"check ancestor feerate in RBF, remove BIP125 Rule2\"]\n+* [https://github.com/bitcoin/bitcoin/pull/26451 \"Enforce incentive compatibility for all RBF replacements\"]\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019841.html\n+* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081349#gistcomment-4081349\n+</ref>.\n+\n+As the incentive compatibility \"score\" of a transaction must be dynamically calculated given the structure of mempools today, there is no satisfactory solution. A full calculation is too computationally expensive. Static values can overestimate or underestimate, leading to more pinning problems <ref>Four examples of static calculations and an example in which they are all inaccurate: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#mining-score-of-a-mempool-transaction</ref>.\n+The ability to calculate incentive compatibility scores efficiently is a primary feature and motivation for both TRUC transactions and Cluster Mempool.\n+\n+===Alternatives: replace by feerate===\n+\n+\"Instead of using Rule 3 and/or 4, allow replacements with a higher feerate.\"\n+\n+One variation of this proposal is to apply this rule in certain exceptional scenarios or when the replacement would confirm \"soon\"\n+<ref>Examples of Replace by Feerate proposals and suggestions:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#fees-in-next-block-and-feerate-for-the-rest-of-the-mempool]\n+* [https://petertodd.org/2024/one-shot-replace-by-fee-rate \"One-Shot Replace-by-Fee-Rate\"]\n+</ref>.\n+\n+The primary problem with these proposals is the potential for free relay and DDoS attacks.\n+\n+Removing Rule 3 and 4 in general would allow free relay\n+<ref>Examples of free relay with the removal of Rule 3 and/or 4:\n+<br/> Consider a rule where the fee can be decreased (remove Rule 3 and 4) but the feerate must double. In this scenario, a 100KvB transaction can be replaced by a 100vB transaction paying 200 sats. That's 200 sats to relay 100,200vB of transaction data, which is less than 0.002sat/vB. It becomes quite cheap to replace large portions of the mempool, decreasing both its average feerate and total absolute fees.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 245,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n<br/> Consider a rule where the fee can be decreased (remove Rule 3 and 4) but the feerate must double. In this scenario, a 100 kvB transaction can be replaced by a 100 vB transaction paying 200 sats. That's 200 sats to relay 100,200 vB of transaction data, which is less than 0.002 sat/vB. It becomes quite cheap to replace large portions of the mempool, decreasing both its average feerate and total absolute fees.\r\n```",
      "created_at": "2024-05-23T13:16:42Z",
      "updated_at": "2024-05-23T13:46:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611676401",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611676401"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611677147",
      "pull_request_review_id": 2073935501,
      "id": 1611677147,
      "node_id": "PRRC_kwDOAN28mc5gED3b",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+6. An individual TRUC transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+====Implementation====\n+\n+- https://github.com/bitcoin/bitcoin/pull/28948\n+- https://github.com/bitcoin/bitcoin/pull/29873\n+- https://github.com/bitcoin/bitcoin/pull/29496\n+\n+====Related Work====\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes the transactions much easier to reason about, which enables additional features like\n+feerate diagram comparisons\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29242 this PR] implements feerate diagram creation and comparison for sets of transactions in which the maximum cluster size is 2, e.g. all TRUC transactions.\n+</ref>,\n+package RBF\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/28984 this PR] implements package RBF, enforcing incentive compatibility by comparing the feerate diagrams of the mempool before and after replacement. The feerate diagrams are easy to build when the relevant clusters are of size 2 and below, so package RBF is restricted to those scenarios. As TRUC transactions always have this property, package RBF is enabled for TRUC transactions.\n+</ref>,\n+and sibling eviction\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29306 This PR] implements sibling eviction for TRUC transactions: if a new transaction would exceed a transaction's descendant limit, it considers evicting the existing descendant using replacement rules. Sibling eviction is feasible for TRUC transactions because there is no difficulty in identifying which descendant to evict (there can only be 1).\n+</ref>.\n+\n+The [https://github.com/bitcoin/bips/pull/1524 Ephemeral Anchors] proposal builds on top of this one to add more features.\n+It changes the anchor script to be anyone can spend, allowing anybody to add fees and reducing the onchain footprint and fee costs.\n+It also allows anchor outputs to have 0 value, eliminating the need to deduct value from the input amount in order to create anchors.\n+\n+The [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/7 Cluster Mempool] proposal makes fundamental changes to mempool structure and policy rules, enabling the accurate assessment of the incentive compatibility of accepting or removing a transaction, among other things. Notably, Cluster Mempool introduces a limit to all transactions' cluster size to make incentive compatibility calculations feasible. This cluster limit is similar to TRUC limits in that it bounds computation to enable improved policies, but is applied to all transactions (not just ones that opt in) and is much less restrictive than TRUC limits.\n+\n+Cluster Mempool provides a more holistic solution to some of the problems listed (such as adding an incentive compatibility requirement to RBF and safely enabling package RBF for more complex topologies). However, it does not help resolve all problems (such as RBF Pinning through Rule 3 and Rule 5). Also, since Cluster Mempool is incompatible with CPFP Carve Out<ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>, TRUC with sibling eviction and package RBF provide an alternative solution to applications that rely on it.\n+\n+Building on top of Cluster Mempool, there are also various ideas for extending TRUC transactions and creating another anti-pinning policy\n+<ref>https://delvingbitcoin.org/t/v3-and-some-possible-futures/523/3</ref>.\n+\n+[https://bitcoinops.org/en/topics/package-relay Package Relay] includes changes in p2p protocol, transaction relay logic, and mempool policy to enable nodes to accept and relay packages of transactions. Much of this proposal's utility relies on the existence of package relay for 1-parent-1-child packages (the topology TRUC supports).\n+\n+====Backward Compatibility====\n+\n+Transactions with <code>nVersion=3</code> were previously nonstandard. There are no known conflicts with previous usage.\n+\n+====Intended Usage====\n+\n+Generally, users with no interest in spending unconfirmed outputs from a transaction can make them TRUC transactions for more robust RBF abilities.\n+\n+This proposal allows for a different solution to fee-bumping in LN, in which commitment transactions are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\n+<ref>Proposals for changes to LN commitment transaction format using TRUC and a single anchor:\n+* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]\n+* [https://github.com/instagibbs/bolts/commits/zero_fee_commitment bolts proposal branch]\n+* See \"Intended usage for LN\" section in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html \"New transaction policies (nVersion=3) for contracting protocols\"]\n+</ref>.\n+A similar fee-bumping model can also be used in other contracting protocols\n+<ref>Examples of non-LN protocols that have shown interest in, designed, or built fee-bumping using TRUC:\n+* A LN-Symmetry implementation using TRUC and ephemeral anchors: [https://delvingbitcoin.org/t/ln-symmetry-project-recap/359 LN-Symmetry Project Recap] [https://github.com/instagibbs/lightning/tree/eltoo_support branch]\n+* See \"Managing Fees Safely\" mentioning ephemeral anchors in [https://jameso.be/vaults.pdf \"Vaults and Covenants\"]\n+</ref>.\n+\n+==Alternatives==\n+\n+Various alternatives for RBF\n+<ref>Proposals and discussions dedicated to improving RBF:\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff \"RBF Improvements\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html \"Improving RBF Policy\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+</ref>\n+and new fee-bumping mechanisms\n+<ref>\n+<br />Proposals and discussions dedicated to improving or creating new fee-bumping mechanisms:\n+* [https://github.com/lightning/bolts/pull/1036 \"Add option to sign commitments at various feerates\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019243.html \"A Stroll through Fee-Bumping Techniques : Input-Based vs Child-Pay-For-Parent\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html \"A Replacement for RBF and CPFP: Non-Destructive TXID Dependencies for Fee Sponsoring\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019879.html \"Thoughts on fee bumping\"]\n+</ref>\n+have been proposed across multiple discussion threads.\n+Most alternatives do not conflict with TRUC, and some work in conjunction with this proposal - see Related Work.\n+A few popular ideas that were not incorporated into this work are summarized here.\n+\n+===Alternatives: add static incentive compatibility rule in RBF policy===\n+\n+Add incentive compatibility requirement to RBF policy using some existing score or static calculation\n+<ref>Examples of incentive compatibility score proposals and suggestions:\n+* [https://github.com/bitcoin/bitcoin/pull/23121 \"check ancestor feerate in RBF, remove BIP125 Rule2\"]\n+* [https://github.com/bitcoin/bitcoin/pull/26451 \"Enforce incentive compatibility for all RBF replacements\"]\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019841.html\n+* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081349#gistcomment-4081349\n+</ref>.\n+\n+As the incentive compatibility \"score\" of a transaction must be dynamically calculated given the structure of mempools today, there is no satisfactory solution. A full calculation is too computationally expensive. Static values can overestimate or underestimate, leading to more pinning problems <ref>Four examples of static calculations and an example in which they are all inaccurate: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#mining-score-of-a-mempool-transaction</ref>.\n+The ability to calculate incentive compatibility scores efficiently is a primary feature and motivation for both TRUC transactions and Cluster Mempool.\n+\n+===Alternatives: replace by feerate===\n+\n+\"Instead of using Rule 3 and/or 4, allow replacements with a higher feerate.\"\n+\n+One variation of this proposal is to apply this rule in certain exceptional scenarios or when the replacement would confirm \"soon\"\n+<ref>Examples of Replace by Feerate proposals and suggestions:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#fees-in-next-block-and-feerate-for-the-rest-of-the-mempool]\n+* [https://petertodd.org/2024/one-shot-replace-by-fee-rate \"One-Shot Replace-by-Fee-Rate\"]\n+</ref>.\n+\n+The primary problem with these proposals is the potential for free relay and DDoS attacks.\n+\n+Removing Rule 3 and 4 in general would allow free relay\n+<ref>Examples of free relay with the removal of Rule 3 and/or 4:\n+<br/> Consider a rule where the fee can be decreased (remove Rule 3 and 4) but the feerate must double. In this scenario, a 100KvB transaction can be replaced by a 100vB transaction paying 200 sats. That's 200 sats to relay 100,200vB of transaction data, which is less than 0.002sat/vB. It becomes quite cheap to replace large portions of the mempool, decreasing both its average feerate and total absolute fees.\n+\n+<br/>Consider a rule where the fee can stay the same (keep Rule 3 but drop Rule 4) but the feerate must double. The attacker can start out with 100KvB transaction, paying 1sat/vB. A user can reduce its size over and over again, doubling the feerate each time until it gets too small, and end up paying 100Ksat for 100KvB(1 + 1/2 + 1/4 + ... log2(mintxsize)) -> approaches 200KvB. This means the attacker pays a rate of 0.5sat/vB to relay transactions, which is below our \"free relay\" threshold of 1sat/vB.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 247,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n<br/>Consider a rule where the fee can stay the same (keep Rule 3 but drop Rule 4) but the feerate must double. The attacker can start out with 100 kvB transaction, paying 1 sat/vB. A user can reduce its size over and over again, doubling the feerate each time until it gets too small, and end up paying 100 ksat for 100 kvB (1 + 1/2 + 1/4 + ... + log2(mintxsize)) -> approaches 200 kvB. This means the attacker pays a rate of 0.5 sat/vB to relay transactions, which is below our \"free relay\" threshold of 1 sat/vB.\r\n```",
      "created_at": "2024-05-23T13:17:08Z",
      "updated_at": "2024-05-23T13:46:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611677147",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611677147"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611677645",
      "pull_request_review_id": 2073935501,
      "id": 1611677645,
      "node_id": "PRRC_kwDOAN28mc5gED_N",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 132,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100 kvB) can have up to 1000 vB of descendants to be within the default descendant limit (101 kvB).\r\n```",
      "created_at": "2024-05-23T13:17:28Z",
      "updated_at": "2024-05-23T13:46:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611677645",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611677645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611695537",
      "pull_request_review_id": 2073935501,
      "id": 1611695537,
      "node_id": "PRRC_kwDOAN28mc5gEIWx",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 135,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000 vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\r\n```",
      "created_at": "2024-05-23T13:24:38Z",
      "updated_at": "2024-05-23T13:46:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611695537",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611695537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 135,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611751250",
      "pull_request_review_id": 2074065659,
      "id": 1611751250,
      "node_id": "PRRC_kwDOAN28mc5gEV9S",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 130,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000 vB, that might be an additional 100,000 sats (at 1 sat/vbyte) or more, depending on the feerate. Restricting all children to 1000 vB reduces the upper bound of the additional fees by a factor of 100.\r\n```",
      "created_at": "2024-05-23T13:57:58Z",
      "updated_at": "2024-05-23T14:00:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611751250",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611751250"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611751893",
      "pull_request_review_id": 2074065659,
      "id": 1611751893,
      "node_id": "PRRC_kwDOAN28mc5gEWHV",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 123,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000 vB.\r\n```",
      "created_at": "2024-05-23T13:58:23Z",
      "updated_at": "2024-05-23T14:00:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611751893",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611751893"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611752156",
      "pull_request_review_id": 2074065659,
      "id": 1611752156,
      "node_id": "PRRC_kwDOAN28mc5gEWLc",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 124,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000 vB seems much larger than necessary.\r\n```",
      "created_at": "2024-05-23T13:58:32Z",
      "updated_at": "2024-05-23T14:00:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611752156",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611752156"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611752408",
      "pull_request_review_id": 2074065659,
      "id": 1611752408,
      "node_id": "PRRC_kwDOAN28mc5gEWPY",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 127,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000 vB.\r\n```",
      "created_at": "2024-05-23T13:58:41Z",
      "updated_at": "2024-05-23T14:00:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611752408",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611752408"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611799700",
      "pull_request_review_id": 2074143209,
      "id": 1611799700,
      "node_id": "PRRC_kwDOAN28mc5gEhyU",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 123,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": 1611751893,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-05-23T14:25:15Z",
      "updated_at": "2024-05-23T14:28:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611799700",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611799700"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611799812",
      "pull_request_review_id": 2074143209,
      "id": 1611799812,
      "node_id": "PRRC_kwDOAN28mc5gEh0E",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 124,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": 1611752156,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-05-23T14:25:20Z",
      "updated_at": "2024-05-23T14:28:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611799812",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611799812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611799915",
      "pull_request_review_id": 2074143209,
      "id": 1611799915,
      "node_id": "PRRC_kwDOAN28mc5gEh1r",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 127,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": 1611752408,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-05-23T14:25:24Z",
      "updated_at": "2024-05-23T14:28:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611799915",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611799915"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801356",
      "pull_request_review_id": 2074143209,
      "id": 1611801356,
      "node_id": "PRRC_kwDOAN28mc5gEiMM",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 130,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": 1611751250,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-05-23T14:26:15Z",
      "updated_at": "2024-05-23T14:28:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611801356",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801462",
      "pull_request_review_id": 2074143209,
      "id": 1611801462,
      "node_id": "PRRC_kwDOAN28mc5gEiN2",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 132,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": 1611677645,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-05-23T14:26:18Z",
      "updated_at": "2024-05-23T14:28:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611801462",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801462"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801571",
      "pull_request_review_id": 2074143209,
      "id": 1611801571,
      "node_id": "PRRC_kwDOAN28mc5gEiPj",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 135,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": 1611695537,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-05-23T14:26:22Z",
      "updated_at": "2024-05-23T14:28:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611801571",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 135,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801662",
      "pull_request_review_id": 2074143209,
      "id": 1611801662,
      "node_id": "PRRC_kwDOAN28mc5gEiQ-",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+6. An individual TRUC transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+====Implementation====\n+\n+- https://github.com/bitcoin/bitcoin/pull/28948\n+- https://github.com/bitcoin/bitcoin/pull/29873\n+- https://github.com/bitcoin/bitcoin/pull/29496",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 146,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": 1611672327,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-05-23T14:26:25Z",
      "updated_at": "2024-05-23T14:28:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611801662",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801662"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801841",
      "pull_request_review_id": 2074143209,
      "id": 1611801841,
      "node_id": "PRRC_kwDOAN28mc5gEiTx",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+6. An individual TRUC transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+====Implementation====\n+\n+- https://github.com/bitcoin/bitcoin/pull/28948\n+- https://github.com/bitcoin/bitcoin/pull/29873\n+- https://github.com/bitcoin/bitcoin/pull/29496\n+\n+====Related Work====\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes the transactions much easier to reason about, which enables additional features like\n+feerate diagram comparisons\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29242 this PR] implements feerate diagram creation and comparison for sets of transactions in which the maximum cluster size is 2, e.g. all TRUC transactions.\n+</ref>,\n+package RBF\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/28984 this PR] implements package RBF, enforcing incentive compatibility by comparing the feerate diagrams of the mempool before and after replacement. The feerate diagrams are easy to build when the relevant clusters are of size 2 and below, so package RBF is restricted to those scenarios. As TRUC transactions always have this property, package RBF is enabled for TRUC transactions.\n+</ref>,\n+and sibling eviction\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29306 This PR] implements sibling eviction for TRUC transactions: if a new transaction would exceed a transaction's descendant limit, it considers evicting the existing descendant using replacement rules. Sibling eviction is feasible for TRUC transactions because there is no difficulty in identifying which descendant to evict (there can only be 1).\n+</ref>.\n+\n+The [https://github.com/bitcoin/bips/pull/1524 Ephemeral Anchors] proposal builds on top of this one to add more features.\n+It changes the anchor script to be anyone can spend, allowing anybody to add fees and reducing the onchain footprint and fee costs.\n+It also allows anchor outputs to have 0 value, eliminating the need to deduct value from the input amount in order to create anchors.\n+\n+The [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/7 Cluster Mempool] proposal makes fundamental changes to mempool structure and policy rules, enabling the accurate assessment of the incentive compatibility of accepting or removing a transaction, among other things. Notably, Cluster Mempool introduces a limit to all transactions' cluster size to make incentive compatibility calculations feasible. This cluster limit is similar to TRUC limits in that it bounds computation to enable improved policies, but is applied to all transactions (not just ones that opt in) and is much less restrictive than TRUC limits.\n+\n+Cluster Mempool provides a more holistic solution to some of the problems listed (such as adding an incentive compatibility requirement to RBF and safely enabling package RBF for more complex topologies). However, it does not help resolve all problems (such as RBF Pinning through Rule 3 and Rule 5). Also, since Cluster Mempool is incompatible with CPFP Carve Out<ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>, TRUC with sibling eviction and package RBF provide an alternative solution to applications that rely on it.\n+\n+Building on top of Cluster Mempool, there are also various ideas for extending TRUC transactions and creating another anti-pinning policy\n+<ref>https://delvingbitcoin.org/t/v3-and-some-possible-futures/523/3</ref>.\n+\n+[https://bitcoinops.org/en/topics/package-relay Package Relay] includes changes in p2p protocol, transaction relay logic, and mempool policy to enable nodes to accept and relay packages of transactions. Much of this proposal's utility relies on the existence of package relay for 1-parent-1-child packages (the topology TRUC supports).\n+\n+====Backward Compatibility====\n+\n+Transactions with <code>nVersion=3</code> were previously nonstandard. There are no known conflicts with previous usage.\n+\n+====Intended Usage====\n+\n+Generally, users with no interest in spending unconfirmed outputs from a transaction can make them TRUC transactions for more robust RBF abilities.\n+\n+This proposal allows for a different solution to fee-bumping in LN, in which commitment transactions are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\n+<ref>Proposals for changes to LN commitment transaction format using TRUC and a single anchor:\n+* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]\n+* [https://github.com/instagibbs/bolts/commits/zero_fee_commitment bolts proposal branch]\n+* See \"Intended usage for LN\" section in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html \"New transaction policies (nVersion=3) for contracting protocols\"]\n+</ref>.\n+A similar fee-bumping model can also be used in other contracting protocols\n+<ref>Examples of non-LN protocols that have shown interest in, designed, or built fee-bumping using TRUC:\n+* A LN-Symmetry implementation using TRUC and ephemeral anchors: [https://delvingbitcoin.org/t/ln-symmetry-project-recap/359 LN-Symmetry Project Recap] [https://github.com/instagibbs/lightning/tree/eltoo_support branch]\n+* See \"Managing Fees Safely\" mentioning ephemeral anchors in [https://jameso.be/vaults.pdf \"Vaults and Covenants\"]\n+</ref>.\n+\n+==Alternatives==\n+\n+Various alternatives for RBF\n+<ref>Proposals and discussions dedicated to improving RBF:\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff \"RBF Improvements\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html \"Improving RBF Policy\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+</ref>\n+and new fee-bumping mechanisms\n+<ref>\n+<br />Proposals and discussions dedicated to improving or creating new fee-bumping mechanisms:\n+* [https://github.com/lightning/bolts/pull/1036 \"Add option to sign commitments at various feerates\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019243.html \"A Stroll through Fee-Bumping Techniques : Input-Based vs Child-Pay-For-Parent\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html \"A Replacement for RBF and CPFP: Non-Destructive TXID Dependencies for Fee Sponsoring\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019879.html \"Thoughts on fee bumping\"]\n+</ref>\n+have been proposed across multiple discussion threads.\n+Most alternatives do not conflict with TRUC, and some work in conjunction with this proposal - see Related Work.\n+A few popular ideas that were not incorporated into this work are summarized here.\n+\n+===Alternatives: add static incentive compatibility rule in RBF policy===\n+\n+Add incentive compatibility requirement to RBF policy using some existing score or static calculation\n+<ref>Examples of incentive compatibility score proposals and suggestions:\n+* [https://github.com/bitcoin/bitcoin/pull/23121 \"check ancestor feerate in RBF, remove BIP125 Rule2\"]\n+* [https://github.com/bitcoin/bitcoin/pull/26451 \"Enforce incentive compatibility for all RBF replacements\"]\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019841.html\n+* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081349#gistcomment-4081349\n+</ref>.\n+\n+As the incentive compatibility \"score\" of a transaction must be dynamically calculated given the structure of mempools today, there is no satisfactory solution. A full calculation is too computationally expensive. Static values can overestimate or underestimate, leading to more pinning problems <ref>Four examples of static calculations and an example in which they are all inaccurate: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#mining-score-of-a-mempool-transaction</ref>.\n+The ability to calculate incentive compatibility scores efficiently is a primary feature and motivation for both TRUC transactions and Cluster Mempool.\n+\n+===Alternatives: replace by feerate===\n+\n+\"Instead of using Rule 3 and/or 4, allow replacements with a higher feerate.\"\n+\n+One variation of this proposal is to apply this rule in certain exceptional scenarios or when the replacement would confirm \"soon\"\n+<ref>Examples of Replace by Feerate proposals and suggestions:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#fees-in-next-block-and-feerate-for-the-rest-of-the-mempool]\n+* [https://petertodd.org/2024/one-shot-replace-by-fee-rate \"One-Shot Replace-by-Fee-Rate\"]\n+</ref>.\n+\n+The primary problem with these proposals is the potential for free relay and DDoS attacks.\n+\n+Removing Rule 3 and 4 in general would allow free relay\n+<ref>Examples of free relay with the removal of Rule 3 and/or 4:\n+<br/> Consider a rule where the fee can be decreased (remove Rule 3 and 4) but the feerate must double. In this scenario, a 100KvB transaction can be replaced by a 100vB transaction paying 200 sats. That's 200 sats to relay 100,200vB of transaction data, which is less than 0.002sat/vB. It becomes quite cheap to replace large portions of the mempool, decreasing both its average feerate and total absolute fees.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 245,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": 1611676401,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-05-23T14:26:31Z",
      "updated_at": "2024-05-23T14:28:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611801841",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801938",
      "pull_request_review_id": 2074143209,
      "id": 1611801938,
      "node_id": "PRRC_kwDOAN28mc5gEiVS",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions (\"Rule 3\"). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through Rule 5===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions (\"Rule 5\"). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but Rule 6 (requiring a feerate increase) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows _one more_ child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from _confirmed_ non-TRUC transactions. A non-TRUC transaction can spend outputs from _confirmed_ TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate Rule 3 pinning, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in Rule 3 Pinning section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000vB seems much larger than necessary.\n+</ref>\n+\n+5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000vB.\n+<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n+<br />Q: Why not bigger?\n+<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000vB, that might be an additional 100,000sats (at 1sat/vbyte) or more, depending on the feerate. Restricting all children to 1000vB reduces the upper bound of the additional fees by a factor of 100.\n+\n+<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100KvB) can have up to 1000vB of descendants to be within the default descendant limit (101KvB).\n+\n+<br />Q: Why not smaller?\n+<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n+</ref>\n+\n+6. An individual TRUC transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n+<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n+</ref>\n+\n+====Implementation====\n+\n+- https://github.com/bitcoin/bitcoin/pull/28948\n+- https://github.com/bitcoin/bitcoin/pull/29873\n+- https://github.com/bitcoin/bitcoin/pull/29496\n+\n+====Related Work====\n+\n+This 1-parent-1-child (aka cluster size 2) topology restriction makes the transactions much easier to reason about, which enables additional features like\n+feerate diagram comparisons\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29242 this PR] implements feerate diagram creation and comparison for sets of transactions in which the maximum cluster size is 2, e.g. all TRUC transactions.\n+</ref>,\n+package RBF\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/28984 this PR] implements package RBF, enforcing incentive compatibility by comparing the feerate diagrams of the mempool before and after replacement. The feerate diagrams are easy to build when the relevant clusters are of size 2 and below, so package RBF is restricted to those scenarios. As TRUC transactions always have this property, package RBF is enabled for TRUC transactions.\n+</ref>,\n+and sibling eviction\n+<ref>\n+[https://github.com/bitcoin/bitcoin/pull/29306 This PR] implements sibling eviction for TRUC transactions: if a new transaction would exceed a transaction's descendant limit, it considers evicting the existing descendant using replacement rules. Sibling eviction is feasible for TRUC transactions because there is no difficulty in identifying which descendant to evict (there can only be 1).\n+</ref>.\n+\n+The [https://github.com/bitcoin/bips/pull/1524 Ephemeral Anchors] proposal builds on top of this one to add more features.\n+It changes the anchor script to be anyone can spend, allowing anybody to add fees and reducing the onchain footprint and fee costs.\n+It also allows anchor outputs to have 0 value, eliminating the need to deduct value from the input amount in order to create anchors.\n+\n+The [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/7 Cluster Mempool] proposal makes fundamental changes to mempool structure and policy rules, enabling the accurate assessment of the incentive compatibility of accepting or removing a transaction, among other things. Notably, Cluster Mempool introduces a limit to all transactions' cluster size to make incentive compatibility calculations feasible. This cluster limit is similar to TRUC limits in that it bounds computation to enable improved policies, but is applied to all transactions (not just ones that opt in) and is much less restrictive than TRUC limits.\n+\n+Cluster Mempool provides a more holistic solution to some of the problems listed (such as adding an incentive compatibility requirement to RBF and safely enabling package RBF for more complex topologies). However, it does not help resolve all problems (such as RBF Pinning through Rule 3 and Rule 5). Also, since Cluster Mempool is incompatible with CPFP Carve Out<ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>, TRUC with sibling eviction and package RBF provide an alternative solution to applications that rely on it.\n+\n+Building on top of Cluster Mempool, there are also various ideas for extending TRUC transactions and creating another anti-pinning policy\n+<ref>https://delvingbitcoin.org/t/v3-and-some-possible-futures/523/3</ref>.\n+\n+[https://bitcoinops.org/en/topics/package-relay Package Relay] includes changes in p2p protocol, transaction relay logic, and mempool policy to enable nodes to accept and relay packages of transactions. Much of this proposal's utility relies on the existence of package relay for 1-parent-1-child packages (the topology TRUC supports).\n+\n+====Backward Compatibility====\n+\n+Transactions with <code>nVersion=3</code> were previously nonstandard. There are no known conflicts with previous usage.\n+\n+====Intended Usage====\n+\n+Generally, users with no interest in spending unconfirmed outputs from a transaction can make them TRUC transactions for more robust RBF abilities.\n+\n+This proposal allows for a different solution to fee-bumping in LN, in which commitment transactions are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\n+<ref>Proposals for changes to LN commitment transaction format using TRUC and a single anchor:\n+* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]\n+* [https://github.com/instagibbs/bolts/commits/zero_fee_commitment bolts proposal branch]\n+* See \"Intended usage for LN\" section in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html \"New transaction policies (nVersion=3) for contracting protocols\"]\n+</ref>.\n+A similar fee-bumping model can also be used in other contracting protocols\n+<ref>Examples of non-LN protocols that have shown interest in, designed, or built fee-bumping using TRUC:\n+* A LN-Symmetry implementation using TRUC and ephemeral anchors: [https://delvingbitcoin.org/t/ln-symmetry-project-recap/359 LN-Symmetry Project Recap] [https://github.com/instagibbs/lightning/tree/eltoo_support branch]\n+* See \"Managing Fees Safely\" mentioning ephemeral anchors in [https://jameso.be/vaults.pdf \"Vaults and Covenants\"]\n+</ref>.\n+\n+==Alternatives==\n+\n+Various alternatives for RBF\n+<ref>Proposals and discussions dedicated to improving RBF:\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff \"RBF Improvements\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html \"Improving RBF Policy\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+</ref>\n+and new fee-bumping mechanisms\n+<ref>\n+<br />Proposals and discussions dedicated to improving or creating new fee-bumping mechanisms:\n+* [https://github.com/lightning/bolts/pull/1036 \"Add option to sign commitments at various feerates\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019243.html \"A Stroll through Fee-Bumping Techniques : Input-Based vs Child-Pay-For-Parent\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html \"A Replacement for RBF and CPFP: Non-Destructive TXID Dependencies for Fee Sponsoring\"]\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019879.html \"Thoughts on fee bumping\"]\n+</ref>\n+have been proposed across multiple discussion threads.\n+Most alternatives do not conflict with TRUC, and some work in conjunction with this proposal - see Related Work.\n+A few popular ideas that were not incorporated into this work are summarized here.\n+\n+===Alternatives: add static incentive compatibility rule in RBF policy===\n+\n+Add incentive compatibility requirement to RBF policy using some existing score or static calculation\n+<ref>Examples of incentive compatibility score proposals and suggestions:\n+* [https://github.com/bitcoin/bitcoin/pull/23121 \"check ancestor feerate in RBF, remove BIP125 Rule2\"]\n+* [https://github.com/bitcoin/bitcoin/pull/26451 \"Enforce incentive compatibility for all RBF replacements\"]\n+* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019841.html\n+* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081349#gistcomment-4081349\n+</ref>.\n+\n+As the incentive compatibility \"score\" of a transaction must be dynamically calculated given the structure of mempools today, there is no satisfactory solution. A full calculation is too computationally expensive. Static values can overestimate or underestimate, leading to more pinning problems <ref>Four examples of static calculations and an example in which they are all inaccurate: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#mining-score-of-a-mempool-transaction</ref>.\n+The ability to calculate incentive compatibility scores efficiently is a primary feature and motivation for both TRUC transactions and Cluster Mempool.\n+\n+===Alternatives: replace by feerate===\n+\n+\"Instead of using Rule 3 and/or 4, allow replacements with a higher feerate.\"\n+\n+One variation of this proposal is to apply this rule in certain exceptional scenarios or when the replacement would confirm \"soon\"\n+<ref>Examples of Replace by Feerate proposals and suggestions:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n+* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#fees-in-next-block-and-feerate-for-the-rest-of-the-mempool]\n+* [https://petertodd.org/2024/one-shot-replace-by-fee-rate \"One-Shot Replace-by-Fee-Rate\"]\n+</ref>.\n+\n+The primary problem with these proposals is the potential for free relay and DDoS attacks.\n+\n+Removing Rule 3 and 4 in general would allow free relay\n+<ref>Examples of free relay with the removal of Rule 3 and/or 4:\n+<br/> Consider a rule where the fee can be decreased (remove Rule 3 and 4) but the feerate must double. In this scenario, a 100KvB transaction can be replaced by a 100vB transaction paying 200 sats. That's 200 sats to relay 100,200vB of transaction data, which is less than 0.002sat/vB. It becomes quite cheap to replace large portions of the mempool, decreasing both its average feerate and total absolute fees.\n+\n+<br/>Consider a rule where the fee can stay the same (keep Rule 3 but drop Rule 4) but the feerate must double. The attacker can start out with 100KvB transaction, paying 1sat/vB. A user can reduce its size over and over again, doubling the feerate each time until it gets too small, and end up paying 100Ksat for 100KvB(1 + 1/2 + 1/4 + ... log2(mintxsize)) -> approaches 200KvB. This means the attacker pays a rate of 0.5sat/vB to relay transactions, which is below our \"free relay\" threshold of 1sat/vB.",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 247,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "32e4e44a5afded6d5c64859b63b1392c4c62b202",
      "in_reply_to_id": 1611677147,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-05-23T14:26:34Z",
      "updated_at": "2024-05-23T14:28:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611801938",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611801938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611865667",
      "pull_request_review_id": 2074255824,
      "id": 1611865667,
      "node_id": "PRRC_kwDOAN28mc5gEx5D",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "c0fb4172f3c40718a102897d34ce4c12562f6f68",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The reference to \"Rule 3\" (and \"Rule 5\" and \"Rule 6\" below) might be confusing to readers who haven't read BIP 125 -- perhaps add a link or explanation? \r\n\r\nEDIT: Actually I guess there is a link to Bitcoin Core's replacement policy, and you have some explanation as well -- I just found the heading to be confusing!",
      "created_at": "2024-05-23T15:02:41Z",
      "updated_at": "2024-05-23T15:04:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611865667",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611865667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611918641",
      "pull_request_review_id": 2074347871,
      "id": 1611918641,
      "node_id": "PRRC_kwDOAN28mc5gE-0x",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "c0fb4172f3c40718a102897d34ce4c12562f6f68",
      "in_reply_to_id": 1611865667,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've renamed the headings to be more descriptive, and added links and clarifications where \"Rule n\" is mentioned throughout the document",
      "created_at": "2024-05-23T15:34:03Z",
      "updated_at": "2024-05-23T15:34:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1611918641",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1611918641"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1612045271",
      "pull_request_review_id": 2074568619,
      "id": 1612045271,
      "node_id": "PRRC_kwDOAN28mc5gFdvX",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through Rule 3===",
      "path": "bip-0431.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "c0fb4172f3c40718a102897d34ce4c12562f6f68",
      "in_reply_to_id": 1611865667,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Looks better to me, thanks!",
      "created_at": "2024-05-23T17:05:16Z",
      "updated_at": "2024-05-23T17:05:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1612045271",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1612045271"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1618101918",
      "pull_request_review_id": 2084152024,
      "id": 1618101918,
      "node_id": "PRRC_kwDOAN28mc5gckae",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through absolute fees===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions ([https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md#current-replace-by-fee-policy \"Rule 3\"]). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n+\n+1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n+\n+2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n+\n+===RBF pinning through number of conflicts===\n+\n+RBF rules require that no replacement trigger the removal of more than 100 transactions ([https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md#current-replace-by-fee-policy \"Rule 5\"]). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n+\n+===RBF incentive compatibility requirements===\n+\n+There is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but the requirement of a feerate increase ([https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md#current-replace-by-fee-policy \"Rule 6\"]) is far too simplistic.\n+\n+For example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n+\n+===Child fees don't count towards RBF rules===\n+\n+A transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n+\n+In LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n+\n+===Package limit pinning and replacing CPFP Carve Out===\n+\n+Mempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n+\n+LN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n+\n+There are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n+\n+* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n+* CPFP Carve Out only allows ''one more'' child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n+\n+==Topologically Restricted Until Confirmation==\n+\n+This section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\n+It is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n+\n+The scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n+\n+Similarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n+\n+===Specification===\n+\n+Senders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\n+A node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n+\n+1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n+\n+2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n+<ref>Rationale:\n+* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n+* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n+</ref>\n+Note: A TRUC transaction can spend outputs from ''confirmed'' non-TRUC transactions. A non-TRUC transaction can spend outputs from ''confirmed'' TRUC transactions.\n+\n+3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n+<ref>Rationale:\n+* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n+* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n+* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n+\n+<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n+<br />To mitigate pinning through absolute fees, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in \"RBF pinning through absolute fees\" section above.\n+\n+<br />Q: Why not allow another child?\n+<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n+\n+<br />Q: Why allow any descendants at all?\n+<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n+</ref>\n+\n+4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000 vB.",
      "path": "bip-0431.mediawiki",
      "position": 123,
      "original_position": 123,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Updated for https://github.com/bitcoin/bitcoin/pull/29873 👍 ",
      "created_at": "2024-05-29T02:36:05Z",
      "updated_at": "2024-05-29T02:50:41Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1618101918",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1618101918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 123,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1618106554",
      "pull_request_review_id": 2084152024,
      "id": 1618106554,
      "node_id": "PRRC_kwDOAN28mc5gcli6",
      "diff_hunk": "@@ -0,0 +1,291 @@\n+<pre>\n+  BIP: 431\n+  Layer: Applications\n+  Title: Topology Restrictions for Pinning\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n+  Status: Draft\n+  Type: Informational\n+  Created: 2024-01-10\n+  License: BSD-3-Clause\n+  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n+                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n+                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n+                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n+                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n+</pre>\n+\n+==Abstract==\n+\n+This document describes pinning problems that can arise from limitations in mempool policy.\n+\n+It also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n+\n+==Motivation==\n+\n+Mempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n+<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\n+to limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n+\n+Users may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\n+Instead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n+<ref>\n+[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n+</ref>\n+to keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n+\n+However, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n+\n+Pinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n+<ref>Posts about pinning in LN and LN-Symmetry:\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n+</ref>.\n+When the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n+\n+===RBF pinning through absolute fees===\n+\n+Imagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions ([https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md#current-replace-by-fee-policy \"Rule 3\"]). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.",
      "path": "bip-0431.mediawiki",
      "position": 51,
      "original_position": 51,
      "commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "original_commit_id": "04d3a0609b548805fa2ebaf5d3a495f1b81a003c",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "With https://github.com/bitcoin/bitcoin/pull/29496 on the table, note to possibly consider updating/appending to https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md#current-replace-by-fee-policy with TRUC at some point (and making sure the multiple links to it in this BIP remain valid).",
      "created_at": "2024-05-29T02:42:43Z",
      "updated_at": "2024-05-29T02:50:41Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1541#discussion_r1618106554",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1618106554"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1541"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 51,
      "original_line": 51,
      "side": "RIGHT"
    }
  ]
}