{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1378",
    "id": 1080726639,
    "node_id": "PR_kwDOAN28mc5AapRv",
    "html_url": "https://github.com/bitcoin/bips/pull/1378",
    "diff_url": "https://github.com/bitcoin/bips/pull/1378.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1378.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1378/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1378/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1378/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/32af2c9dc2d88df12b02409a023d647ee1de4c8a",
    "number": 1378,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Add BIP324: v2 P2P Transport Protocol",
    "user": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Supersedes #1024\r\n\r\nLink to rendered version for your convenience: https://github.com/dhruv/bips/blob/bip324/bip-0324.mediawiki\r\n\r\nOpen questions:\r\n- The BIP text currently includes a [table for 1-byte message type IDs](https://github.com/dhruv/bips/blob/bip324/bip-0324.mediawiki#v2_Bitcoin_P2P_message_structure). The process for updating this table atomically to assign new IDs when new message types are being proposed is likely going to be an annoyance. What are better ways to handle ongoing allocation?",
    "labels": [],
    "created_at": "2022-10-07T19:35:06Z",
    "updated_at": "2023-01-09T21:21:37Z",
    "closed_at": "2023-01-04T23:44:56Z",
    "mergeable_state": "unknown",
    "merged_at": "2023-01-04T23:44:56Z",
    "merge_commit_sha": "2361582f0b921977f8eb2062e72181a1f6dc1546",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "dhruv:bip324",
      "ref": "bip324",
      "sha": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "user": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 429610370,
        "node_id": "R_kgDOGZtVgg",
        "name": "bips",
        "full_name": "dhruv/bips",
        "owner": {
          "login": "dhruv",
          "id": 856960,
          "node_id": "MDQ6VXNlcjg1Njk2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/dhruv",
          "html_url": "https://github.com/dhruv",
          "followers_url": "https://api.github.com/users/dhruv/followers",
          "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
          "organizations_url": "https://api.github.com/users/dhruv/orgs",
          "repos_url": "https://api.github.com/users/dhruv/repos",
          "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/dhruv/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/dhruv/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/dhruv/bips",
        "archive_url": "https://api.github.com/repos/dhruv/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/dhruv/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/dhruv/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/dhruv/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/dhruv/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/dhruv/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/dhruv/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/dhruv/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/dhruv/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/dhruv/bips/contributors",
        "deployments_url": "https://api.github.com/repos/dhruv/bips/deployments",
        "downloads_url": "https://api.github.com/repos/dhruv/bips/downloads",
        "events_url": "https://api.github.com/repos/dhruv/bips/events",
        "forks_url": "https://api.github.com/repos/dhruv/bips/forks",
        "git_commits_url": "https://api.github.com/repos/dhruv/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/dhruv/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/dhruv/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/dhruv/bips.git",
        "issue_comment_url": "https://api.github.com/repos/dhruv/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/dhruv/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/dhruv/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/dhruv/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/dhruv/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/dhruv/bips/languages",
        "merges_url": "https://api.github.com/repos/dhruv/bips/merges",
        "milestones_url": "https://api.github.com/repos/dhruv/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/dhruv/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/dhruv/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/dhruv/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:dhruv/bips.git",
        "stargazers_url": "https://api.github.com/repos/dhruv/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/dhruv/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/dhruv/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/dhruv/bips/subscription",
        "tags_url": "https://api.github.com/repos/dhruv/bips/tags",
        "teams_url": "https://api.github.com/repos/dhruv/bips/teams",
        "trees_url": "https://api.github.com/repos/dhruv/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/dhruv/bips.git",
        "hooks_url": "https://api.github.com/repos/dhruv/bips/hooks",
        "svn_url": "https://github.com/dhruv/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 13762,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-02-28T17:53:37Z",
        "created_at": "2021-11-18T23:32:10Z",
        "updated_at": "2022-12-05T02:07:19Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "79bb53dde55e94ebf51ada4adee38fb40f127ae6",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5178,
        "stargazers_count": 8116,
        "watchers_count": 8116,
        "size": 13694,
        "default_branch": "master",
        "open_issues_count": 115,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-08T12:03:37Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2023-06-12T10:53:19Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1296,
    "deletions": 1,
    "changed_files": 9,
    "commits": 1,
    "review_comments": 15,
    "comments": 22
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 7546175822,
      "node_id": "HRFPE_lADOAN28mc5Tip9VzwAAAAHByYFO",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7546175822",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-07T19:55:38Z"
    },
    {
      "event": "subscribed",
      "id": 7546967442,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHB1ZWS",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7546967442",
      "actor": {
        "login": "0xB10C",
        "id": 19157360,
        "node_id": "MDQ6VXNlcjE5MTU3MzYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/0xB10C",
        "html_url": "https://github.com/0xB10C",
        "followers_url": "https://api.github.com/users/0xB10C/followers",
        "following_url": "https://api.github.com/users/0xB10C/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/0xB10C/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/0xB10C/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
        "organizations_url": "https://api.github.com/users/0xB10C/orgs",
        "repos_url": "https://api.github.com/users/0xB10C/repos",
        "events_url": "https://api.github.com/users/0xB10C/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/0xB10C/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-07T22:55:12Z"
    },
    {
      "event": "reviewed",
      "id": 1135153458,
      "node_id": "PRR_kwDOAN28mc5DqREy",
      "url": null,
      "actor": null,
      "commit_id": "72e3a6cf0ae8782469b52338bd9c65ad679bf575",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#pullrequestreview-1135153458",
      "submitted_at": "2022-10-08T00:31:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7547178009,
      "node_id": "HRFPE_lADOAN28mc5Tip9VzwAAAAHB2MwZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7547178009",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T00:39:43Z"
    },
    {
      "event": "reviewed",
      "id": 1135156164,
      "node_id": "PRR_kwDOAN28mc5DqRvE",
      "url": null,
      "actor": null,
      "commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#pullrequestreview-1135156164",
      "submitted_at": "2022-10-08T01:34:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
    },
    {
      "event": "subscribed",
      "id": 7557139100,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHCcMqc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7557139100",
      "actor": {
        "login": "namcios",
        "id": 82450345,
        "node_id": "MDQ6VXNlcjgyNDUwMzQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/82450345?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/namcios",
        "html_url": "https://github.com/namcios",
        "followers_url": "https://api.github.com/users/namcios/followers",
        "following_url": "https://api.github.com/users/namcios/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/namcios/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/namcios/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/namcios/subscriptions",
        "organizations_url": "https://api.github.com/users/namcios/orgs",
        "repos_url": "https://api.github.com/users/namcios/repos",
        "events_url": "https://api.github.com/users/namcios/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/namcios/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-10T21:00:04Z"
    },
    {
      "event": "commented",
      "id": 1292747813,
      "node_id": "IC_kwDOAN28mc5NDcQl",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1292747813",
      "actor": {
        "login": "ProofOfKeags",
        "id": 4033651,
        "node_id": "MDQ6VXNlcjQwMzM2NTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4033651?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ProofOfKeags",
        "html_url": "https://github.com/ProofOfKeags",
        "followers_url": "https://api.github.com/users/ProofOfKeags/followers",
        "following_url": "https://api.github.com/users/ProofOfKeags/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ProofOfKeags/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ProofOfKeags/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ProofOfKeags/subscriptions",
        "organizations_url": "https://api.github.com/users/ProofOfKeags/orgs",
        "repos_url": "https://api.github.com/users/ProofOfKeags/repos",
        "events_url": "https://api.github.com/users/ProofOfKeags/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ProofOfKeags/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-26T22:49:53Z",
      "updated_at": "2022-10-26T22:49:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "Since TLS isn't being used is there any way to recover \"virtual host\" functionality? This is necessary for addressing multiple nodes behind the same NAT which is increasingly common these days.",
      "user": {
        "login": "ProofOfKeags",
        "id": 4033651,
        "node_id": "MDQ6VXNlcjQwMzM2NTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4033651?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ProofOfKeags",
        "html_url": "https://github.com/ProofOfKeags",
        "followers_url": "https://api.github.com/users/ProofOfKeags/followers",
        "following_url": "https://api.github.com/users/ProofOfKeags/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ProofOfKeags/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ProofOfKeags/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ProofOfKeags/subscriptions",
        "organizations_url": "https://api.github.com/users/ProofOfKeags/orgs",
        "repos_url": "https://api.github.com/users/ProofOfKeags/repos",
        "events_url": "https://api.github.com/users/ProofOfKeags/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ProofOfKeags/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1292747813",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1304818628,
      "node_id": "IC_kwDOAN28mc5NxfPE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1304818628",
      "actor": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T14:51:08Z",
      "updated_at": "2022-11-06T14:51:08Z",
      "author_association": "NONE",
      "body": "The [Transport layer specification](https://github.com/dhruv/bips/blob/bip324/bip-0324.mediawiki#Transport_layer_specification) says:\r\n\r\n> Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, ...\r\n\r\nWhat does \"typically TCP/IP\" mean? Will UDP based connections be supported by BIP-324 as well?\r\n\r\nI'm asking, because I stumbled over this `obfs4`-like protocol today which supports both, TCP and UDP:\r\nhttps://lib.rs/crates/sosistab\r\n`sosistab` seems to have similar goals as BIP-324 and seems to be in active development for over a year now. Maybe there are some learnings/takeaways for BIP-324 here? Especially the following aspect of `sosistap` might of interest for Bitcoin:\r\n > Avoids last-mile congestive collapse but works around lossy links. Shamelessly unfair in permanently congested WANs --- but that's really their problem, not yours.\r\n\r\nAny thoughts? ",
      "user": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1304818628",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1304831143,
      "node_id": "IC_kwDOAN28mc5NxiSn",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1304831143",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T15:52:10Z",
      "updated_at": "2022-11-06T15:52:10Z",
      "author_association": "MEMBER",
      "body": "@yojoe The encrypted protocol we are proposing requires state and the order of packets is important. So we require a stream interface and can't use UDP.",
      "user": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1304831143",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "mentioned",
      "id": 7747513409,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHNyaxB",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7747513409",
      "actor": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T15:52:11Z"
    },
    {
      "event": "subscribed",
      "id": 7747513412,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHNyaxE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7747513412",
      "actor": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T15:52:11Z"
    },
    {
      "event": "commented",
      "id": 1304839497,
      "node_id": "IC_kwDOAN28mc5NxkVJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1304839497",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T16:32:46Z",
      "updated_at": "2022-11-06T16:33:25Z",
      "author_association": "MEMBER",
      "body": "@dhruv @yojoe We should probably clarify that BIP324 assumes a reliable stream interface to run on top of, as the statefulnes of the Bitcoin P2P needs the same, so that's what we're targetting. The text says \"typically\" TCP/IP, because it can also run over whatever else provides that (in particular, Tor or I2P also do, and are used as layers to run the P2P protocol over).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1304839497",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "mentioned",
      "id": 7747566917,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHNyn1F",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7747566917",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T16:32:46Z"
    },
    {
      "event": "subscribed",
      "id": 7747566918,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHNyn1G",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7747566918",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T16:32:47Z"
    },
    {
      "event": "mentioned",
      "id": 7747566919,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHNyn1H",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7747566919",
      "actor": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T16:32:47Z"
    },
    {
      "event": "subscribed",
      "id": 7747566920,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHNyn1I",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7747566920",
      "actor": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T16:32:47Z"
    },
    {
      "event": "commented",
      "id": 1304841789,
      "node_id": "IC_kwDOAN28mc5Nxk49",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1304841789",
      "actor": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-06T16:44:40Z",
      "updated_at": "2022-11-06T17:16:21Z",
      "author_association": "NONE",
      "body": "> BIP324 assumes a reliable stream interface to run on top of\r\n\r\nSo BIP324 \"could\" run on [QUIC](https://en.wikipedia.org/wiki/QUIC) and similar protocols, which use UDP instead of TCP to provide reliable streams over multiplexed connections?\r\n\r\nWith quite a lot of P2P applications moving to QUIC (UDP) right now (at least in my perception) and keeping TCP only as a fallback, I think two or three sentences on \"Why not QUIC?\" would help the BIP324 spec.",
      "user": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1304841789",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1305019770,
      "node_id": "IC_kwDOAN28mc5NyQV6",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1305019770",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-07T03:05:28Z",
      "updated_at": "2022-11-07T03:12:02Z",
      "author_association": "MEMBER",
      "body": "@ProofOfKeags \r\n\r\n> Since TLS isn't being used is there any way to recover \"virtual host\" functionality? This is necessary for addressing multiple nodes behind the same NAT which is increasingly common these days.\r\n\r\nYou can forward different port numbers to different machines on the NAT, if that's what you want. The P2P protocol already relays full IP/port combinations, and since version 23.0 Bitcoin Core also can keep track of different ports on the same IP as separate entities.\r\n\r\nIf you're referring to some kind of (v)host functionality, as it exists in HTTP(S), where the client sends the server an actual hostname it's trying to connect to, so that multiple hostnames can be served from a single IP: no; I think that would be a significant complication for little/no gain. The P2P protocol has no notion of hostnames right now, and adding something like that would require changes not just to the transport protocol but also to IP address relay to convey these. It'd also require running a trusted service on the NAT to properly dispatch to what's behind it, so you'd have to wonder if that same entity couldn't just run a single node for all users behind it (who could run their own nodes just connected to that one).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1305019770",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "mentioned",
      "id": 7748688414,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHN25oe",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7748688414",
      "actor": {
        "login": "ProofOfKeags",
        "id": 4033651,
        "node_id": "MDQ6VXNlcjQwMzM2NTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4033651?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ProofOfKeags",
        "html_url": "https://github.com/ProofOfKeags",
        "followers_url": "https://api.github.com/users/ProofOfKeags/followers",
        "following_url": "https://api.github.com/users/ProofOfKeags/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ProofOfKeags/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ProofOfKeags/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ProofOfKeags/subscriptions",
        "organizations_url": "https://api.github.com/users/ProofOfKeags/orgs",
        "repos_url": "https://api.github.com/users/ProofOfKeags/repos",
        "events_url": "https://api.github.com/users/ProofOfKeags/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ProofOfKeags/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-07T03:05:28Z"
    },
    {
      "event": "subscribed",
      "id": 7748688418,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHN25oi",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7748688418",
      "actor": {
        "login": "ProofOfKeags",
        "id": 4033651,
        "node_id": "MDQ6VXNlcjQwMzM2NTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4033651?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ProofOfKeags",
        "html_url": "https://github.com/ProofOfKeags",
        "followers_url": "https://api.github.com/users/ProofOfKeags/followers",
        "following_url": "https://api.github.com/users/ProofOfKeags/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ProofOfKeags/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ProofOfKeags/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ProofOfKeags/subscriptions",
        "organizations_url": "https://api.github.com/users/ProofOfKeags/orgs",
        "repos_url": "https://api.github.com/users/ProofOfKeags/repos",
        "events_url": "https://api.github.com/users/ProofOfKeags/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ProofOfKeags/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-07T03:05:28Z"
    },
    {
      "event": "commented",
      "id": 1305026258,
      "node_id": "IC_kwDOAN28mc5NyR7S",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1305026258",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-07T03:12:20Z",
      "updated_at": "2022-11-07T03:16:44Z",
      "author_association": "MEMBER",
      "body": "@yojoe \r\n\r\n> So BIP324 \"could\" run on [QUIC](https://en.wikipedia.org/wiki/QUIC) and similar protocols, which use UDP instead of TCP to provide reliable streams over multiplexed connections?\r\n\r\nIn theory, yes. I don't think there is that much to gain from QUIC, as we don't care about latency of connection set-up (we have very long-lived connections in general), integrated TLS encryption, or multiple parallel datastreams. I could imagine making use of the latter, but that'd need a much deeper redesign of the whole P2P protocol to make use of. In BIP324 we're just looking at improving the transport layer of the protocol.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1305026258",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "mentioned",
      "id": 7748720708,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHN3BhE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7748720708",
      "actor": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-07T03:12:20Z"
    },
    {
      "event": "subscribed",
      "id": 7748720715,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHN3BhL",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7748720715",
      "actor": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-07T03:12:20Z"
    },
    {
      "event": "reviewed",
      "id": 1194901055,
      "node_id": "PRR_kwDOAN28mc5HOL4_",
      "url": null,
      "actor": null,
      "commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#pullrequestreview-1194901055",
      "submitted_at": "2022-11-26T19:05:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
    },
    {
      "event": "comment_deleted",
      "id": 7897369347,
      "node_id": "CDE_lADOAN28mc5Tip9VzwAAAAHWuEsD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7897369347",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-27T10:45:06Z"
    },
    {
      "event": "reviewed",
      "id": 1212693054,
      "node_id": "PRR_kwDOAN28mc5ISDo-",
      "url": null,
      "actor": null,
      "commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "manda2020panda",
        "id": 47097619,
        "node_id": "MDQ6VXNlcjQ3MDk3NjE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/47097619?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/manda2020panda",
        "html_url": "https://github.com/manda2020panda",
        "followers_url": "https://api.github.com/users/manda2020panda/followers",
        "following_url": "https://api.github.com/users/manda2020panda/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/manda2020panda/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/manda2020panda/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/manda2020panda/subscriptions",
        "organizations_url": "https://api.github.com/users/manda2020panda/orgs",
        "repos_url": "https://api.github.com/users/manda2020panda/repos",
        "events_url": "https://api.github.com/users/manda2020panda/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/manda2020panda/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#pullrequestreview-1212693054",
      "submitted_at": "2022-12-11T12:57:46Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
    },
    {
      "event": "reviewed",
      "id": 1232042460,
      "node_id": "PRR_kwDOAN28mc5Jb3nc",
      "url": null,
      "actor": null,
      "commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Bitcoin P2P connections are asymmetric: one peer connects to the other peer, and that other peer must be known by some id. For now, the connection happens by the network address (which serves that id). The proposed wire protocol doesn't provide any means of authenticating other peer, which opens possibilities for MiTs, and argues that this increases privacy. I see two contradictions:\r\n- the connecting peer knows the peer it connects to; no anonymity here is gained;\r\n- not authenticating the remote peer keeps the possibility for MiT attacks from the current wire protocol.\r\n\r\nI think that \"exchange-known\" key scheme (like in Noise_XK) is more adequate for bitcoin P2P than \"exchange-exchange\", as in the current proposal (and like in Noise_XX).",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#pullrequestreview-1232042460",
      "submitted_at": "2022-12-28T22:03:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
    },
    {
      "event": "commented",
      "id": 1366957149,
      "node_id": "IC_kwDOAN28mc5Rehxd",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1366957149",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-28T22:19:02Z",
      "updated_at": "2022-12-28T22:26:37Z",
      "author_association": "MEMBER",
      "body": "@dr-orlovsky The proposal isn't to not authenticate at all; it's to leave authentication for a future improvement, in cases where it is desired.\r\n\r\nAs the text argues, in a Bitcoin P2P setting, authentication is only relevant in cases where the initiator makes a deliberate connection to a peer with whom they have some out-of-band trust relation, and doesn't matter for automatic connections. That optionality makes it undesirable to integrate in the key exchange (as that would make it mandatory), but nothing prevents it from being done separately, in a post-key-exchange, optional step when desired (that's easy to do, but comes at the cost of an extra roundtrip, which many transport protocols prioritize; our P2P protocol connections are so long-lived this doesn't matter).\r\n\r\nAnd this isn't just a matter of avoiding a bit of complexity: using something like Noise_XK would *require* all listening nodes to have a known public key. I think that's something we actively don't want, as it would introduce a notion of identities to the protocol that must be known for it to operate at all.\r\n\r\nFWIW, we're also working on a protocol for an optional authentication scheme without discoverable identities, and with the property that a MitM can't learn anything about the desired/provided public/private keys. That will take time, as we'd want academic scrutiny before actually proposing it. There are already tangible benefits to deploying opportunistic encryption without authentication at all, so we don't feel like waiting for that is desirable either. It's also only one of a possible number of approaches that could be taken w.r.t. authentication.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1366957149",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "mentioned",
      "id": 8123409696,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHkMWUg",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8123409696",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-28T22:19:02Z"
    },
    {
      "event": "subscribed",
      "id": 8123409700,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHkMWUk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8123409700",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-28T22:19:02Z"
    },
    {
      "event": "commented",
      "id": 1367001255,
      "node_id": "IC_kwDOAN28mc5Resin",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1367001255",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-29T00:39:15Z",
      "updated_at": "2022-12-29T00:39:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "> authentication is only relevant in cases where the initiator makes a deliberate connection to a peer with whom they have some out-of-band trust relation, and doesn't matter for automatic connections\r\n\r\nThat is exactly the point I am trying to make: I think that even for automatic connections it might be desirable to know the identity of the peer. The requirement to always have a remote pubkey is not that hard to meet: the remote peers are listed either by the config or via P2P messages, and both of them can require to provide the remote identities alongside network address, as it is done in LN.\r\n\r\nAt the same time I agree that the abstraction of authentication from encryption is a good thing to have. What is not good is to build a new P2P stack for bitcoin without paying attention to authentication.",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1367001255",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1367002989,
      "node_id": "IC_kwDOAN28mc5Res9t",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1367002989",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-29T00:45:13Z",
      "updated_at": "2022-12-29T00:45:13Z",
      "author_association": "MEMBER",
      "body": "> The requirement to always have a remote pubkey is not that hard to meet: the remote peers are listed either by the config or via P2P messages, and both of them can require to provide the remote identities alongside network address, as it is done in LN.\n\nIt's not hard; it's just a bad idea. Bitcoin nodes don't, and shouldn't, have identities.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1367002989",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1367005606,
      "node_id": "IC_kwDOAN28mc5Retmm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1367005606",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-29T00:56:53Z",
      "updated_at": "2022-12-29T00:58:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "Isn't IP address an identity? Or Onion address? Or any other networking address? Having public key next to it is just a second factor: it doesn't add to the leak of a privacy or doesn't make the node \"more identifiable\" at all; it is just a second factor ensuring that the _existing identity_ is not stolen by a MitM",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1367005606",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1367010019,
      "node_id": "IC_kwDOAN28mc5Reurj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1367010019",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-29T01:10:17Z",
      "updated_at": "2022-12-29T01:10:17Z",
      "author_association": "MEMBER",
      "body": "An IP can be used as an identity, and in some cases it is, and that's a bad idea. It's that scenario where adding authentication makes sense, e.g. people configuring manual IP addresses of their own nodes or people they know.\n\nBut in the case of automatic connections, the IP addresses are just endpoints. They're not identities in the sense that they're not trusted (nodes verify all incoming data), there is no reputation, and there is no cost to creating a new one. Effectively, every node is equally (dis)trusted, and adding cryptographic identities for that is just pointless. Furthermore, it's risky; e.g. you need to make sure that nodes use separate identities for each IP they are reachable on (which the node might not even be aware of) or you're instantly adding a fingerprinting vector.\n\nAnd when restricted to just the manual connection use case, non-discoverable identities suffice: all you need is a way to verify you're connected to the party you intended to talk to; it doesn't require telling others who you are, greatly reducing those risks.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1367010019",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1367012542,
      "node_id": "IC_kwDOAN28mc5RevS-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1367012542",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-29T01:18:40Z",
      "updated_at": "2022-12-29T01:18:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "I think there is terminological (actually semantic) difference.\n\nThere is an identity for a reputation (state that persists before connections) -- and there is an \"identity\" as a \"second factor\" to ensure that there is no forgery of some network addresses controlled by authorities (DNS, NATs etc).\n\nFor sure I am not arguing about the first case (reputation, permanent identity).\n\nThe point I am trying to address is that bitcoin P2P protocol probably shouldn't allow connecting to remote peers by DNS or IP addresses without ensuring that the peer behind that address is the peer which was advertised via P2P. And static public key servers that purpose (and probably it is incorrect to call it \"permanent identity\", but its validation against an expected value is still an authentication).",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1367012542",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1367014841,
      "node_id": "IC_kwDOAN28mc5Rev25",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1367014841",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-29T01:28:36Z",
      "updated_at": "2022-12-29T01:28:36Z",
      "author_association": "MEMBER",
      "body": "> The point I am trying to address is that bitcoin P2P protocol probably shouldn't allow connecting to remote peers by DNS or IP addresses without ensuring that the peer behind that address is the peer which was advertised via P2P. And static public key servers that purpose (and probably it is incorrect to call it \"permanent identity\", but its validation against an expected value is still an authentication).\n\nI disagree. There is no point in ensuring anything, because there is nothing to ensure: for automatic connections, every node is equally good.\n\nIn any case, I believe I understand your argument, but we fundamentally disagree about what qualities the P2P network should have.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1367014841",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "comment_deleted",
      "id": 8125325057,
      "node_id": "CDE_lADOAN28mc5Tip9VzwAAAAHkTp8B",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8125325057",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-29T09:50:09Z"
    },
    {
      "event": "commented",
      "id": 1367198354,
      "node_id": "IC_kwDOAN28mc5RfcqS",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1367198354",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-29T09:52:14Z",
      "updated_at": "2022-12-29T09:53:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "I'd like to understand better why you think that P2P network should have a quality that for automatic connections, every node is equally good (i.e. the rational behind that). I am not trying to persuade you, I am asking for better rationale - I think others may have similar questions and it will be nice to clarify the approach better (including the text of the document).\r\n\r\nFrom my understanding, Bitcoin P2P network has a quality of eclipse attack. Connecting to peers which are guaranteed to be the peers known to be well-connected - or outside of the scope of a vulnerable network segment (for instance being in US for a Chinese node) is a way to mitigate that risk. If these nodes are not authenticated to be the nodes a peer tried to connect to (i.e. proving their network address was not stolen and they are just fakes run by a Chinese government) would make eclipse attacks more probable/simple. Or you mean that such nodes would be authenticated as a layer above this spec, while all other nodes (\"automatically connected\") can be fakes without increasing chances of eclipse?",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1367198354",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1367410885,
      "node_id": "IC_kwDOAN28mc5RgQjF",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1367410885",
      "actor": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-29T15:28:46Z",
      "updated_at": "2022-12-29T15:40:41Z",
      "author_association": "NONE",
      "body": "> I'd like to understand better why you think that P2P network should have a quality that for automatic connections, every node is equally good (i.e. the rational behind that).\r\n\r\nBitcoin is special among P2P networks in regards to eclipse attacks as they can be easily/cheaply detected here. All you need to do is periodically check the chain tip hash via other low-bandwidth, out-of-band channel(s). Either manually or you script it. It would be really hard for an adversary to eclipse all your information channels and stop you from learning that another (and potentially heavier) chain tip exists. Alternatively, you can already manually and explicitly add a few trusted \"nodes\" to the mix, e.g. Tor, I2P or CJDNS, whose address schemes are all \"public key\" based and don't rely on centralised authorities like DNS. So if you worry about eclipse attacks, you can already detect and somewhat counter them.\r\n\r\nBut the main point is that \"public key based identities\" and \"authenticated connections\" are not the silver bullet against eclipse attacks in **TRUSTLESS, PUBLIC, OPEN NETWORKS**.\r\n\r\n> Connecting to peers which are guaranteed to be the peers known to be well-connected\r\n\r\nThat would be a \"web of trust\" and not a \"trustless\" topology.\r\n\r\n> or outside of the scope of a vulnerable network segment (for instance being in US for a Chinese node) is a way to mitigate that risk\r\n\r\nAFAIK that's exactly what the clearnet (IP4/6) peer selection algorithm already considers.",
      "user": {
        "login": "yojoe",
        "id": 58518123,
        "node_id": "MDQ6VXNlcjU4NTE4MTIz",
        "avatar_url": "https://avatars.githubusercontent.com/u/58518123?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yojoe",
        "html_url": "https://github.com/yojoe",
        "followers_url": "https://api.github.com/users/yojoe/followers",
        "following_url": "https://api.github.com/users/yojoe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yojoe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yojoe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yojoe/subscriptions",
        "organizations_url": "https://api.github.com/users/yojoe/orgs",
        "repos_url": "https://api.github.com/users/yojoe/repos",
        "events_url": "https://api.github.com/users/yojoe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yojoe/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1367410885",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "reviewed",
      "id": 1232612712,
      "node_id": "PRR_kwDOAN28mc5JeC1o",
      "url": null,
      "actor": null,
      "commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I've got all answers to my questions, thank you. ACK",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#pullrequestreview-1232612712",
      "submitted_at": "2022-12-29T16:09:50Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
    },
    {
      "event": "commented",
      "id": 1370406415,
      "node_id": "IC_kwDOAN28mc5Rrr4P",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1370406415",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T02:03:37Z",
      "updated_at": "2023-01-04T02:03:37Z",
      "author_association": "MEMBER",
      "body": "I don't see any un-addressed concerns regarding this pull request and will merge this soon unless someone pipes up. Thanks.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1370406415",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "commented",
      "id": 1370413747,
      "node_id": "IC_kwDOAN28mc5Rrtqz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1370413747",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T02:16:42Z",
      "updated_at": "2023-01-04T02:16:42Z",
      "author_association": "MEMBER",
      "body": "@kallewoof we have a couple small changes coming up",
      "user": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1370413747",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "mentioned",
      "id": 8147375122,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHlnxQS",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147375122",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T02:16:44Z"
    },
    {
      "event": "subscribed",
      "id": 8147375128,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHlnxQY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147375128",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T02:16:44Z"
    },
    {
      "event": "commented",
      "id": 1370434310,
      "node_id": "IC_kwDOAN28mc5RrysG",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1370434310",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T02:59:25Z",
      "updated_at": "2023-01-04T02:59:25Z",
      "author_association": "MEMBER",
      "body": "It's helpful if you change to draft when you don't want it merged so maintainers know to skip over it.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1370434310",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8147608191,
      "node_id": "HRFPE_lADOAN28mc5Tip9VzwAAAAHloqJ_",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147608191",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T03:33:56Z"
    },
    {
      "event": "commented",
      "id": 1370453069,
      "node_id": "IC_kwDOAN28mc5Rr3RN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1370453069",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T03:37:41Z",
      "updated_at": "2023-01-04T03:39:17Z",
      "author_association": "MEMBER",
      "body": "@kallewoof I'm sorry about that -- I was unclear about the workflow on the bips repo but I understand now. I have pushed up the latest changes and the working group (@sipa, @real-or-random and I) agrees it's rfm. \r\n\r\nLatest push:\r\n- New rekeying mechanism that uses ChaCha20 keystream bytes and does not rely on SHA256 - reducing one dependency for the BIP324 requirements as well as a small efficiency gain. The PRs in Bitcoin Core are already using this new mechanism.\r\n- Changed rekey interval to 224 messages instead of 256 messages.\r\n- Erlay message types in the message type id table\r\n- Reference code changes for terminator derivation\r\n- Changes to footnotes/rationale\r\n- Grammar/spelling",
      "user": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1370453069",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "mentioned",
      "id": 8147619393,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHlos5B",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147619393",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T03:37:41Z"
    },
    {
      "event": "subscribed",
      "id": 8147619395,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHlos5D",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147619395",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T03:37:41Z"
    },
    {
      "event": "mentioned",
      "id": 8147619400,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHlos5I",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147619400",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T03:37:41Z"
    },
    {
      "event": "subscribed",
      "id": 8147619406,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHlos5O",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147619406",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T03:37:42Z"
    },
    {
      "event": "mentioned",
      "id": 8147619412,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHlos5U",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147619412",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T03:37:42Z"
    },
    {
      "event": "subscribed",
      "id": 8147619415,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHlos5X",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147619415",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T03:37:42Z"
    },
    {
      "event": "commented",
      "id": 1370487814,
      "node_id": "IC_kwDOAN28mc5Rr_wG",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1370487814",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T04:56:59Z",
      "updated_at": "2023-01-04T04:56:59Z",
      "author_association": "MEMBER",
      "body": "No worries!\r\n\r\nMaybe mark BIP-151 as \"Replaced\" in `README.mediawiki`, similar to BIP-1 replaced by BIP-2?",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1370487814",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDMyYWYyYzlkYzJkODhkZjEyYjAyNDA5YTAyM2Q2NDdlZTFkZTRjOGE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "tree": {
        "sha": "ebe2d8cb207a207217cbf330fc8be388436fb8a7",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/ebe2d8cb207a207217cbf330fc8be388436fb8a7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/6545b81022212a9f1c814f6ce1673e84bc02c910",
          "sha": "6545b81022212a9f1c814f6ce1673e84bc02c910",
          "html_url": "https://github.com/bitcoin/bips/commit/6545b81022212a9f1c814f6ce1673e84bc02c910"
        }
      ],
      "message": "Add BIP324",
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2023-01-04T16:46:46Z"
      },
      "author": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2022-10-07T18:59:24Z"
      },
      "sha": "32af2c9dc2d88df12b02409a023d647ee1de4c8a"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8152881874,
      "node_id": "HRFPE_lADOAN28mc5Tip9VzwAAAAHl8xrS",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8152881874",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T16:47:05Z"
    },
    {
      "event": "commented",
      "id": 1371170219,
      "node_id": "IC_kwDOAN28mc5RumWr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1371170219",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T16:47:26Z",
      "updated_at": "2023-01-04T16:47:26Z",
      "author_association": "MEMBER",
      "body": "> Maybe mark BIP-151 as \"Replaced\" in `README.mediawiki`, similar to BIP-1 replaced by BIP-2?\r\n\r\n@kallewoof Done.\r\n",
      "user": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1378#issuecomment-1371170219",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1378"
    },
    {
      "event": "mentioned",
      "id": 8152884697,
      "node_id": "MEE_lADOAN28mc5Tip9VzwAAAAHl8yXZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8152884697",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T16:47:27Z"
    },
    {
      "event": "subscribed",
      "id": 8152884706,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHl8yXi",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8152884706",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T16:47:27Z"
    },
    {
      "event": "merged",
      "id": 8155389517,
      "node_id": "ME_lADOAN28mc5Tip9VzwAAAAHmGV5N",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8155389517",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2361582f0b921977f8eb2062e72181a1f6dc1546",
      "commit_url": "https://api.github.com/repos/bitcoin/bips/commits/2361582f0b921977f8eb2062e72181a1f6dc1546",
      "created_at": "2023-01-04T23:44:56Z"
    },
    {
      "event": "closed",
      "id": 8155389533,
      "node_id": "CE_lADOAN28mc5Tip9VzwAAAAHmGV5d",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8155389533",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T23:44:56Z"
    },
    {
      "event": "subscribed",
      "id": 8175222070,
      "node_id": "SE_lADOAN28mc5Tip9VzwAAAAHnR_02",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8175222070",
      "actor": {
        "login": "Leylimahmud",
        "id": 99537361,
        "node_id": "U_kgDOBe7R0Q",
        "avatar_url": "https://avatars.githubusercontent.com/u/99537361?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Leylimahmud",
        "html_url": "https://github.com/Leylimahmud",
        "followers_url": "https://api.github.com/users/Leylimahmud/followers",
        "following_url": "https://api.github.com/users/Leylimahmud/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Leylimahmud/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Leylimahmud/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Leylimahmud/subscriptions",
        "organizations_url": "https://api.github.com/users/Leylimahmud/orgs",
        "repos_url": "https://api.github.com/users/Leylimahmud/repos",
        "events_url": "https://api.github.com/users/Leylimahmud/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Leylimahmud/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-07T18:45:42Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990561850",
      "pull_request_review_id": 1135153458,
      "id": 990561850,
      "node_id": "PRRC_kwDOAN28mc47CsY6",
      "diff_hunk": "@@ -981,6 +981,13 @@ Those proposing changes should consider that ultimately consent may rest with th\n | Standard\n | Draft\n |- style=\"background-color: #ffffcf\"\n+| [[bip-0324.mediawiki|324]]\n+| Peer Services\n+| Version 2 P2P Encrypted Transport Protocol\n+| Dhruv Mehta, Tim Ruffing, Jonas Schnelli, Pieter Wuille\n+| Standard\n+| Draft\n+|-",
      "path": "README.mediawiki",
      "position": null,
      "original_position": 10,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "72e3a6cf0ae8782469b52338bd9c65ad679bf575",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `style=\"background-color: #ffffcf\"` line needs to be after bip-324, not before it.",
      "created_at": "2022-10-08T00:31:38Z",
      "updated_at": "2022-10-08T00:31:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990561850",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990561850"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 990,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990563251",
      "pull_request_review_id": 1135154892,
      "id": 990563251,
      "node_id": "PRRC_kwDOAN28mc47Csuz",
      "diff_hunk": "@@ -981,6 +981,13 @@ Those proposing changes should consider that ultimately consent may rest with th\n | Standard\n | Draft\n |- style=\"background-color: #ffffcf\"\n+| [[bip-0324.mediawiki|324]]\n+| Peer Services\n+| Version 2 P2P Encrypted Transport Protocol\n+| Dhruv Mehta, Tim Ruffing, Jonas Schnelli, Pieter Wuille\n+| Standard\n+| Draft\n+|-",
      "path": "README.mediawiki",
      "position": null,
      "original_position": 10,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "72e3a6cf0ae8782469b52338bd9c65ad679bf575",
      "in_reply_to_id": 990561850,
      "user": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That fixed it. Thanks, @ajtowns!",
      "created_at": "2022-10-08T00:40:57Z",
      "updated_at": "2022-10-08T00:40:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990563251",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990563251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 990,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990567999",
      "pull_request_review_id": 1135156164,
      "id": 990567999,
      "node_id": "PRRC_kwDOAN28mc47Ct4_",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>\n+\n+The following table lists currently defined message type IDs:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+|-\n+!+0\n+|(undefined)||(1 byte string)||(2 byte string)||(3 byte string)\n+|-\n+!+4\n+|(4 byte string)||(5 byte string)||(6 byte string)||(7 byte string)\n+|-\n+!+8\n+|(8 byte string)||(9 byte string)||(10 byte string)||(11 byte string)\n+|-\n+!+12\n+|(12 byte string)||<code>ADDR</code>||<code>BLOCK</code>||<code>BLOCKTXN</code>\n+|-\n+!+16\n+|<code>CMPCTBLOCK</code>||<code>FEEFILTER</code>||<code>FILTERADD</code>||<code>FILTERCLEAR</code>\n+|-\n+!+20\n+|<code>FILTERLOAD</code>||<code>GETADDR</code>||<code>GETBLOCKS</code>||<code>GETBLOCKTXN</code>\n+|-\n+!+24\n+|<code>GETDATA</code>||<code>GETHEADERS</code>||<code>HEADERS</code>||<code>INV</code>\n+|-\n+!+28\n+|<code>MEMPOOL</code>||<code>MERKLEBLOCK</code>||<code>NOTFOUND</code>||<code>PING</code>\n+|-\n+!+32\n+|<code>PONG</code>||<code>SENDCMPCT</code>||<code>SENDHEADERS</code>||<code>TX</code>\n+|-\n+!+36\n+|<code>VERACK</code>||<code>VERSION</code>||<code>GETCFILTERS</code>||<code>CFILTER</code>\n+|-\n+!+40\n+|<code>GETCFHEADERS</code>||<code>CFHEADERS</code>||<code>GETCFCHECKPT</code>||<code>CFCHECKPT</code>\n+|-\n+!+44\n+|<code>WTXIDRELAY</code>||<code>ADDRV2</code>||<code>SENDADDRV2</code>||(undefined)",
      "path": "bip-0324.mediawiki",
      "position": null,
      "original_position": 558,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`VERSION`, `VERACK`,`SENDHEADERS`, `WTXIDRELAY`, and `SENDADDRV2` are only sent at most once per connection; wouldn't it make sense to reserve single byte message types for things that will give a meaningful benefit from compression? (EDIT: `GETADDR` too, arguably)",
      "created_at": "2022-10-08T01:18:21Z",
      "updated_at": "2022-10-08T01:36:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990567999",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990567999"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 558,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990568481",
      "pull_request_review_id": 1135156164,
      "id": 990568481,
      "node_id": "PRRC_kwDOAN28mc47CuAh",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>\n+\n+The following table lists currently defined message type IDs:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+|-\n+!+0\n+|(undefined)||(1 byte string)||(2 byte string)||(3 byte string)\n+|-\n+!+4\n+|(4 byte string)||(5 byte string)||(6 byte string)||(7 byte string)\n+|-\n+!+8\n+|(8 byte string)||(9 byte string)||(10 byte string)||(11 byte string)\n+|-\n+!+12\n+|(12 byte string)||<code>ADDR</code>||<code>BLOCK</code>||<code>BLOCKTXN</code>\n+|-\n+!+16\n+|<code>CMPCTBLOCK</code>||<code>FEEFILTER</code>||<code>FILTERADD</code>||<code>FILTERCLEAR</code>\n+|-\n+!+20\n+|<code>FILTERLOAD</code>||<code>GETADDR</code>||<code>GETBLOCKS</code>||<code>GETBLOCKTXN</code>\n+|-\n+!+24\n+|<code>GETDATA</code>||<code>GETHEADERS</code>||<code>HEADERS</code>||<code>INV</code>\n+|-\n+!+28\n+|<code>MEMPOOL</code>||<code>MERKLEBLOCK</code>||<code>NOTFOUND</code>||<code>PING</code>",
      "path": "bip-0324.mediawiki",
      "position": 557,
      "original_position": 546,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The [BIP-61](https://github.com/bitcoin/bips/blob/master/bip-0061.mediawiki) `REJECT` message isn't supported by bitcoin core since 0.19.0, but does seem to still be supported by [btcd](https://github.com/btcsuite/btcd/blob/38ee9a41c8f8aa24a079a28f5e8a86faecffdfe1/peer/peer.go#L997) eg, so maybe would be worth including? On the other hand, maybe there's no point making messages that are only useful for debugging more efficient by a few bytes?",
      "created_at": "2022-10-08T01:22:35Z",
      "updated_at": "2022-10-08T01:34:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990568481",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990568481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 557,
      "original_line": 557,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990568546",
      "pull_request_review_id": 1135156164,
      "id": 990568546,
      "node_id": "PRRC_kwDOAN28mc47CuBi",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>\n+\n+The following table lists currently defined message type IDs:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+|-\n+!+0\n+|(undefined)||(1 byte string)||(2 byte string)||(3 byte string)\n+|-\n+!+4\n+|(4 byte string)||(5 byte string)||(6 byte string)||(7 byte string)\n+|-\n+!+8\n+|(8 byte string)||(9 byte string)||(10 byte string)||(11 byte string)\n+|-\n+!+12\n+|(12 byte string)||<code>ADDR</code>||<code>BLOCK</code>||<code>BLOCKTXN</code>",
      "path": "bip-0324.mediawiki",
      "position": 545,
      "original_position": 534,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is there any reason to expect clients supporting this BIP to use `ADDR` rather than `ADDRV2`?",
      "created_at": "2022-10-08T01:23:07Z",
      "updated_at": "2022-10-08T01:34:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990568546",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990568546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 545,
      "original_line": 545,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990569523",
      "pull_request_review_id": 1135156164,
      "id": 990569523,
      "node_id": "PRRC_kwDOAN28mc47CuQz",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>",
      "path": "bip-0324.mediawiki",
      "position": 523,
      "original_position": 512,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Updating this table seems like it might be annoying (both if proposals made at the same time both choose the same byte, and if a proposal using just an ascii string wants to add support for a one byte id, while remaining compatible with nodes that aren't aware of the new id) -- it seems like it would serialize adding features in a similar way to having to bump the protocol version number to indicate support for a feature.\r\n\r\nDid you consider a more generic approach, like just running the protocol through a compression stage prior to encryption, and letting that automatically reduce commonly used message types into a shorter byte stream?",
      "created_at": "2022-10-08T01:31:56Z",
      "updated_at": "2022-10-08T01:34:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990569523",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990569523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 523,
      "original_line": 523,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990575987",
      "pull_request_review_id": 1135167730,
      "id": 990575987,
      "node_id": "PRRC_kwDOAN28mc47Cv1z",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>\n+\n+The following table lists currently defined message type IDs:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+|-\n+!+0\n+|(undefined)||(1 byte string)||(2 byte string)||(3 byte string)\n+|-\n+!+4\n+|(4 byte string)||(5 byte string)||(6 byte string)||(7 byte string)\n+|-\n+!+8\n+|(8 byte string)||(9 byte string)||(10 byte string)||(11 byte string)\n+|-\n+!+12\n+|(12 byte string)||<code>ADDR</code>||<code>BLOCK</code>||<code>BLOCKTXN</code>\n+|-\n+!+16\n+|<code>CMPCTBLOCK</code>||<code>FEEFILTER</code>||<code>FILTERADD</code>||<code>FILTERCLEAR</code>\n+|-\n+!+20\n+|<code>FILTERLOAD</code>||<code>GETADDR</code>||<code>GETBLOCKS</code>||<code>GETBLOCKTXN</code>\n+|-\n+!+24\n+|<code>GETDATA</code>||<code>GETHEADERS</code>||<code>HEADERS</code>||<code>INV</code>\n+|-\n+!+28\n+|<code>MEMPOOL</code>||<code>MERKLEBLOCK</code>||<code>NOTFOUND</code>||<code>PING</code>\n+|-\n+!+32\n+|<code>PONG</code>||<code>SENDCMPCT</code>||<code>SENDHEADERS</code>||<code>TX</code>\n+|-\n+!+36\n+|<code>VERACK</code>||<code>VERSION</code>||<code>GETCFILTERS</code>||<code>CFILTER</code>\n+|-\n+!+40\n+|<code>GETCFHEADERS</code>||<code>CFHEADERS</code>||<code>GETCFCHECKPT</code>||<code>CFCHECKPT</code>\n+|-\n+!+44\n+|<code>WTXIDRELAY</code>||<code>ADDRV2</code>||<code>SENDADDRV2</code>||(undefined)",
      "path": "bip-0324.mediawiki",
      "position": null,
      "original_position": 558,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": 990567999,
      "user": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There are 210 additional message type IDs still available to allocate. In the future, if we did come close to using them up, a future upgrade could interpret 0xFF as \"the next byte(or more than one) is also a part of the message type ID\". Given that, it made sense to allocate an ID to all message types still in use.",
      "created_at": "2022-10-08T02:33:11Z",
      "updated_at": "2022-10-08T13:08:27Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990575987",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990575987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 558,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990576228",
      "pull_request_review_id": 1135167938,
      "id": 990576228,
      "node_id": "PRRC_kwDOAN28mc47Cv5k",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>",
      "path": "bip-0324.mediawiki",
      "position": 523,
      "original_position": 512,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": 990569523,
      "user": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In the time that I worked on it, we did not consider such a generic approach. However, I imagine such an approach might come with new dependencies and an increased surface area?",
      "created_at": "2022-10-08T02:35:14Z",
      "updated_at": "2022-10-08T02:35:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990576228",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990576228"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 523,
      "original_line": 523,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990579358",
      "pull_request_review_id": 1135170971,
      "id": 990579358,
      "node_id": "PRRC_kwDOAN28mc47Cwqe",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>",
      "path": "bip-0324.mediawiki",
      "position": 523,
      "original_position": 512,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": 990569523,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think we really considered that possibility in this context.\n\nGeneric compression may be useful, but for it to be useful for tiny messages, I think we'll need some kind of training data or dictionary approach; generic compression without that really only is beneficial after sufficient amounts of data.\n\nFor example zstd compression have standard tooling for constructing dictionary files based on training data. I could imagine an extension that uses that, either with a single dictionary, or a small per-message-type one. But that doesn't help us around the message coordination (either because the training data will become outdated with new messages, and switching to another dictionary is a protocol break; or, because new per-message dicts need some form of signalling... like this table).",
      "created_at": "2022-10-08T03:06:36Z",
      "updated_at": "2022-10-08T03:06:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990579358",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990579358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 523,
      "original_line": 523,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990740263",
      "pull_request_review_id": 1135304832,
      "id": 990740263,
      "node_id": "PRRC_kwDOAN28mc47DX8n",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>",
      "path": "bip-0324.mediawiki",
      "position": 523,
      "original_position": 512,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": 990569523,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I agree a custom (compression) dictionary doesn't seem workable; I was thinking of having a compression stream over the entire connection lifetime, and invoking `flush` after each message, or perhaps when the uncompressed send buffer is empty.\r\n\r\nI guess updating the mapping as a whole (this bip specifies table version 0, then later define table version 1 mapping 13..255 to some particular set of messages, then version 2 later provides some other mapping), and listing out the table versions you both support either using the VERSION message, or via some new message prior to VERACK, and then using the highest version that you both support once VERACK is completed would work. Perhaps message type 0 could be used for VERSION, since there's presumably no way it can be changed while retaining compatibility?",
      "created_at": "2022-10-09T06:16:24Z",
      "updated_at": "2022-10-09T13:14:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990740263",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990740263"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 523,
      "original_line": 523,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990783540",
      "pull_request_review_id": 1135342632,
      "id": 990783540,
      "node_id": "PRRC_kwDOAN28mc47Dig0",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>",
      "path": "bip-0324.mediawiki",
      "position": 523,
      "original_position": 512,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": 990569523,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "An alternative is adding a feature later where the sender just announces their mapping once (\"I will use byte `<byte>` for message type `<string>`), possibly so that any byte not listed retains its original assignment. That means a one-time up-to-3KiB cost for a fully custom set, but removes all coordination issues. ",
      "created_at": "2022-10-09T12:36:14Z",
      "updated_at": "2022-10-09T12:36:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990783540",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990783540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 523,
      "original_line": 523,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990787314",
      "pull_request_review_id": 1135345836,
      "id": 990787314,
      "node_id": "PRRC_kwDOAN28mc47Djby",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()\n+</pre>\n+\n+Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code> followed by an authenticated, encrypted packet with empty contents<ref name=\"send_empty_garbauth\">'''Does the content of the garbage authentication packet need to be empty?''' The receiver ignores the content of the garbage authentication packet, so its content can be anything, and it can in principle be used as a shaping mechanism too. There is however no need for that, as immediately afterwards the initiator can start using decoy packets as (much more flexible) shaping mechanism instead.</ref> to authenticate the garbage, and its own version packet. It then receives the responder's garbage and garbage authentication packet (delimited by the garbage terminator), and checks if the garbage is authenticated correctly. The responder performs very similar steps, but includes the earlier received prefix bytes in the public key. As mentioned before, the encrypted packets for the '''version negotiation phase''' can be piggybacked with the garbage authentication packet to minimize roundtrips.\n+\n+<pre>\n+def complete_handshake(peer, initiating):\n+    received_prefix = b'' if initiating else peer.received_prefix\n+    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n+    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n+                          initiating=initiating)\n+    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n+    # Send garbage terminator + garbage authentication packet + version packet.\n+    send(peer, peer.send_garbage_terminator +\n+               v2_enc_packet(peer, b'', aad=peer.sent_garbage) +\n+               v2_enc_packet(peer, TRANSPORT_VERSION))\n+    # Skip garbage, until encountering garbage terminator.\n+    received_garbage = recv(peer, 16)\n+    for i in range(4096):\n+        if received_garbage[-16:] == peer.recv_garbage_terminator:\n+            # Receive, decode, and ignore garbage authentication packet (decoy or not)\n+            v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)\n+            # Receive, decode, and ignore version packet, skipping decoys\n+            v2_receive_packet(peer)\n+            return\n+        else:\n+            received_garbage += recv(peer, 1)\n+    # Garbage terminator was not seen after 4 KiB of garbage.\n+    disconnect(peer)\n+</pre>\n+\n+==== Packet encryption ====\n+\n+Lastly, we specify the packet encryption cipher in detail.\n+\n+===== Existing cryptographic primitives =====\n+\n+Packet encryption is built on two existing primitives:\n+\n+* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n+** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n+** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n+* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n+** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n+\n+These will be used for plaintext encryption and length encryption, respectively.\n+\n+===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n+\n+To provide re-keying every 256 packets, we specify two wrappers.\n+\n+The first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 256 messages by hashing the rekey salt together with the previous key to obtain the next one. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little endian encoding of the number of messages with the current key, followed by the 64-bit little endian encoding of the number of rekeyings performed.\n+\n+<pre>\n+REKEY_INTERVAL = 256\n+\n+class FSChaCha20Poly1305:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.message_counter = 0\n+\n+    def get_nonce(self):\n+        ret = (self.message_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n+              (self.message_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+        self.message_counter += 1\n+        if self.message_counter % REKEY_INTERVAL == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+        return ret\n+\n+    def encrypt(self, aad, plaintext):\n+        return aead_chacha20_poly1305_encrypt(self.key, self.get_nonce(), aad, plaintext)\n+\n+    def decrypt(self, aad, ciphertext):\n+        return aead_chacha20_poly1305_decrypt(self.key, self.get_nonce(), aad, ciphertext)\n+</pre>\n+\n+The second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 256 chunks where a ''chunk'' refers to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 256 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 256 chunks is composed of 4 zero bytes followed by the 64-bit little endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n+\n+<pre>\n+class FSChaCha20:\n+    def __init__(self, initial_key, rekey_salt):\n+        self.key = initial_key\n+        self.rekey_salt = rekey_salt\n+        self.block_counter = 0\n+        self.chunk_counter = 0\n+        self.keystream = b''\n+\n+    def crypt(self, chunk):\n+        while len(self.keystream) < len(chunk):\n+            nonce = (0).to_bytes(4, 'little') +\n+                    (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little')\n+            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n+            self.block_counter += 1\n+        ret = bytes([self.keystream[i] ^ chunk[i] for i in range(len(chunk))])\n+        self.keystream = self.keystream[len(chunk):]\n+        self.chunk_counter += 1\n+        if (self.chunk_counter % REKEY_INTERVAL) == 0:\n+            self.key = hashlib.sha256(self.rekey_salt + self.key).digest()\n+            self.block_counter = 0\n+        return ret\n+</pre>\n+\n+===== Overall packet encryption and decryption pseudocode =====\n+\n+Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n+\n+<pre>\n+LENGTH_FIELD_LEN = 3\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+\n+def v2_enc_packet(peer, contents, aad=b'', ignore=False):\n+    assert len(contents) <= 2**24 - 1\n+    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+    plaintext = header + contents\n+    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n+    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+    return enc_contents_len + aead_ciphertext\n+</pre>\n+\n+<pre>\n+CHACHA20POLY1305_EXPANSION = 16\n+\n+def v2_receive_packet(peer, aad=b'', skip_decoy=True):\n+    while True:\n+        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n+        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n+        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n+        plaintext = peer.recv_P.decrypt(aead_ciphertext)\n+        if plaintext is None:\n+            disconnect(peer)\n+            break\n+        header = plaintext[:HEADER_LEN]\n+        if not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\n+            return plaintext[HEADER_LEN:]\n+</pre>\n+\n+==== Performance ====\n+\n+Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n+\n+=== Application layer specification ===\n+==== v2 Bitcoin P2P message structure ====\n+v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n+\n+{|class=\"wikitable\"\n+! Field !! Size in bytes !! Comments\n+|-\n+| <code>message_type</code> || ''1..13'' || either a one byte ID or an ASCII string prefixed with a length byte\n+|-\n+| <code>message_payload</code> || <code>message_length</code> || message payload\n+|}\n+\n+If the first byte of <code>message_type</code> is in the range ''1..12'', it is interpreted as the number of ASCII bytes that follow for the message type. If it is in the range ''13..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol as most messages sent/received will have a message type ID.<ref name=\"smaller_messages\">'''How do the length between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>",
      "path": "bip-0324.mediawiki",
      "position": 523,
      "original_position": 512,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": 990569523,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you're mapping `44=WTXIDRELAY` then the receiver presumably either knows how to interpret `WTXIDRELAY`, and can map it to a one or two byte enum `MSG_WTXIDRELAY`, or doesn't know how to interpret `WTXIDRELAY` and can map it to the same one/two byte enum as `MSG_INVALID` or `MSG_IGNORE`. So really this would be an up to 3kB message to announce your mappings but only 250 to 500 bytes per peer to actually track the mapping.",
      "created_at": "2022-10-09T13:11:43Z",
      "updated_at": "2022-10-09T13:11:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r990787314",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/990787314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 523,
      "original_line": 523,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1032822396",
      "pull_request_review_id": 1194901055,
      "id": 1032822396,
      "node_id": "PRRC_kwDOAN28mc49j558",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()",
      "path": "bip-0324.mediawiki",
      "position": null,
      "original_position": 358,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Am I correct in assuming that this inbound downgrade logic only exists because service flags are additive and v1 clients will make connection to addresses that have the v2 service bit?\r\n\r\nCould it make more sense to introduce a new BIP155 network type instead of using the service flags? All the current network types essentially define a separate transport/network protocol (IPv{4,6}, Tor, I2P, CJDNS) while the current service flags are more about what type of application data a node serves (blocks, witnesses, compact filters, bloom filters).",
      "created_at": "2022-11-26T19:05:06Z",
      "updated_at": "2022-11-26T19:22:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r1032822396",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1032822396"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": 345,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1037365836",
      "pull_request_review_id": 1201374847,
      "id": 1037365836,
      "node_id": "PRRC_kwDOAN28mc491PJM",
      "diff_hunk": "@@ -0,0 +1,587 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 P2P Encrypted Transport Protocol\n+  Author: Dhruv Mehta <dhruv@bip324.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Jonas Schnelli <dev@jonasschnelli.ch>\n+          Pieter Wuille <bitcoin-dev@wuille.net>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: BSD-3-Clause\n+  Replaces: 151\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n+\n+=== Copyright ===\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n+\n+* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n+* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n+* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n+\n+This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n+\n+* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in case of manual, deliberate connections (as opposed to automatic, random ones) they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n+* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n+* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n+\n+''' Why encrypt without authentication?'''\n+\n+As we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n+* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n+* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some means of known public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus all connections should use encryption, even if they are unauthenticated.\n+\n+When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n+\n+''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n+\n+Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n+\n+A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n+\n+''' Why not use a secure tunnel protocol? '''\n+\n+Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, as well as the the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN networks, these are not desirable or applicable for automatic connections at scale:\n+* Proxy networks like Tor or I2P introduce a separate address space, independent from network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n+* VPN networks like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n+\n+Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.\n+\n+''' Why not use a general-purpose transport encryption protocol? '''\n+\n+While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n+\n+The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n+\n+In contrast, our proposal instead aims for simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside with the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n+\n+Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n+\n+* Neither offers a pseudorandom bytestream.\n+* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n+* Neither offers shapability of the bytestream.\n+* Both provide a stream-based interface to the application layer whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n+\n+While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n+\n+== Goals ==\n+\n+This proposal aims to achieve the following properties:\n+\n+* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n+* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n+* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n+* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n+* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n+* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n+* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n+* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n+\n+== Specification ==\n+\n+The specification consists of three parts:\n+\n+* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n+* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n+* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n+\n+=== Transport layer specification ===\n+\n+In this section we define the encryption protocol for messages between peers.\n+\n+==== Overview and design ====\n+\n+We first give an informal overview of the entire protocol flow and packet encryption.\n+\n+'''Protocol flow overview'''\n+\n+Given a newly-established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n+\n+# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n+#* The initiator:\n+#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n+#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n+#* The responder:\n+#** Waits until one byte is received which does not match the 12 bytes consisting of the network magic followed by \"version\\x00\". If the first 12 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 12 bytes?''' This is so unlikely (probability of ''2<sup>-96</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it.</ref>\n+#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n+#** Similarly may send up to 4095 bytes of garbage data after their public key.\n+#* Both parties:\n+#** Receive (the remainder of) the full 64-byte public key from the other side.\n+#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''rekey salt''', a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadverdently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n+</ref> (one in each direction) using HKDF-SHA256.\n+#** Send their 16-byte garbage terminator<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the garbage authentication packet directly as a terminator (scan until a valid authentication packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref> followed by a '''garbage authentication packet'''<ref name=\"why_garbage_auth\">'''Why does the protocol require a garbage authentication packet?''' Otherwise the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>, an '''encrypted packet''' (see further) with arbitrary '''contents''', and '''associated data''' equal to the garbage.\n+#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n+#** Receive an encrypted packet, verify that it decrypts correctly with associated data set to the garbage received, and then ignore its contents.\n+#* At this point, both parties have the same keys, and all further communication proceeds in the form of encrypted packets. Packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point after this. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n+# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n+#* The responder:\n+#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n+#* The initiator:\n+#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n+#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n+#* The responder:\n+#** Receives a packet, ignores its contents.\n+# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n+#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n+\n+In order to provide a means of avoiding the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n+\n+* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 12 bytes prefix.\n+* The responder must start sending after having received at least one byte that mismatches that 12-byte prefix.\n+* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n+* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n+* After either party has sent their garbage terminator, they must also send the garbage authentication packet without waiting for more bytes, and transition to the version negotiation phase.\n+\n+Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n+\n+Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage authentication packet. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n+\n+* the initiator sends public key + garbage\n+* the responder sends public key + garbage + garbage terminator + garbage authentication packet + version packet\n+* the initiator sends garbage terminator + garbage authentication packet + version packet\n+\n+'''Packet encryption overview'''\n+\n+All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n+\n+Each packet consists of:\n+* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accomodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n+* An authenticated encryption of the '''plaintext''', which consists of:\n+** A 1-byte '''header''' which consists of transport layer protocol flags. Currently only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n+** The variable-length '''contents'''.\n+\n+The encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used amonst others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n+\n+The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n+* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n+* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n+* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n+* A hash step is performed every 256 messages to rekey the the encryption ciphers, in order to provide forward security.\n+</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n+\n+In order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection in order to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 256<ref name=\"rekey_interval\">'''How was the rekeying interval 256 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 256 packets in about 3.56 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 256 messages is sufficiently infrequent that it has only negligible impact on performance.</ref> messages, by hashing a shared secret-derived '''rekey salt''' together with the previous key to obtain the next key.<ref name=\"why_rekey_salt>'''Why is there a rekey salt?''' Salting the rekeying operation is not strictly necessary for security, but it is free, as SHA256 hashing 32 or 55 bytes has the same complexity.</ref>\n+\n+==== Handshake: key exchange and version negotiation ====\n+\n+Next we specify the handshake of a connection in detail.\n+\n+As explained before, these messages are sent to set up the connection:\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------------------\n+ | Initiator                         Responder                                                      |\n+ |                                                                                                  |\n+ | x, ellswift_X = ellswift_create(initiating=True)                                                 |\n+ |                                                                                                  |\n+ |           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n+ |                                                                                                  |\n+ |                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n+ |                                   ecdh_secret = v2_ecdh(                                         |\n+ |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n+ |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n+ |                                                                                                  |\n+ |           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n+ |                    responder_garbage_terminator (16 bytes) +                                     |\n+ |                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n+ |                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n+ |                                                                                                  |\n+ | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n+ | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n+ |                                                                                                  |\n+ |            --- initiator_garbage_terminator (16 bytes) +                                         |\n+ |                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n+ |                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n+ |                                                                                                  |\n+ ----------------------------------------------------------------------------------------------------\n+</pre>\n+\n+===== Shared secret computation =====\n+\n+The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n+\n+<pre>\n+def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+    if initiating:\n+        # Initiating, place our public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+    else:\n+        # Responding, place their public key encoding first.\n+        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+</pre>\n+\n+Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+===== ElligatorSwift encoding of curve X coordinates =====\n+\n+The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\n+ElligatorSwift-encoded public keys.\n+\n+First we define a constant:\n+* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n+\n+To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+* ''XSwiftEC(u, t)'':\n+** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n+*** If ''u mod p = 0'', let ''u = 1'' instead.\n+*** If ''t mod p = 0'', let ''t = 1'' instead.\n+*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n+** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n+** Let ''Y = (X + t)/(cu) (mod p)''.\n+** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n+*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n+\n+To find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range 0 to 7 inclusive, which selects which of the up to 8 valid such ''t'' values to return:\n+\n+* ''XSwiftECInv(x, u, case)'':\n+** If ''case & 2 = 0'':\n+*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n+*** Let ''v = x'' if ''case & 1 = 0''; let ''v = -x - u (mod p)'' otherwise.\n+*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n+** If ''case & 2 = 2'':\n+*** Let ''s = x - u (mod p)''.\n+*** If ''s = 0'', return ''None''.\n+*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n+*** If ''case & 1 = 1'':\n+**** If ''r = 0'', return ''None''.\n+**** let ''r = -r (mod p)''.\n+*** Let ''v = (-u + r/s)/2''.\n+** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n+** If ''case & 4 = 4'', let ''w = -w (mod p)''.\n+** Return ''w(u(c - 1)/2 - v)''.\n+\n+The overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n+\n+* ''XElligatorSwift(x)'':\n+** Loop:\n+*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n+*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n+*** Compute ''t = XSwiftECInv(x, u, case)''.\n+*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n+\n+This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n+\n+* ''ellswift_create()'':\n+** Generate a random private key ''priv'' in range ''1..p-1''.\n+** Let ''P = priv⋅G'', the corresponding public key point to ''priv''.\n+** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n+** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n+** Return ''(priv, ellswift_pub)''.\n+\n+Finally the <code>ellswift_ecdh_xonly</code> algorithm is:\n+\n+* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n+** Let ''u = int(ellswift_theirs[:32]) mod p''.\n+** Let ''t = int(ellswift_theirs[32:]) mod p''.\n+** Return ''bytes(x(priv⋅lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n+\n+===== Keys and session ID derivation =====\n+\n+The authenticated encryption construction proposed here requires two 32-byte keys per communication direction and a 23-byte rekey salt.<ref>'''Why is the rekey salt 23 bytes?''' The rekeying procedure <code>new_key = SHA256(rekey_salt + key)</code> can be completed in a single SHA256 block compression when the 23 byte rekey salt is combined with a 32 byte key and (the minimum of) 9 bytes of padding used by the hash construction. Any longer a rekey salt would result in multiple compressions.</ref> These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n+\n+<pre>\n+def initialize_v2_transport(peer, ecdh_secret, initiating):\n+    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n+    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n+\n+    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n+\n+    # Initialize the packet encryption ciphers.\n+    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n+    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n+    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n+    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n+    rekey_salt  = HKDF_Expand(Hash=sha256, PRK=prk, info=b'rekey_salt',  L=23)\n+    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n+    initiator_garbage_terminator = garbage_terminators[:16]\n+    responder_garbage_terminator = garbage_terminators[16:]\n+\n+    if initiating:\n+        peer.send_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.send_garbage_terminator = initiator_garbage_terminator\n+        peer.recv_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.recv_garbage_terminator = responder_garbage_terminator\n+    else:\n+        peer.send_L = FSChaCha20(responder_L, rekey_salt)\n+        peer.send_P = FSChaCha20Poly1305(responder_P, rekey_salt)\n+        peer.send_garbage_terminator = responder_garbage_terminator\n+        peer.recv_L = FSChaCha20(initiator_L, rekey_salt)\n+        peer.recv_P = FSChaCha20Poly1305(initiator_P, rekey_salt)\n+        peer.recv_garbage_terminator = initiator_garbage_terminator\n+\n+    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n+    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n+</pre>\n+\n+The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n+\n+===== Overall handshake pseudocode =====\n+\n+To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n+\n+<pre>\n+def initiate_v2_handshake(peer, garbage_len):\n+    peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\n+    peer.sent_garbage = rand_bytes(garbage_len)\n+    send(peer, peer.ellswift_ours + peer.sent_garbage)\n+</pre>\n+\n+The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 12 bytes received match the v1 prefix, the v1 protocol is used instead.\n+\n+<pre>\n+TRANSPORT_VERSION = b''\n+NETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\n+V1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n+\n+def respond_v2_handshake(peer, garbage_len):\n+    peer.received_prefix = b\"\"\n+    while len(prefix) < 12:\n+        peer.received_prefix += receive(peer, 1)\n+        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n+            peer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\n+            peer.sent_garbage = rand_bytes(garbage_len)\n+            send(peer, ellswift_Y + peer.sent_garbage)\n+            return\n+    use_v1_protocol()",
      "path": "bip-0324.mediawiki",
      "position": null,
      "original_position": 358,
      "commit_id": "32af2c9dc2d88df12b02409a023d647ee1de4c8a",
      "original_commit_id": "245d21cf2f425cd2074daa211ff94ea1c2e4bf89",
      "in_reply_to_id": 1032822396,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So your proposal is something like:\r\n\r\n* Add new BIP155 network types TRANSV2_IPV4, TRANSV2_IPV6 (and perhaps TRANSV2_TOR_V3, etc), corresponding to existing V1 transports on those networks (with similar IP/hash encoding).\r\n* Allow nodes to support just v1, just v2, or both if done on separate ports.\r\n* Drop the ability to create a v2 listener that can detect inbound v1 connections on the same port.\r\n\r\nI do agree that's somewhat cleaner as service flags aren't a perfect match, but using separate networks has downsides too (roughly in decreasing order of severity):\r\n\r\n* To avoid creating a heightened partition risk between v1 and v2, I think we need to expect that most nodes support both, at least on inbound, probably for a long time. And if that is the case, the introduction of new networks means effectively a doubling of addrv2 data rumoured on the network, as well as a duplication of addrman entries (or equivalent in other implementations).\r\n* V2 address propagation will initially be hampered by being treated as unknown network by old nodes (a bootstrapping problem every new network has).\r\n* Requiring every node to listen on two ports if they want to support v2 also means that in some instances, upgrading needs system administrator intervention to open ports.\r\n* Special logic is needed so that if a node knows about a peer's IP in both V1 and V2 networks, it can prefer the V2 one.\r\n* Anti-DOS logic would need to be special cased to treat V1 and corresponding V2 networks as the same (as clearly control over a netrange in one implies control over the same netrange in the other).\r\n\r\nSo I think that using service flags is a nice workaround for these issues, as it naturally implies the V1 and V2 \"entry\" to a node will be thought of as a single entity for the purpose of address relay, even to old nodes. It does mean listeners for now need auto-detection logic to be able to serve both V1 and V2 on the same port, but I think that's mostly an implementation issue.\r\n\r\nThe way to think about the service flags is that it is a hint to try V2 connections to a node. If the service flags incorrectly contains V2, the responder will almost certainly immediately disconnect, which the initiator interprets as a \"retry as V1\" per BIP324. Once a connection is established, using either V1 or V2, the initiator's knowledge of the responder's service flags will be corrected using the VERSION message, so even if the flags incorrectly say V1, the initiator can then still decide to reconnect as V2 (and if not, they will the next time a connection is established).\r\n\r\nSo it's just a hint, and not a disaster if it's wrong in either direction. It's an optimistic optimization over just not having any service flag at all, and make every V2 initiator always try V2 first and fall back to V1 on every connection. Given a very effective P2P attacker which can \"or in\" the V2 flag to every rumoured service flag, the service flag approach effectively becomes identical to not having the flags in the first place.\r\n",
      "created_at": "2022-12-01T17:05:56Z",
      "updated_at": "2022-12-01T18:24:59Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1378#discussion_r1037365836",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1037365836"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1378"
        }
      },
      "start_line": null,
      "original_start_line": 345,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 357,
      "side": "RIGHT"
    }
  ]
}