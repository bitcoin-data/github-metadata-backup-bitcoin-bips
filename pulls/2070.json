{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/2070",
    "id": 3143734105,
    "node_id": "PR_kwDOAN28mc67YZNZ",
    "html_url": "https://github.com/bitcoin/bips/pull/2070",
    "diff_url": "https://github.com/bitcoin/bips/pull/2070.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/2070.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/2070/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/289286c95bd719cdd0fb3c2d3ad19a64193d614c",
    "number": 2070,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "BIP445: FROST Signing Protocol for BIP340 Signatures",
    "user": {
      "login": "siv2r",
      "id": 56887198,
      "node_id": "MDQ6VXNlcjU2ODg3MTk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/siv2r",
      "html_url": "https://github.com/siv2r",
      "followers_url": "https://api.github.com/users/siv2r/followers",
      "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
      "organizations_url": "https://api.github.com/users/siv2r/orgs",
      "repos_url": "https://api.github.com/users/siv2r/repos",
      "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/siv2r/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "This PR adds a BIP for the FROST (Flexible Round-Optimized Schnorr Threshold) signing protocol. The development repository is at https://github.com/siv2r/bip-frost-signing.\r\n\r\nThere already exists [RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html), which standardizes the two-round FROST signing protocol, but it is incompatible with Bitcoin's BIP340 X-only public keys. This BIP bridges that gap by providing a BIP340-compatible variant of FROST.\r\n\r\nThis BIP standardizes the FROST3 variant (Section 2.3 of the [ROAST paper](https://eprint.iacr.org/2022/550.pdf)). This variant shares significant similarities with the MuSig2 signing protocol (BIP327). Accordingly, this BIP follows the core design principles of [BIP327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki), and many sections have been directly adapted from it.\r\n\r\nFROST key generation is out of scope for this BIP. There are sister BIPs such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg) and [Trusted Dealer Generation](https://github.com/BEULAHEVANJALIN/bip-frost-trusted-dealer) that specify key generation mechanisms. This BIP must be used in conjunction with either of those for the full workflow from key generation to signature creation. Careful consideration has been taken to ensure the terminology in this BIP matches that of ChillDKG.\r\n\r\nThere are multiple (experimental) implementations of this specification:\r\n- The reference Python implementation included in this PR\r\n- [secp256k1-zkp FROST module](https://github.com/BlockstreamResearch/secp256k1-zkp/pull/278) (yet to implement the test vectors)\r\n- ~[FROST-BIP340](https://github.com/jesseposner/FROST-BIP340)~ TODO: verify if this impl is compatible with our test vectors\r\n- ~[secp256kfun](https://github.com/LLFourn/secp256kfun/blob/master/schnorr_fun/src/frost/session.rs) (implements ChillDKG with FROST signing)~ TODO: verify if this impl is compatible with our test vectors\r\n\r\n**Disclosure:** AI has been used to rephrase paragraphs for clarity, refactor certain sections of the reference code, and review pull requests made to the development repository. \r\n\r\nFeedback is appreciated! Please comment on this pull request or open an issue at https://github.com/siv2r/bip-frost-signing for any feedback. Thank you!\r\n\r\ncc @jonasnick @real-or-random @jesseposner",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 6924377447,
        "node_id": "LA_kwDOAN28mc8AAAABnLmdZw",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/PR%20Author%20action%20required",
        "name": "PR Author action required",
        "description": "Needs updates, has unaddressed review comments, or is otherwise waiting for PR author",
        "color": "e99695",
        "default": false
      }
    ],
    "created_at": "2026-01-03T18:00:46Z",
    "updated_at": "2026-02-02T20:15:29Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merged": false,
    "merge_commit_sha": "f1a256ade715fd8a265fef3a37820214f387e22e",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "siv2r:bip-frost-signing",
      "ref": "bip-frost-signing",
      "sha": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 433631019,
        "node_id": "R_kgDOGdivKw",
        "name": "bips",
        "full_name": "siv2r/bips",
        "owner": {
          "login": "siv2r",
          "id": 56887198,
          "node_id": "MDQ6VXNlcjU2ODg3MTk4",
          "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/siv2r",
          "html_url": "https://github.com/siv2r",
          "followers_url": "https://api.github.com/users/siv2r/followers",
          "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
          "organizations_url": "https://api.github.com/users/siv2r/orgs",
          "repos_url": "https://api.github.com/users/siv2r/repos",
          "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/siv2r/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/siv2r/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/siv2r/bips",
        "archive_url": "https://api.github.com/repos/siv2r/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/siv2r/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/siv2r/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/siv2r/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/siv2r/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/siv2r/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/siv2r/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/siv2r/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/siv2r/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/siv2r/bips/contributors",
        "deployments_url": "https://api.github.com/repos/siv2r/bips/deployments",
        "downloads_url": "https://api.github.com/repos/siv2r/bips/downloads",
        "events_url": "https://api.github.com/repos/siv2r/bips/events",
        "forks_url": "https://api.github.com/repos/siv2r/bips/forks",
        "git_commits_url": "https://api.github.com/repos/siv2r/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/siv2r/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/siv2r/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/siv2r/bips.git",
        "issue_comment_url": "https://api.github.com/repos/siv2r/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/siv2r/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/siv2r/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/siv2r/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/siv2r/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/siv2r/bips/languages",
        "merges_url": "https://api.github.com/repos/siv2r/bips/merges",
        "milestones_url": "https://api.github.com/repos/siv2r/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/siv2r/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/siv2r/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/siv2r/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:siv2r/bips.git",
        "stargazers_url": "https://api.github.com/repos/siv2r/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/siv2r/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/siv2r/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/siv2r/bips/subscription",
        "tags_url": "https://api.github.com/repos/siv2r/bips/tags",
        "teams_url": "https://api.github.com/repos/siv2r/bips/teams",
        "trees_url": "https://api.github.com/repos/siv2r/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/siv2r/bips.git",
        "hooks_url": "https://api.github.com/repos/siv2r/bips/hooks",
        "svn_url": "https://github.com/siv2r/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 1,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 18826,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-01T10:29:00Z",
        "created_at": "2021-12-01T00:28:09Z",
        "updated_at": "2026-01-03T11:21:21Z",
        "allow_forking": true
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "43e3983e4b9e9703b32c7f4edea6c60425d5dffe",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5888,
        "stargazers_count": 10528,
        "watchers_count": 10528,
        "size": 18880,
        "default_branch": "master",
        "open_issues_count": 73,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-01-29T18:18:01Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2026-02-02T19:26:13Z",
        "allow_forking": true
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 6582,
    "deletions": 0,
    "changed_files": 40,
    "commits": 7,
    "review_comments": 98,
    "comments": 8
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGI3ZTQyZjkzYjU2NTEwNTVhNGU5YTEyMDJlNzBiMWI0MzI0NmQ0ZDE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "tree": {
        "sha": "b57db43fa590354164a66b4597a0101f0b44ed65",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/b57db43fa590354164a66b4597a0101f0b44ed65"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b57db43fa590354164a66b4597a0101f0b44ed65\nparent fc00f51c229088c447b3694cca9bf14ace0e1a96\nauthor siv2r <siv2ram@gmail.com> 1767446416 +0530\ncommitter siv2r <siv2ram@gmail.com> 1767446827 +0530\n\nAdd BIP FROST Signing for Schnorr threshold signatures\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRv2EYOHAumKdeBnCb+DYEu6GLj3QUCaVkZKwAKCRD+DYEu6GLj\n3apdAQDnR7ccLVi17lCqkHKbtuc78SVx4gCYNSbeZe6copQb9AD/XJFZK9rDuF8R\n6TAwJfSLkPT4ITNxan1n7kweycuguQE=\n=s6Q7\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/fc00f51c229088c447b3694cca9bf14ace0e1a96",
          "sha": "fc00f51c229088c447b3694cca9bf14ace0e1a96",
          "html_url": "https://github.com/bitcoin/bips/commit/fc00f51c229088c447b3694cca9bf14ace0e1a96"
        }
      ],
      "message": "Add BIP FROST Signing for Schnorr threshold signatures",
      "committer": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-03T13:27:07Z"
      },
      "author": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-03T13:20:16Z"
      },
      "sha": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1"
    },
    {
      "event": "mentioned",
      "id": 21837284561,
      "node_id": "MEE_lADOAN28mc7hNLslzwAAAAUVmoTR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284561",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "subscribed",
      "id": 21837284566,
      "node_id": "SE_lADOAN28mc7hNLslzwAAAAUVmoTW",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284566",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "mentioned",
      "id": 21837284569,
      "node_id": "MEE_lADOAN28mc7hNLslzwAAAAUVmoTZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284569",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "subscribed",
      "id": 21837284577,
      "node_id": "SE_lADOAN28mc7hNLslzwAAAAUVmoTh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284577",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "mentioned",
      "id": 21837284584,
      "node_id": "MEE_lADOAN28mc7hNLslzwAAAAUVmoTo",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284584",
      "actor": {
        "login": "jesseposner",
        "id": 12010116,
        "node_id": "MDQ6VXNlcjEyMDEwMTE2",
        "avatar_url": "https://avatars.githubusercontent.com/u/12010116?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jesseposner",
        "html_url": "https://github.com/jesseposner",
        "followers_url": "https://api.github.com/users/jesseposner/followers",
        "following_url": "https://api.github.com/users/jesseposner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jesseposner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jesseposner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jesseposner/subscriptions",
        "organizations_url": "https://api.github.com/users/jesseposner/orgs",
        "repos_url": "https://api.github.com/users/jesseposner/repos",
        "events_url": "https://api.github.com/users/jesseposner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jesseposner/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "subscribed",
      "id": 21837284587,
      "node_id": "SE_lADOAN28mc7hNLslzwAAAAUVmoTr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284587",
      "actor": {
        "login": "jesseposner",
        "id": 12010116,
        "node_id": "MDQ6VXNlcjEyMDEwMTE2",
        "avatar_url": "https://avatars.githubusercontent.com/u/12010116?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jesseposner",
        "html_url": "https://github.com/jesseposner",
        "followers_url": "https://api.github.com/users/jesseposner/followers",
        "following_url": "https://api.github.com/users/jesseposner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jesseposner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jesseposner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jesseposner/subscriptions",
        "organizations_url": "https://api.github.com/users/jesseposner/orgs",
        "repos_url": "https://api.github.com/users/jesseposner/repos",
        "events_url": "https://api.github.com/users/jesseposner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jesseposner/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "commented",
      "id": 3707251353,
      "node_id": "IC_kwDOAN28mc7c-CqZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3707251353",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:12:32Z",
      "updated_at": "2026-01-03T18:12:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "I'll fix the typos check soon",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3707251353",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "commented",
      "id": 3707273822,
      "node_id": "IC_kwDOAN28mc7c-IJe",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3707273822",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:49:43Z",
      "updated_at": "2026-01-04T08:57:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "I can see that GitHub's file changes view shows only one file at a time due to the large number of changes. This is because the reference implementation includes dependencies and auxiliary materials:\r\n\r\n- The reference code uses [secp256k1lab](https://github.com/secp256k1lab/secp256k1lab) python library (vendored as a git subtree, ~20 files) for scalar and group arithmetic. I can remove this from the PR when the library is integrated into this repository (#1855).\r\n- Auxiliary files include `docs/partialsig_forgery.md` (which I can move to a gist if preferred) and a test vector generation script (~1400 lines). I can exclude these if necessary.",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3707273822",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "labeled",
      "id": 21865706760,
      "node_id": "LE_lADOAN28mc7hNLslzwAAAAUXTDUI",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21865706760",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-06T00:53:23Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "renamed",
      "id": 21865763096,
      "node_id": "RTE_lADOAN28mc7hNLslzwAAAAUXTREY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21865763096",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-06T00:57:43Z",
      "rename": {
        "from": "Add BIP: FROST Signing for BIP340-compatible Threshold Signatures",
        "to": "BIP Draft: FROST Signing Protocol for BIP340 Schnorr Signatures"
      }
    },
    {
      "event": "reviewed",
      "id": 3628910689,
      "node_id": "PRR_kwDOAN28mc7YTMhh",
      "url": null,
      "actor": null,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-06T01:14:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "This is just a first glance, but I noticed a few issues:",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3628910689",
      "submitted_at": "2026-01-06T01:14:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGVjNDZhMjAzMjM4NDBiMWE2YWJhODNiYzJkMThiMzRkZDA4MTEyNDU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "tree": {
        "sha": "b1ea7779a989a513e6b0970819876347ebcd5837",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/b1ea7779a989a513e6b0970819876347ebcd5837"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b1ea7779a989a513e6b0970819876347ebcd5837\nparent b7e42f93b5651055a4e9a1202e70b1b43246d4d1\nauthor siv2r <siv2ram@gmail.com> 1767856279 +0530\ncommitter siv2r <siv2ram@gmail.com> 1767856279 +0530\n\nbip-frost-signing: fix typos, preamble, and title\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRv2EYOHAumKdeBnCb+DYEu6GLj3QUCaV9YrgAKCRD+DYEu6GLj\n3QoeAP46owzcKSDC4TAVZawzxmXELo0oPZ3jw4pmJUh5SWFdJgEAtcoIzVJj56Js\nvF38xVueZE6w2CsBYpr94EqbJ8ou/AE=\n=lib2\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
          "sha": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
          "html_url": "https://github.com/bitcoin/bips/commit/b7e42f93b5651055a4e9a1202e70b1b43246d4d1"
        }
      ],
      "message": "bip-frost-signing: fix typos, preamble, and title",
      "committer": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-08T07:11:19Z"
      },
      "author": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-08T07:11:19Z"
      },
      "sha": "ec46a20323840b1a6aba83bc2d18b34dd0811245"
    },
    {
      "event": "renamed",
      "id": 21931755755,
      "node_id": "RTE_lADOAN28mc7hNLslzwAAAAUbPAjr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21931755755",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-08T20:12:02Z",
      "rename": {
        "from": "BIP Draft: FROST Signing Protocol for BIP340 Schnorr Signatures",
        "to": "BIP Draft: FROST Signing Protocol for BIP340 Signatures"
      }
    },
    {
      "event": "reviewed",
      "id": 3641092452,
      "node_id": "PRR_kwDOAN28mc7ZBqlk",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-08T20:17:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the quick turn-around. Itâ€™s on my todo list to give this a more thorough look, but it might take a bit. If you can motivate some other reviewers meanwhile, that would also be welcome.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3641092452",
      "submitted_at": "2026-01-08T20:17:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "commented",
      "id": 3728923010,
      "node_id": "IC_kwDOAN28mc7eQtmC",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3728923010",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-09T13:30:19Z",
      "updated_at": "2026-01-09T13:30:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "> If you can motivate some other reviewers meanwhile, that would also be welcome.\r\n\r\nI've shared it with most of the Bitcoin cryptographers I know and will post it on Twitter and the Bitcoin dev groups I'm part of. Hopefully that will bring in more reviewers!",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3728923010",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "reviewed",
      "id": 3660028850,
      "node_id": "PRR_kwDOAN28mc7aJ5uy",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-14T13:05:15Z",
      "author_association": "NONE",
      "body": "Hi! Quite a remarkable job! We found a few minor issues, and correcting them would improve the overall specification of the BIP.",
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3660028850",
      "submitted_at": "2026-01-14T13:05:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "reviewed",
      "id": 3675747861,
      "node_id": "PRR_kwDOAN28mc7bF3YV",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-18T20:19:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "As I mentioned on X i'm working on this, so you will likely see more comments in the future. Another nice-to-have would be a table of contents ([example](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki#table-of-contents)) as most other BIPs have this. Perhaps this is a limitation of the `.md` document vs `.mediawiki`. Not sure.",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3675747861",
      "submitted_at": "2026-01-18T20:19:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "reviewed",
      "id": 3679618675,
      "node_id": "PRR_kwDOAN28mc7bUoZz",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-19T21:07:06Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3679618675",
      "submitted_at": "2026-01-19T21:07:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "commented",
      "id": 3776054292,
      "node_id": "IC_kwDOAN28mc7hEgQU",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3776054292",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-21T04:13:19Z",
      "updated_at": "2026-01-21T04:13:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Another nice-to-have would be a table of contents ([example](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki#table-of-contents)) as most other BIPs have this. Perhaps this is a limitation of the `.md` document vs `.mediawiki`. Not sure.\r\n\r\nYes, it's a `.md` issue, this bip initially had a manually written table of contents but was removed after https://github.com/bitcoin/bips/pull/2070#discussion_r2663226155",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3776054292",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "commented",
      "id": 3779764190,
      "node_id": "IC_kwDOAN28mc7hSp_e",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3779764190",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-21T17:08:13Z",
      "updated_at": "2026-01-21T17:08:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "> As I mentioned on X i'm working on this, so you will likely see more comments in the future. Another nice-to-have would be a table of contents ([example](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki#table-of-contents)) as most other BIPs have this. Perhaps this is a limitation of the `.md` document vs `.mediawiki`. Not sure.\r\n\r\nClick there. ;)\r\n\r\n<img width=\"1116\" height=\"620\" alt=\"image\" src=\"https://github.com/user-attachments/assets/60befb5c-55a9-4a64-987c-140e944ab88c\" />\r\n",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3779764190",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "commented",
      "id": 3780661049,
      "node_id": "IC_kwDOAN28mc7hWE85",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3780661049",
      "actor": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-21T19:02:15Z",
      "updated_at": "2026-01-21T19:02:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "> > As I mentioned on X i'm working on this, so you will likely see more comments in the future. Another nice-to-have would be a table of contents ([example](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki#table-of-contents)) as most other BIPs have this. Perhaps this is a limitation of the `.md` document vs `.mediawiki`. Not sure.\r\n> \r\n> Click there. ;)\r\n\r\nThank you! TIL :-)\r\n\r\n",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3780661049",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "reviewed",
      "id": 3691689081,
      "node_id": "PRR_kwDOAN28mc7cCrR5",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-22T11:20:44Z",
      "author_association": "NONE",
      "body": "A few additional minor issues and questions.",
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3691689081",
      "submitted_at": "2026-01-22T11:20:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGYyMTI0NGE5ZTVmMjJlN2FiYzM5ZmQzMGYyYWIxYjc3MGU2YWMyNjI",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/f21244a9e5f22e7abc39fd30f2ab1b770e6ac262",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/f21244a9e5f22e7abc39fd30f2ab1b770e6ac262",
      "tree": {
        "sha": "9ce04b0e4ceb1b322a5d8a4b2b648760139933cf",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/9ce04b0e4ceb1b322a5d8a4b2b648760139933cf"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 9ce04b0e4ceb1b322a5d8a4b2b648760139933cf\nparent ec46a20323840b1a6aba83bc2d18b34dd0811245\nauthor siv2r <siv2ram@gmail.com> 1769084809 +0530\ncommitter siv2r <siv2ram@gmail.com> 1769084809 +0530\n\npython: update secp256k1lab & remove the stub file\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRv2EYOHAumKdeBnCb+DYEu6GLj3QUCaXIXoQAKCRD+DYEu6GLj\n3UqrAQDwy7tMx/P5JKJd9Z/8cC1kb3LbWjOa9IZdc+xI+WudDgEAgVXXLQ4CEvng\nPHvpI3nasEvgYxmDdvI3pYeA7M6BQgc=\n=aEpK\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/ec46a20323840b1a6aba83bc2d18b34dd0811245",
          "sha": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
          "html_url": "https://github.com/bitcoin/bips/commit/ec46a20323840b1a6aba83bc2d18b34dd0811245"
        }
      ],
      "message": "python: update secp256k1lab & remove the stub file",
      "committer": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-22T12:26:49Z"
      },
      "author": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-22T12:26:49Z"
      },
      "sha": "f21244a9e5f22e7abc39fd30f2ab1b770e6ac262"
    },
    {
      "event": "reviewed",
      "id": 3694925537,
      "node_id": "PRR_kwDOAN28mc7cPBbh",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-22T22:50:52Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3694925537",
      "submitted_at": "2026-01-22T22:50:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGE4OGYwMzNkZjdhMjM2MWM3MDBmMjA1Y2VkNmI1MGQ0OTg3MWM2OTY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/a88f033df7a2361c700f205ced6b50d49871c696",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/a88f033df7a2361c700f205ced6b50d49871c696",
      "tree": {
        "sha": "73135747fc24fde2274a0611d0c7ca1579997a6a",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/73135747fc24fde2274a0611d0c7ca1579997a6a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 73135747fc24fde2274a0611d0c7ca1579997a6a\nparent f21244a9e5f22e7abc39fd30f2ab1b770e6ac262\nauthor siv2r <siv2ram@gmail.com> 1769333294 +0530\ncommitter siv2r <siv2ram@gmail.com> 1769333294 +0530\n\nbip-frost-signing: fix formatting and explain more\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRv2EYOHAumKdeBnCb+DYEu6GLj3QUCaXXiRgAKCRD+DYEu6GLj\n3R4iAP99QA7tAJnnSHd4WUhrQ94m6Iq5mesrQ5v5BdQA50KceAEAxN/0Mc+AJCoI\nxwC9A5yGqJIrUqwO1+7riyZOMR8qZgU=\n=8MP/\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/f21244a9e5f22e7abc39fd30f2ab1b770e6ac262",
          "sha": "f21244a9e5f22e7abc39fd30f2ab1b770e6ac262",
          "html_url": "https://github.com/bitcoin/bips/commit/f21244a9e5f22e7abc39fd30f2ab1b770e6ac262"
        }
      ],
      "message": "bip-frost-signing: fix formatting and explain more",
      "committer": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-25T09:28:14Z"
      },
      "author": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-25T09:28:14Z"
      },
      "sha": "a88f033df7a2361c700f205ced6b50d49871c696"
    },
    {
      "event": "commented",
      "id": 3796275447,
      "node_id": "IC_kwDOAN28mc7iRpD3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3796275447",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-25T09:33:14Z",
      "updated_at": "2026-01-25T09:33:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "@DarkWindman thanks a lot for the review! I've addressed most of your review comments in a88f033.",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3796275447",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "mentioned",
      "id": 22272480543,
      "node_id": "MEE_lADOAN28mc7hNLslzwAAAAUvixUf",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/22272480543",
      "actor": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-25T09:33:15Z"
    },
    {
      "event": "subscribed",
      "id": 22272480551,
      "node_id": "SE_lADOAN28mc7hNLslzwAAAAUvixUn",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/22272480551",
      "actor": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-25T09:33:15Z"
    },
    {
      "event": "reviewed",
      "id": 3713655608,
      "node_id": "PRR_kwDOAN28mc7dWeM4",
      "url": null,
      "actor": null,
      "commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-27T22:22:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "From an editorial standpoint, it looks pretty good and like all the required sections are present. I have read the proposal only partially, and do not have the expertise to fully understand all aspects, so I cannot comment on the technical soundness and whether the Specification is complete and sufficient.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3713655608",
      "submitted_at": "2026-01-27T22:20:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "labeled",
      "id": 22329910238,
      "node_id": "LE_lADOAN28mc7hNLslzwAAAAUy92Pe",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/22329910238",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-27T22:20:41Z",
      "label": {
        "name": "PR Author action required",
        "color": "e99695"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDZlYTUzZjI0OGI2ZDgzNTAyNjJmYWQ0YWJhMmY2OWZkMGIyZGQ5M2Q",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "tree": {
        "sha": "f9751164a66fb461bdfcc80768fb0ae54cf2e359",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/f9751164a66fb461bdfcc80768fb0ae54cf2e359"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree f9751164a66fb461bdfcc80768fb0ae54cf2e359\nparent a88f033df7a2361c700f205ced6b50d49871c696\nauthor siv2r <siv2ram@gmail.com> 1769615862 +0530\ncommitter siv2r <siv2ram@gmail.com> 1769615862 +0530\n\npython: add license file and re-write to error msg\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRv2EYOHAumKdeBnCb+DYEu6GLj3QUCaXoyJAAKCRD+DYEu6GLj\n3XP9AP41AeQwGNy0LaQBOphgzBZCaORRwajoUaf3zGWi1cAG7QD/fC/9LWdNfXdK\n1n8wDmwBdTBuYXuN37T8wL1tXmRy9wA=\n=UOVe\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/a88f033df7a2361c700f205ced6b50d49871c696",
          "sha": "a88f033df7a2361c700f205ced6b50d49871c696",
          "html_url": "https://github.com/bitcoin/bips/commit/a88f033df7a2361c700f205ced6b50d49871c696"
        }
      ],
      "message": "python: add license file and re-write to error msg",
      "committer": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-28T15:57:42Z"
      },
      "author": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-28T15:57:42Z"
      },
      "sha": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d"
    },
    {
      "event": "reviewed",
      "id": 3718016896,
      "node_id": "PRR_kwDOAN28mc7dnG-A",
      "url": null,
      "actor": null,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-28T17:35:57Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3718016896",
      "submitted_at": "2026-01-28T17:35:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "reviewed",
      "id": 3718749658,
      "node_id": "PRR_kwDOAN28mc7dp53a",
      "url": null,
      "actor": null,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-28T19:38:22Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3718749658",
      "submitted_at": "2026-01-28T19:38:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDVkODdmNTYyNmVkZjM4ODVhYjI1OGZlN2VmM2I0Mzg4MTRmZGViOTY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "tree": {
        "sha": "538b3ec92b42aad038ed2df454186c237c90fac2",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/538b3ec92b42aad038ed2df454186c237c90fac2"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 538b3ec92b42aad038ed2df454186c237c90fac2\nparent 6ea53f248b6d8350262fad4aba2f69fd0b2dd93d\nauthor siv2r <siv2ram@gmail.com> 1769693966 +0530\ncommitter siv2r <siv2ram@gmail.com> 1769693966 +0530\n\nbip-frost-signing: add info about OP_CHECKSIGADD and minor edits\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRv2EYOHAumKdeBnCb+DYEu6GLj3QUCaXtjQQAKCRD+DYEu6GLj\n3eUHAQDDn1dgCYSSSDyPFLqX4fpfskDPg4acY3Jh1fGzattXrQD/bn8d1D8LKKYH\nREWHkzmsEYeeJNTUI9BNZA0ls7GodAo=\n=vUFP\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
          "sha": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
          "html_url": "https://github.com/bitcoin/bips/commit/6ea53f248b6d8350262fad4aba2f69fd0b2dd93d"
        }
      ],
      "message": "bip-frost-signing: add info about OP_CHECKSIGADD and minor edits",
      "committer": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-29T13:39:26Z"
      },
      "author": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-29T13:39:26Z"
      },
      "sha": "5d87f5626edf3885ab258fe7ef3b438814fdeb96"
    },
    {
      "event": "commented",
      "id": 3825935402,
      "node_id": "IC_kwDOAN28mc7kCyQq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3825935402",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-30T21:50:29Z",
      "updated_at": "2026-01-30T22:20:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "Letâ€™s call this BIPâ€¯445. Please add an entry for your proposal in the README table, in the preamble update the BIP header to 445 and Assigned header to 2026-01-30, and update your documents file name as well as the auxiliary file directory.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3825935402",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "renamed",
      "id": 22418425346,
      "node_id": "RTE_lADOAN28mc7hNLslzwAAAAU4PgYC",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/22418425346",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-30T21:50:39Z",
      "rename": {
        "from": "BIP Draft: FROST Signing Protocol for BIP340 Signatures",
        "to": "BIP445: FROST Signing Protocol for BIP340 Signatures"
      }
    },
    {
      "event": "reviewed",
      "id": 3730614122,
      "node_id": "PRR_kwDOAN28mc7eXKdq",
      "url": null,
      "actor": null,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-30T22:06:22Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3730614122",
      "submitted_at": "2026-01-30T22:06:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "reviewed",
      "id": 3733918058,
      "node_id": "PRR_kwDOAN28mc7ejxFq",
      "url": null,
      "actor": null,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-31T23:37:09Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3733918058",
      "submitted_at": "2026-01-31T23:37:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDI4OTI4NmM5NWJkNzE5Y2RkMGZiM2MyZDNhZDE5YTY0MTkzZDYxNGM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "tree": {
        "sha": "31e921e93fc7bbeccac5f9d928e30fa95d07f8b1",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/31e921e93fc7bbeccac5f9d928e30fa95d07f8b1"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 31e921e93fc7bbeccac5f9d928e30fa95d07f8b1\nparent 5d87f5626edf3885ab258fe7ef3b438814fdeb96\nauthor siv2r <siv2ram@gmail.com> 1769939494 +0530\ncommitter siv2r <siv2ram@gmail.com> 1769941721 +0530\n\nrename bip-frost-signing to bip-0445\n\nAlso, add minor fixes in the preamble of the BIP\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRv2EYOHAumKdeBnCb+DYEu6GLj3QUCaX8q2QAKCRD+DYEu6GLj\n3Sq3AQCAAIcE7RGC9TGL89nj0UOKP+TAeVHm9way20jDDktY4QD/as3jmzd4u7EJ\na3r0eTBSGfQyCyL1ZondGCDlU5zXeA4=\n=stIK\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/5d87f5626edf3885ab258fe7ef3b438814fdeb96",
          "sha": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
          "html_url": "https://github.com/bitcoin/bips/commit/5d87f5626edf3885ab258fe7ef3b438814fdeb96"
        }
      ],
      "message": "rename bip-frost-signing to bip-0445\n\nAlso, add minor fixes in the preamble of the BIP",
      "committer": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-02-01T10:28:41Z"
      },
      "author": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-02-01T09:51:34Z"
      },
      "sha": "289286c95bd719cdd0fb3c2d3ad19a64193d614c"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22442341733,
      "node_id": "HRFPE_lADOAN28mc7hNLslzwAAAAU5qvVl",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/22442341733",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "commit_url": "https://api.github.com/repos/siv2r/bips/commits/289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "created_at": "2026-02-01T10:29:01Z"
    },
    {
      "event": "reviewed",
      "id": 3741555342,
      "node_id": "PRR_kwDOAN28mc7fA5qO",
      "url": null,
      "actor": null,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-02-02T20:15:29Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3741555342",
      "submitted_at": "2026-02-02T20:15:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663220161",
      "pull_request_review_id": 3628910689,
      "id": 2663220161,
      "node_id": "PRRC_kwDOAN28mc6evYPB",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 1,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The â€œyamlâ€ here is superfluous and will likely break CI checks.",
      "created_at": "2026-01-06T00:58:33Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663220161",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663220161"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663226155",
      "pull_request_review_id": 3628910689,
      "id": 2663226155,
      "node_id": "PRRC_kwDOAN28mc6evZsr",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational\n+Created:\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Comments-URI:\n+```\n+\n+- [Abstract](#abstract)\n+- [Copyright](#copyright)\n+- [Motivation](#motivation)\n+- [Overview](#overview)\n+  - [Optionality of Features](#optionality-of-features)\n+  - [Key Material and Setup](#key-material-and-setup)\n+    - [Protocol Parties and Network Setup](#protocol-parties-and-network-setup)\n+    - [Signing Inputs and Outputs](#signing-inputs-and-outputs)\n+  - [General Signing Flow](#general-signing-flow)\n+  - [Nonce Generation](#nonce-generation)\n+  - [Identifying Disruptive Signers](#identifying-disruptive-signers)\n+    - [Further Remarks](#further-remarks)\n+  - [Tweaking the Threshold Public Key](#tweaking-the-threshold-public-key)\n+- [Algorithms](#algorithms)\n+  - [Notation](#notation)\n+    - [Cryptographic Types and Operations](#cryptographic-types-and-operations)\n+    - [Auxiliary and Byte-string Operations](#auxiliary-and-byte-string-operations)\n+  - [Key Material and Setup](#key-material-and-setup-1)\n+    - [Signers Context](#signers-context)\n+  - [Tweaking the Threshold Public Key](#tweaking-the-threshold-public-key-1)\n+    - [Tweak Context](#tweak-context)\n+    - [Applying Tweaks](#applying-tweaks)\n+  - [Nonce Generation](#nonce-generation-1)\n+  - [Nonce Aggregation](#nonce-aggregation)\n+  - [Session Context](#session-context)\n+  - [Signing](#signing)\n+  - [Partial Signature Verification](#partial-signature-verification)\n+  - [Partial Signature Aggregation](#partial-signature-aggregation)\n+  - [Test Vectors \\& Reference Code](#test-vectors--reference-code)\n+- [Remarks on Security and Correctness](#remarks-on-security-and-correctness)\n+  - [Modifications to Nonce Generation](#modifications-to-nonce-generation)\n+    - [Deterministic and Stateless Signing for a Single Signer](#deterministic-and-stateless-signing-for-a-single-signer)\n+  - [Tweaking Definition](#tweaking-definition)\n+  - [Negation of the Secret Share when Signing](#negation-of-the-secret-share-when-signing)\n+    - [Negation of the Pubshare when Partially Verifying](#negation-of-the-pubshare-when-partially-verifying)\n+  - [Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation)\n+- [Backwards Compatibility](#backwards-compatibility)\n+- [Changelog](#changelog)\n+- [Acknowledgments](#acknowledgments)",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 52,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks, but it is not necessary to manually include a table of contents. Mediawiki files are automatically rendered with one on GitHub, and you can find one for markdown files here:\r\n<img width=\"812\" height=\"566\" alt=\"image\" src=\"https://github.com/user-attachments/assets/48e1e21b-83f3-4ac0-a3a0-700b57741271\" />\r\n",
      "created_at": "2026-01-06T01:01:53Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663226155",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663226155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663227754",
      "pull_request_review_id": 3628910689,
      "id": 2663227754,
      "node_id": "PRRC_kwDOAN28mc6evaFq",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 8,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This should be labeled as a Standards Track BIP",
      "created_at": "2026-01-06T01:02:41Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663227754",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663227754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663234008",
      "pull_request_review_id": 3628910689,
      "id": 2663234008,
      "node_id": "PRRC_kwDOAN28mc6evbnY",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 3,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Title exceeds 44 characters",
      "created_at": "2026-01-06T01:07:03Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663234008",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663234008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663239079",
      "pull_request_review_id": 3628910689,
      "id": 2663239079,
      "node_id": "PRRC_kwDOAN28mc6evc2n",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational\n+Created:\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Comments-URI:",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 11,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The headers here are a bit out of order. They must be in a specific order (see https://bips.xyz/2#bip-header-preamble), and CI checks will fail if they arenâ€™t.\r\n\r\nThe order should be:\r\n\r\n```suggestion\r\nComments-URI:\r\nStatus: Draft\r\nType: Informational\r\nCreated:\r\nLicense: CC0-1.0\r\nLicense-Code: MIT\r\nPost-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\r\n```",
      "created_at": "2026-01-06T01:10:57Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663239079",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663239079"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 5,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663953656",
      "pull_request_review_id": 3629782051,
      "id": 2663953656,
      "node_id": "PRRC_kwDOAN28mc6eyLT4",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 3,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663234008,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "suggestion: \"FROST Signing Protocol for BIP340 Signatures\" (exactly 44 characters)",
      "created_at": "2026-01-06T07:37:48Z",
      "updated_at": "2026-01-06T07:37:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663953656",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663953656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671151161",
      "pull_request_review_id": 3638053436,
      "id": 2671151161,
      "node_id": "PRRC_kwDOAN28mc6fNog5",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 1,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663220161,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I added it because the syntax highlighting looked nice. Removed it.",
      "created_at": "2026-01-08T07:13:24Z",
      "updated_at": "2026-01-08T07:13:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671151161",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671151161"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671152130",
      "pull_request_review_id": 3638054775,
      "id": 2671152130,
      "node_id": "PRRC_kwDOAN28mc6fNowC",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational\n+Created:\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Comments-URI:\n+```\n+\n+- [Abstract](#abstract)\n+- [Copyright](#copyright)\n+- [Motivation](#motivation)\n+- [Overview](#overview)\n+  - [Optionality of Features](#optionality-of-features)\n+  - [Key Material and Setup](#key-material-and-setup)\n+    - [Protocol Parties and Network Setup](#protocol-parties-and-network-setup)\n+    - [Signing Inputs and Outputs](#signing-inputs-and-outputs)\n+  - [General Signing Flow](#general-signing-flow)\n+  - [Nonce Generation](#nonce-generation)\n+  - [Identifying Disruptive Signers](#identifying-disruptive-signers)\n+    - [Further Remarks](#further-remarks)\n+  - [Tweaking the Threshold Public Key](#tweaking-the-threshold-public-key)\n+- [Algorithms](#algorithms)\n+  - [Notation](#notation)\n+    - [Cryptographic Types and Operations](#cryptographic-types-and-operations)\n+    - [Auxiliary and Byte-string Operations](#auxiliary-and-byte-string-operations)\n+  - [Key Material and Setup](#key-material-and-setup-1)\n+    - [Signers Context](#signers-context)\n+  - [Tweaking the Threshold Public Key](#tweaking-the-threshold-public-key-1)\n+    - [Tweak Context](#tweak-context)\n+    - [Applying Tweaks](#applying-tweaks)\n+  - [Nonce Generation](#nonce-generation-1)\n+  - [Nonce Aggregation](#nonce-aggregation)\n+  - [Session Context](#session-context)\n+  - [Signing](#signing)\n+  - [Partial Signature Verification](#partial-signature-verification)\n+  - [Partial Signature Aggregation](#partial-signature-aggregation)\n+  - [Test Vectors \\& Reference Code](#test-vectors--reference-code)\n+- [Remarks on Security and Correctness](#remarks-on-security-and-correctness)\n+  - [Modifications to Nonce Generation](#modifications-to-nonce-generation)\n+    - [Deterministic and Stateless Signing for a Single Signer](#deterministic-and-stateless-signing-for-a-single-signer)\n+  - [Tweaking Definition](#tweaking-definition)\n+  - [Negation of the Secret Share when Signing](#negation-of-the-secret-share-when-signing)\n+    - [Negation of the Pubshare when Partially Verifying](#negation-of-the-pubshare-when-partially-verifying)\n+  - [Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation)\n+- [Backwards Compatibility](#backwards-compatibility)\n+- [Changelog](#changelog)\n+- [Acknowledgments](#acknowledgments)",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 52,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663226155,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah, I was not aware of this. Thanks!",
      "created_at": "2026-01-08T07:13:49Z",
      "updated_at": "2026-01-08T07:13:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671152130",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671152130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671152564",
      "pull_request_review_id": 3638055293,
      "id": 2671152564,
      "node_id": "PRRC_kwDOAN28mc6fNo20",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational\n+Created:\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Comments-URI:",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 11,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663239079,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Rearragned",
      "created_at": "2026-01-08T07:14:02Z",
      "updated_at": "2026-01-08T07:14:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671152564",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671152564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 5,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671153815",
      "pull_request_review_id": 3638056831,
      "id": 2671153815,
      "node_id": "PRRC_kwDOAN28mc6fNpKX",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 3,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663234008,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I like the suggestion. Updated the title.",
      "created_at": "2026-01-08T07:14:34Z",
      "updated_at": "2026-01-08T07:14:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671153815",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671153815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671154143",
      "pull_request_review_id": 3638057205,
      "id": 2671154143,
      "node_id": "PRRC_kwDOAN28mc6fNpPf",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 8,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663227754,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed",
      "created_at": "2026-01-08T07:14:44Z",
      "updated_at": "2026-01-08T07:14:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671154143",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671154143"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2673736993",
      "pull_request_review_id": 3641081865,
      "id": 2673736993,
      "node_id": "PRRC_kwDOAN28mc6fXf0h",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 3,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663234008,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I also adopted it for the title of this PR. :)",
      "created_at": "2026-01-08T20:12:18Z",
      "updated_at": "2026-01-08T20:12:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2673736993",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2673736993"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2673745481",
      "pull_request_review_id": 3641092452,
      "id": 2673745481,
      "node_id": "PRRC_kwDOAN28mc6fXh5J",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 8,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "As currently BIPâ€¯2 still regulates the BIPâ€¯Process, this should still be Created. (Looking forward to BIPâ€¯3 activating any year now. ;))\r\n\r\n```suggestion\r\nCreated: ?\r\n```",
      "created_at": "2026-01-08T20:14:54Z",
      "updated_at": "2026-01-08T20:17:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2673745481",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2673745481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2676196310",
      "pull_request_review_id": 3643933132,
      "id": 2676196310,
      "node_id": "PRRC_kwDOAN28mc6fg4PW",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 8,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2673745481,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Okay, I'll revert it back.",
      "created_at": "2026-01-09T13:27:07Z",
      "updated_at": "2026-01-09T13:27:07Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2676196310",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2676196310"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689891911",
      "pull_request_review_id": 3660028850,
      "id": 2689891911,
      "node_id": "PRRC_kwDOAN28mc6gVH5H",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation",
      "path": "bip-0445.md",
      "position": 22,
      "original_position": 23,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The first sections of the BIP use `code-style` formatting for variables, which\r\nis convenient in Markdown and improves readability. However, the following sections,\r\nstarting with **General Signing Flow**, do not follow this convention, resulting in an\r\ninconsistent style. \r\nWe suggest adopting a single formatting style throughout the document.",
      "created_at": "2026-01-14T10:36:52Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689891911",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689891911"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 22,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689921315",
      "pull_request_review_id": 3660028850,
      "id": 2689921315,
      "node_id": "PRRC_kwDOAN28mc6gVPEj",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 99,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The first two paragraphs of the **General Signing Flow** section are repetitive. We suggest keeping the second paragraph, as it is easier to follow.",
      "created_at": "2026-01-14T10:42:38Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689921315",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689921315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689930973",
      "pull_request_review_id": 3660028850,
      "id": 2689930973,
      "node_id": "PRRC_kwDOAN28mc6gVRbd",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 261,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It is better to reorder the table to place the scalar `to_bytes` functions before the\r\n`from_bytes` functions, in order to be consistent with the order of the point transformation\r\nfunctions.",
      "created_at": "2026-01-14T10:44:46Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689930973",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689930973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689949680",
      "pull_request_review_id": 3660028850,
      "id": 2689949680,
      "node_id": "PRRC_kwDOAN28mc6gVV_w",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*",
      "path": "bip-0445.md",
      "position": 288,
      "original_position": 289,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This note duplicates the footnote 8 and used twice in the text. We think, it would be simpler to just add modulo _n =_ `order` wherever scalar arithmetic is used.",
      "created_at": "2026-01-14T10:50:08Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689949680",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689949680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 288,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689983627",
      "pull_request_review_id": 3660028850,
      "id": 2689983627,
      "node_id": "PRRC_kwDOAN28mc6gVeSL",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 449,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The multiplication operator `*` is not displayed in the compiled version when calculating `pubnonce` array indices.",
      "created_at": "2026-01-14T11:02:01Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689983627",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689983627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690021238",
      "pull_request_review_id": 3660028850,
      "id": 2690021238,
      "node_id": "PRRC_kwDOAN28mc6gVnd2",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 509,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The computed value P is only used in the subsequent line. It may be clearer to just write _pubshare = cbytes(dâ€²Â·G)_, similar to the `DeterministicSign` algorithm.",
      "created_at": "2026-01-14T11:14:50Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690021238",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690021238"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 509,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690026960",
      "pull_request_review_id": 3660028850,
      "id": 2690026960,
      "node_id": "PRRC_kwDOAN28mc6gVo3Q",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*\n+- LetÂ *pubshare = cbytes(P)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d'*Â (SeeÂ [*Negation of Secret Share When Signing*](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:",
      "path": "bip-0445.md",
      "position": 526,
      "original_position": 526,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Missing the `v` argument, which is listed as an input parameter below.",
      "created_at": "2026-01-14T11:16:58Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690026960",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690026960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 526,
      "original_line": 526,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690035306",
      "pull_request_review_id": 3660028850,
      "id": 2690035306,
      "node_id": "PRRC_kwDOAN28mc6gVq5q",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*\n+- LetÂ *pubshare = cbytes(P)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d'*Â (SeeÂ [*Negation of Secret Share When Signing*](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:\n+\n+- Inputs:\n+  - The partial signatureÂ *psig*: a 32-byte array, serialized scalar\n+  - The list public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte arrays, each an output of *NonceGen*\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+  - The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+  - The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+  - The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+  - The messageÂ *m*: a byte array[^max-msg-len]\n+  - The index *i* of the signer in the list of public nonces where *0 < i â‰¤ u*\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 537,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`thresh_pk` is never used and should be replaced with a wildcard.",
      "created_at": "2026-01-14T11:19:50Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690035306",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690035306"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 537,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690050015",
      "pull_request_review_id": 3660028850,
      "id": 2690050015,
      "node_id": "PRRC_kwDOAN28mc6gVuff",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*\n+- LetÂ *pubshare = cbytes(P)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d'*Â (SeeÂ [*Negation of Secret Share When Signing*](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:\n+\n+- Inputs:\n+  - The partial signatureÂ *psig*: a 32-byte array, serialized scalar\n+  - The list public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte arrays, each an output of *NonceGen*\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+  - The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+  - The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+  - The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+  - The messageÂ *m*: a byte array[^max-msg-len]\n+  - The index *i* of the signer in the list of public nonces where *0 < i â‰¤ u*\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *aggnonce = NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*; fail if that fails\n+- Let *session_ctx = (signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)*\n+- RunÂ *PartialSigVerifyInternal(psig, id<sub>i</sub>, pubnonce<sub>i</sub>, pubshare<sub>i</sub>, session_ctx)*\n+- Return success iff no failure occurred before reaching this point.\n+\n+Internal Algorithm *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*:\n+\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *s = scalar_from_bytes_nonzero_checked(psig)*; fail if that fails\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *R<sub>\\*,1</sub>Â = cpoint(pubnonce[0:33]), R<sub>\\*,2</sub>Â = cpoint(pubnonce[33:66])*\n+- LetÂ *Re<sub>\\*</sub>' = R<sub>\\*,1</sub>Â + b &middot; R<sub>\\*,2</sub>*\n+- Let effective nonceÂ *Re<sub>\\*</sub>Â = Re<sub>\\*</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *Re<sub>\\*</sub>Â = -Re<sub>\\*</sub>'*\n+- LetÂ *P = cpoint(pubshare)*; fail if that fails\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*[^lambda-cant-fail]\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *g' = g &middot; gacc*Â (SeeÂ [*Negation of Pubshare When Partially Verifying*](#negation-of-the-pubshare-when-partially-verifying))\n+- Fail ifÂ *s &middot; G â‰  Re<sub>\\*</sub>Â + e &middot; &lambda; &middot; g' &middot; P*\n+- Return success iff no failure occurred before reaching this point.\n+\n+[^lambda-cant-fail]: *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)* cannot fail when called from *PartialSigVerifyInternal* as *PartialSigVerify* picks *my_id* from *id<sub>1..u</sub>*\n+\n+### Partial Signature Aggregation\n+\n+Algorithm *PartialSigAgg(psig<sub>1..u</sub>, id<sub>1..u</sub>, session_ctx)*:\n+\n+- Inputs:\n+  - The numberÂ *u*Â of signatures withÂ *t â‰¤ u â‰¤ n*\n+  - The list of partial signaturesÂ *psig<sub>1..u</sub>*:Â *u*Â 32-byte arrays, each an output of *Sign*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, _, tacc, _, _, _, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- ForÂ *i = 1 .. u*:\n+  - Let *s<sub>i</sub> = scalar_from_bytes_nonzero_checked(psig<sub>i</sub>)*; fail if that fails and blame signer *id<sub>i</sub>* for invalid partial signature.\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *s = s<sub>1</sub>Â + ... + s<sub>u</sub>Â + e &middot; g &middot; tacc*\n+- ReturnÂ *sig =Â xbytes(R) || scalar_to_bytes(s)*\n+\n+### Test Vectors & Reference Code",
      "path": "bip-0445.md",
      "position": 577,
      "original_position": 577,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Links to the code and test vectors do not work.",
      "created_at": "2026-01-14T11:24:47Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690050015",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690050015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 577,
      "original_line": 577,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690063885",
      "pull_request_review_id": 3660028850,
      "id": 2690063885,
      "node_id": "PRRC_kwDOAN28mc6gVx4N",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*\n+- LetÂ *pubshare = cbytes(P)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d'*Â (SeeÂ [*Negation of Secret Share When Signing*](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:\n+\n+- Inputs:\n+  - The partial signatureÂ *psig*: a 32-byte array, serialized scalar\n+  - The list public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte arrays, each an output of *NonceGen*\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+  - The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+  - The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+  - The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+  - The messageÂ *m*: a byte array[^max-msg-len]\n+  - The index *i* of the signer in the list of public nonces where *0 < i â‰¤ u*\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *aggnonce = NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*; fail if that fails\n+- Let *session_ctx = (signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)*\n+- RunÂ *PartialSigVerifyInternal(psig, id<sub>i</sub>, pubnonce<sub>i</sub>, pubshare<sub>i</sub>, session_ctx)*\n+- Return success iff no failure occurred before reaching this point.\n+\n+Internal Algorithm *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*:\n+\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *s = scalar_from_bytes_nonzero_checked(psig)*; fail if that fails\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *R<sub>\\*,1</sub>Â = cpoint(pubnonce[0:33]), R<sub>\\*,2</sub>Â = cpoint(pubnonce[33:66])*\n+- LetÂ *Re<sub>\\*</sub>' = R<sub>\\*,1</sub>Â + b &middot; R<sub>\\*,2</sub>*\n+- Let effective nonceÂ *Re<sub>\\*</sub>Â = Re<sub>\\*</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *Re<sub>\\*</sub>Â = -Re<sub>\\*</sub>'*\n+- LetÂ *P = cpoint(pubshare)*; fail if that fails\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*[^lambda-cant-fail]\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *g' = g &middot; gacc*Â (SeeÂ [*Negation of Pubshare When Partially Verifying*](#negation-of-the-pubshare-when-partially-verifying))\n+- Fail ifÂ *s &middot; G â‰  Re<sub>\\*</sub>Â + e &middot; &lambda; &middot; g' &middot; P*\n+- Return success iff no failure occurred before reaching this point.\n+\n+[^lambda-cant-fail]: *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)* cannot fail when called from *PartialSigVerifyInternal* as *PartialSigVerify* picks *my_id* from *id<sub>1..u</sub>*\n+\n+### Partial Signature Aggregation\n+\n+Algorithm *PartialSigAgg(psig<sub>1..u</sub>, id<sub>1..u</sub>, session_ctx)*:\n+\n+- Inputs:\n+  - The numberÂ *u*Â of signatures withÂ *t â‰¤ u â‰¤ n*\n+  - The list of partial signaturesÂ *psig<sub>1..u</sub>*:Â *u*Â 32-byte arrays, each an output of *Sign*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, _, tacc, _, _, _, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- ForÂ *i = 1 .. u*:\n+  - Let *s<sub>i</sub> = scalar_from_bytes_nonzero_checked(psig<sub>i</sub>)*; fail if that fails and blame signer *id<sub>i</sub>* for invalid partial signature.\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *s = s<sub>1</sub>Â + ... + s<sub>u</sub>Â + e &middot; g &middot; tacc*\n+- ReturnÂ *sig =Â xbytes(R) || scalar_to_bytes(s)*\n+\n+### Test Vectors & Reference Code\n+\n+We provide a naive, highly inefficient, and non-constant timeÂ [pure Python 3 reference implementation of the threshold public key tweaking, nonce generation, partial signing, and partial signature verification algorithms](./reference/reference.py).\n+\n+Standalone JSON test vectors are also available in theÂ [same directory](./reference/vectors/), to facilitate porting the test vectors into other implementations.\n+\n+> [!CAUTION]\n+> The reference implementation is for demonstration purposes only and not to be used in production environments.\n+\n+## Remarks on Security and Correctness\n+\n+### Modifications to Nonce Generation\n+\n+Implementers must avoid modifying the *NonceGen* algorithm without being fully aware of the implications.\n+We provide two modifications to *NonceGen* that are secure when applied correctly and may be useful in special circumstances, summarized in the following table.\n+\n+| | needs secure randomness | needs secure counter | needs to keep state securely | needs aggregate nonce of all other signers (only possible for one signer) |\n+| --- | --- | --- | --- | --- |\n+| **NonceGen** | âœ“ | | âœ“ | |\n+| **CounterNonceGen** | | âœ“ | âœ“ | |\n+| **DeterministicSign** | | | | âœ“ |\n+\n+First, on systems where obtaining uniformly random values is much harder than maintaining a global atomic counter, it can be beneficial to modify *NonceGen*.\n+The resulting algorithm *CounterNonceGen* does not draw *rand'* uniformly at random but instead sets *rand'* to the value of an atomic counter that is incremented whenever it is read.\n+With this modification, the secret share *secshare* of the signer generating the nonce is **not** an optional argument and must be provided to *NonceGen*.\n+The security of the resulting scheme then depends on the requirement that reading the counter must never yield the same counter value in two *NonceGen* invocations with the same *secshare*.\n+\n+Second, if there is a unique signer who generates their nonce last (i.e., after receiving the aggregate nonce from all other signers), it is possible to modify nonce generation for this single signer to not require high-quality randomness.\n+Such a nonce generation algorithm *DeterministicSign* is specified below.\n+Note that the only optional argument is *rand*, which can be omitted if randomness is entirely unavailable.\n+*DeterministicSign* requires the argument *aggothernonce* which should be set to the output of *NonceAgg* run on the *pubnonce* value of **all** other signers (but can be provided by an untrusted party).\n+Hence, using *DeterministicSign* is only possible for the last signer to generate a nonce and makes the signer stateless, similar to the stateless signer described in the [Nonce Generation](#nonce-generation) section.\n+<!-- REVIEW just say n is < 2^32 during intro, than mentioning it everywhere -->\n+\n+#### Deterministic and Stateless Signing for a Single Signer\n+\n+Algorithm *DeterministicSign(secshare, my_id, aggothernonce, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, rand)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - The aggregate public nonce *aggothernonce* (see [above](#modifications-to-nonce-generation)): a 66-byte array, output of *NonceAgg*\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+  - The number *v* of tweaks with *0 â‰¤ v < 2^32*\n+  - The list of tweaks *tweak<sub>1..v</sub>*: *v* 32-byte arrays, each a serialized scalar\n+  - The list of tweak methods *is_xonly_t<sub>1..v</sub>*: *v* booleans\n+  - The message *m*: a byte array[^max-msg-len]\n+  - The auxiliary randomness *rand*: a 32-byte array, serialized scalar (optional argument)\n+- If the optional argument *rand* is present:\n+  - Let *secshare' = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand))*\n+- Else:\n+  - Let *secshare' = secshare*\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- Let *tweaked_tpk = GetXonlyPubkey(tweak_ctx<sub>v</sub>)*\n+- Let *k<sub>i</sub> = scalar_from_bytes_wrapping(hash<sub>FROST/deterministic/nonce</sub>(secshare' || aggothernonce || tweaked_tpk || bytes(8, len(m)) || m || bytes(1, i - 1)))* for *i = 1,2*\n+- Fail if *k<sub>1</sub> = Scalar(0)* or *k<sub>2</sub> = Scalar(0)*\n+- Let *R<sub>\\*,1</sub> = k<sub>1</sub> &middot; G, R<sub>\\*,2</sub> = k<sub>2</sub> &middot; G*\n+- Let *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- Let *d = scalar_from_bytes_nonzero_checked(secshare')*; fail if that fails\n+- Let *my_pubshare = cbytes(d &middot; G)*\n+- Fail if *my_pubshare* is not present in *pubshare<sub>1..u</sub>*\n+- Let *secnonce = scalar_to_bytes(k<sub>1</sub>) || scalar_to_bytes(k<sub>2</sub>)*\n+- Let *aggnonce = NonceAgg((pubnonce, aggothernonce), (my_id, COORDINATOR_ID))*[^coordinator-id-sentinel]; fail if that fails and blame coordinator for invalid *aggothernonce*.\n+- Let *session_ctx = (signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)*\n+- Return (pubnonce, Sign(secnonce, secshare, my_id, session_ctx))\n+\n+[^coordinator-id-sentinel]: *COORDINATOR_ID* is a sentinel value (not an actual participant identifier) used to track the source of *aggothernonce* for error attribution. If *NonceAgg* fails, the coordinator is blamed for providing an invalid *aggothernonce*. In the reference implementation, *COORDINATOR_ID* is represented as `None`.\n+\n+### Tweaking Definition\n+\n+Two modes of tweaking the threshold public key are supported. They correspond to the following algorithms:\n+\n+Algorithm *ApplyPlainTweak(P, t)*:\n+\n+- Inputs:\n+  - *P*: a point\n+  - The tweakÂ *t*: a scalar\n+- ReturnÂ *P + t &middot; G*\n+\n+Algorithm *ApplyXonlyTweak(P, t)*:\n+\n+- Inputs:\n+  - *P*: a point\n+  - The tweakÂ *t*: a scalar\n+- ReturnÂ *with_even_y(P) + t &middot; G*\n+\n+<!-- REVIEW: Should we point to BIP327 for this proof? Unless we use agnostic tweaking -->\n+### Negation of the Secret Share when Signing\n+\n+> [!NOTE]\n+> In the following equations, all scalar arithmetic is understood to be modulo the group order, as specified in the [Notation](#notation) section.\n+\n+During the signing process, the *[Sign](#signing)* algorithm might have to negate the secret share in order to produce a partial signature for an X-only threshold public key, which may be tweaked *v* times (X-only or plain).\n+\n+The following elliptic curve points arise as intermediate steps when creating a signature:\n+\n+- The values *P<sub>i</sub>* (pubshare), *d<sub>i</sub>'* (secret share), and *Q<sub>0</sub>* (threshold public key) are produced by a FROST key generation protocol. We have  \n+  <pre>\n+    P<sub>i</sub> = d<sub>i</sub>'&middot;G\n+    Q<sub>0</sub> = &lambda;<sub>id<sub>1</sub></sub>&middot;P<sub>1</sub>Â + &lambda;<sub>id<sub>2</sub></sub>&middot;P<sub>2</sub>Â + ... + &lambda;<sub>id<sub>u</sub></sub>&middot;P<sub>u</sub>\n+  </pre>  \n+  Here, *&lambda;<sub>id<sub>i</sub></sub>* denotes the interpolating value for the *i*-th signing participant in the [Signers Context](#signers-context).\n+\n+- *Q<sub>i</sub>*Â is the tweaked threshold public key after theÂ *i*-th execution ofÂ *ApplyTweak*Â forÂ *1 â‰¤ i â‰¤ v*. It holds that  \n+  <pre>\n+    Q<sub>i</sub>Â = f(i-1) + t<sub>i</sub>&middot;GÂ forÂ i = 1, ..., vÂ where\n+      f(i-1) := with_even_y(Q<sub>i-1</sub>)Â ifÂ is_xonly_t<sub>i</sub>Â and\n+      f(i-1) := Q<sub>i-1</sub>Â otherwise.\n+  </pre>\n+- *with_even_y(Q*<sub>v</sub>*)*Â is the final result of the threshold public key tweaking operations. It corresponds to the output ofÂ *GetXonlyPubkey*Â applied on the final Tweak Context.\n+\n+The signer's goal is to produce a partial signature corresponding to the final result of threshold pubkey derivation and tweaking, i.e., the X-only public keyÂ *with_even_y(Q<sub>v</sub>)*.\n+\n+For *1 â‰¤ i â‰¤ v*, we denote the value *g* computed in the *i*-th execution of *ApplyTweak* by *g<sub>i-1</sub>*. Therefore, *g<sub>i-1</sub>* equals *Scalar(-1)* if and only if *is_xonly_t<sub>i</sub>* is true and *Q<sub>i-1</sub>* has an odd Y coordinate. In other words, *g<sub>i-1</sub>* indicates whether *Q<sub>i-1</sub>* needed to be negated to apply an X-only tweak:\n+<pre>\n+  f(i-1) = g<sub>i-1</sub>&middot;Q<sub>i-1</sub> for 1 â‰¤ i â‰¤ v\n+</pre>\n+Furthermore, the *Sign* and *PartialSigVerify* algorithms set value *g* depending on whether Q<sub>v</sub> needed to be negated to produce the (X-only) final output. For consistency, this value *g* is referred to as *g<sub>v</sub>* in this section.\n+<pre>\n+  with_even_y(Q<sub>v</sub>) = g<sub>v</sub>&middot;Q<sub>v</sub>\n+</pre>\n+\n+So, the (X-only) final public key is\n+<pre>\n+  with_even_y(Q<sub>v</sub>)\n+    = g<sub>v</sub>&middot;Q<sub>v</sub>\n+    = g<sub>v</sub>&middot;(f(v-1) + t<sub>v</sub>&middot;G)\n+    = g<sub>v</sub>&middot;(g<sub>v-1</sub>&middot;(f(v-2) + t<sub>v-1</sub>&middot;G) + t<sub>v</sub>&middot;G)\n+    = g<sub>v</sub>&middot;g<sub>v-1</sub>&middot;f(v-2) + g<sub>v</sub>&middot;(t<sub>v</sub> + g<sub>v-1</sub>&middot;t<sub>v-1</sub>)&middot;G\n+    = g<sub>v</sub>&middot;g<sub>v-1</sub>&middot;f(v-2) + (sum<sub>i=v-1..v</sub> t<sub>i</sub> &middot; prod<sub>j=i..v</sub> g<sub>j</sub>)&middot;G\n+    = g<sub>v</sub>&middot;g<sub>v-1</sub>&middot; ... &middot;g<sub>1</sub>&middot;f(0) + (sum<sub>i=1..v</sub> t<sub>i</sub> &middot; prod<sub>j=i..v</sub> g<sub>j</sub>)&middot;G\n+    = g<sub>v</sub>&middot; ... &middot;g<sub>0</sub>&middot;Q<sub>0</sub> + g<sub>v</sub>&middot;tacc<sub>v</sub>&middot;G\n+</pre>\n+where tacc<sub>i</sub> is computed by TweakCtxInit and ApplyTweak as follows:\n+<pre>\n+  tacc<sub>0</sub> = 0\n+  tacc<sub>i</sub> = t<sub>i</sub> + g<sub>i-1</sub>&middot;tacc<sub>i-1</sub> for i=1..v\n+</pre>\n+  for which it holds that\n+<pre>\n+  g<sub>v</sub>&middot;tacc<sub>v</sub> = sum<sub>i=1..v</sub> t<sub>i</sub> &middot; prod<sub>j=i..v</sub> g<sub>j</sub>\n+</pre>\n+\n+*TweakCtxInit* and *ApplyTweak* compute\n+<pre>\n+  gacc<sub>0</sub> = 1\n+  gacc<sub>i</sub> = g<sub>i-1</sub> &middot; gacc<sub>i-1</sub> for i=1..v\n+</pre>\n+So we can rewrite above equation for the final public key as\n+<pre>\n+  with_even_y(Q<sub>v</sub>) = g<sub>v</sub> &middot; gacc<sub>v</sub> &middot; Q<sub>0</sub> + g<sub>v</sub> &middot; tacc<sub>v</sub> &middot; G\n+</pre>\n+\n+Then we have\n+<pre>\n+  with_even_y(Q<sub>v</sub>) - g<sub>v</sub>&middot;tacc<sub>v</sub>&middot;G\n+    = g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;Q<sub>0</sub>\n+    = g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;(&lambda;<sub>id<sub>1</sub></sub>&middot;P<sub>1</sub> + ... + &lambda;<sub>id<sub>u</sub></sub>&middot;P<sub>u</sub>)\n+    = g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;(&lambda;<sub>id<sub>1</sub></sub>&middot;d<sub>1</sub>'&middot;G + ... + &lambda;<sub>id<sub>u</sub></sub>&middot;d<sub>u</sub>'&middot;G)\n+    = sum<sub>j=1..u</sub>(g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;&lambda;<sub>id<sub>j</sub></sub>&middot;d<sub>j</sub>')&middot;G\n+</pre>\n+\n+Intuitively, *gacc<sub>i</sub>* tracks accumulated sign flipping and *tacc<sub>i</sub>* tracks the accumulated tweak value after applying the first *i* individual tweaks. Additionally, *g<sub>v</sub>* indicates whether *Q<sub>v</sub>* needed to be negated to produce the final X-only result. Thus, participant *i* multiplies their secret share *d<sub>i</sub>'* with *g<sub>v</sub>&middot;gacc<sub>v</sub>* in the [*Sign*](#signing) algorithm.\n+\n+#### Negation of the Pubshare when Partially Verifying\n+\n+As explained in [Negation Of The Secret Share When Signing](#negation-of-the-secret-share-when-signing) the signer uses a possibly negated secret share\n+<pre>\n+  d = g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;d'\n+</pre>\n+when producing a partial signature to ensure that the aggregate signature will correspond to a threshold public key with even Y coordinate.\n+\n+The [*PartialSigVerifyInternal*](#partial-signature-verification) algorithm is supposed to check\n+<pre>\n+  s&middot;G = Re<sub>*</sub> + e&middot;&lambda;&middot;d&middot;G\n+</pre>\n+\n+The verifier doesn't have access to *d &middot; G* but can construct it using the participant *pubshare* as follows:\n+<pre>\n+d&middot;G\n+  = g<sub>v</sub> &middot; gacc<sub>v</sub> &middot; d' &middot; G\n+  = g<sub>v</sub> &middot; gacc<sub>v</sub> &middot; cpoint(pubshare)\n+</pre>\n+Note that the threshold public key and list of tweaks are inputs to partial signature verification, so the verifier can also construct *g<sub>v</sub>* and *gacc<sub>v</sub>*.\n+\n+### Dealing with Infinity in Nonce Aggregation\n+\n+If the coordinator provides *aggnonce = bytes(33,0) || bytes(33,0)*, either the coordinator is dishonest or there is at least one dishonest signer (except with negligible probability).\n+If signing aborted in this case, it would be impossible to determine who is dishonest.\n+Therefore, signing continues so that the culprit is revealed when collecting and verifying partial signatures.\n+\n+However, the final nonce *R* of a BIP340 Schnorr signature cannot be the point at infinity.\n+If we would nonetheless allow the final nonce to be the point at infinity, then the scheme would lose the following property:\n+if *PartialSigVerify* succeeds for all partial signatures, then *PartialSigAgg* will return a valid Schnorr signature.\n+Since this is a valuable feature, we modify [FROST3 signing][roast] to avoid producing an invalid Schnorr signature while still allowing detection of the dishonest signer: In *GetSessionValues*, if the final nonce *R* would be the point at infinity, set it to the generator instead (an arbitrary choice).",
      "path": "bip-0445.md",
      "position": 774,
      "original_position": 774,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It might be better to also mention ROAST in the **Motivation** section when discussing FROST3.",
      "created_at": "2026-01-14T11:29:26Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690063885",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690063885"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 774,
      "original_line": 774,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690144915",
      "pull_request_review_id": 3660028850,
      "id": 2690144915,
      "node_id": "PRRC_kwDOAN28mc6gWFqT",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 80,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The _Signers Context_ link is formatted in italics, deviating from the style in the rest of the specification. To maintain a consistent style, italics formatting should be removed from links that do not represent specific functions.\r\nSimilar issues appear in other sections:\r\n**Key Material and Setup**: _Signers Context_ (line:80)\r\n**General Signing Flow**: _Signers Context_, _Tweak Context_ (line:102)\r\n**Signing**: See _Negation of Secret Share When Signing_ (line:515)\r\n**Partial Signature Verification**: See _Negation of Pubshare When Partially Verifying_ (line:555)",
      "created_at": "2026-01-14T11:55:36Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690144915",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690144915"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690155491",
      "pull_request_review_id": 3660028850,
      "id": 2690155491,
      "node_id": "PRRC_kwDOAN28mc6gWIPj",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 66,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Minor typo: negates â†’ negate",
      "created_at": "2026-01-14T11:59:26Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690155491",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690155491"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690157273",
      "pull_request_review_id": 3660028850,
      "id": 2690157273,
      "node_id": "PRRC_kwDOAN28mc6gWIrZ",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 63,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Minor typo: implementations's â†’ implementation's",
      "created_at": "2026-01-14T12:00:10Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690157273",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690157273"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2702695740",
      "pull_request_review_id": 3675747861,
      "id": 2702695740,
      "node_id": "PRRC_kwDOAN28mc6hF908",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*",
      "path": "bip-0445.md",
      "position": 427,
      "original_position": 426,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can you explain why `i=1,2`? This is unclear to me. Why not `i=1,2,3,...,n`? I don't understand why we stop at `2`. ",
      "created_at": "2026-01-18T20:18:30Z",
      "updated_at": "2026-01-18T20:19:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2702695740",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2702695740"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 427,
      "original_line": 426,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2702707516",
      "pull_request_review_id": 3675756079,
      "id": 2702707516,
      "node_id": "PRRC_kwDOAN28mc6hGAs8",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*",
      "path": "bip-0445.md",
      "position": 427,
      "original_position": 426,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2702695740,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Nevermind this is because you need a public and secret nonce feel free to resolve ðŸ˜¬ ",
      "created_at": "2026-01-18T20:37:29Z",
      "updated_at": "2026-01-18T20:37:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2702707516",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2702707516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 427,
      "original_line": 426,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2706071004",
      "pull_request_review_id": 3679618675,
      "id": 2706071004,
      "node_id": "PRRC_kwDOAN28mc6hS13c",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:",
      "path": "bip-0445.md",
      "position": 421,
      "original_position": 420,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "How would you suggest handling this case in C? \r\n\r\nWe have a message `m` that equal to the empty bytestring? This is tested in the test vectors accompying this file [here](https://github.com/bitcoin/bips/pull/2070/files#diff-8e1aea52a17a71e665c111d9431eaa41c23f481545f240ae26e1b3675a1611c4R14).\r\n\r\nThe python implmentation allows us to represent 2 different states that are (perhaps?) semantically mean the same thing is my understanding. Here are the 2 cases\r\n\r\n1. `m` is not present (encoded as `00`) with the prefix\r\n2. `m` is present, but its the empty bytestring (encoded as `0100`) with the prefix.\r\n\r\nThis can be represented in the type system of higher level languages like C++, Python, Rust, Scala etc.\r\n\r\nFrom looking at the [API on zkp](https://github.com/BlockstreamResearch/secp256k1-zkp/pull/278/files#diff-80b51497bd08deb468dbfb0c80429ace7109ea19b2e5e58e5aa7060e7517b3d0R302), it seems like this wouldn't be possible to represent?",
      "created_at": "2026-01-19T21:07:06Z",
      "updated_at": "2026-01-19T21:07:06Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2706071004",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2706071004"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 421,
      "original_line": 420,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2706319665",
      "pull_request_review_id": 3679866957,
      "id": 2706319665,
      "node_id": "PRRC_kwDOAN28mc6hTykx",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:",
      "path": "bip-0445.md",
      "position": 421,
      "original_position": 420,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2706071004,
      "user": {
        "login": "vitrixLab",
        "id": 144500546,
        "node_id": "U_kgDOCJznQg",
        "avatar_url": "https://avatars.githubusercontent.com/u/144500546?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vitrixLab",
        "html_url": "https://github.com/vitrixLab",
        "followers_url": "https://api.github.com/users/vitrixLab/followers",
        "following_url": "https://api.github.com/users/vitrixLab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vitrixLab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vitrixLab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vitrixLab/subscriptions",
        "organizations_url": "https://api.github.com/users/vitrixLab/orgs",
        "repos_url": "https://api.github.com/users/vitrixLab/repos",
        "events_url": "https://api.github.com/users/vitrixLab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vitrixLab/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In **`C`** this must be modeled explicitly as an optional bytes type, otherwise we cannot distinguish\r\nâ€œm not presentâ€ (00) from â€œ`m present but empty`â€ `(0100).`\r\n\r\nI recommend representing this as `{ uint8_t *ptr; size_t len; bool is_present; }` and encoding based on `is_present`.\r\n\r\nCollapsing these cases would break the test vectors and change the hash domain.\r\n\r\n#sc",
      "created_at": "2026-01-19T23:34:01Z",
      "updated_at": "2026-01-19T23:36:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2706319665",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2706319665"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 421,
      "original_line": 420,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2710936061",
      "pull_request_review_id": 3685315607,
      "id": 2710936061,
      "node_id": "PRRC_kwDOAN28mc6hlZn9",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*",
      "path": "bip-0445.md",
      "position": 427,
      "original_position": 426,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2702695740,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "According to the protocol, each signer generates two pairs of nonces, as specified by $\\text{Preround(pk)}$ in [Figure 4 of the paper](https://eprint.iacr.org/2023/899.pdf). These secret nonces are later combined during signing. We could technically generate more than two nonces ([section 2.2 of Musig2 paper](https://eprint.iacr.org/2020/1261.pdf)), but that might be an overkill.",
      "created_at": "2026-01-21T04:37:55Z",
      "updated_at": "2026-01-21T04:37:55Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2710936061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2710936061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 427,
      "original_line": 426,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2711035567",
      "pull_request_review_id": 3685416929,
      "id": 2711035567,
      "node_id": "PRRC_kwDOAN28mc6hlx6v",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:",
      "path": "bip-0445.md",
      "position": 421,
      "original_position": 420,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2706071004,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "We distinguish between a zeroed byte array and an empty byte string. Thus, `m` being absent (*empty_bytestring*) is different from `m` being equal to zero bytes (of any length), and we want to generate distinct nonces for these cases.\r\n\r\nYes, the current the [zkp API doesn't add the message prefix correctly](https://github.com/BlockstreamResearch/secp256k1-zkp/pull/278/changes#r1716621392) which needs to be fixed.\r\n\r\nI agree with @vitrixLab, we can model this in C with an `is_present` variable, [Musig2 does exactly this](https://github.com/bitcoin-core/secp256k1/blob/4721e077b4ac9a9ab80db3fd9a05d6dda207f5c1/src/modules/musig/session_impl.h#L339). \r\n\r\n```\r\nunsigned char msg_present;\r\nmsg_present = msg32 != NULL;\r\nsecp256k1_sha256_write(&sha, &msg_present, 1);\r\nif (msg_present) {\r\n    secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\r\n}\r\n```    ",
      "created_at": "2026-01-21T05:35:42Z",
      "updated_at": "2026-01-21T05:36:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2711035567",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2711035567"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 421,
      "original_line": 420,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2713530350",
      "pull_request_review_id": 3688404503,
      "id": 2713530350,
      "node_id": "PRRC_kwDOAN28mc6hvS_u",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 8,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2673745481,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sorry, it happened more quickly than I anticipated! :)",
      "created_at": "2026-01-21T17:07:32Z",
      "updated_at": "2026-01-21T17:07:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2713530350",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2713530350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716245465",
      "pull_request_review_id": 3691689081,
      "id": 2716245465,
      "node_id": "PRRC_kwDOAN28mc6h5p3Z",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*",
      "path": "bip-0445.md",
      "position": 315,
      "original_position": 316,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The same function is also invoked in the `DeriveInterpolatingValue()` algorithm, which is called through the following chain:\r\n    `ValidateSignersCtx()->DeriveThreshPubkey()->DeriveInterpolatingValue()`.\r\nIs there a compelling reason to perform this check at the top level, or could the ID duplication check be retained solely at a lower level within `DeriveInterpolatingValue()`?\r\n\r\nIn addition, the `ValidateSignersCtx()` algorithm checks the condition `t > n`. However, as stated in the description, the valid range is `1 <= t <= n`. Therefore, it would be clearer to replace the condition â€œFail if `t > n`â€ with â€œFail if not `1 <= t <= n`â€.",
      "created_at": "2026-01-22T10:20:35Z",
      "updated_at": "2026-01-22T16:06:28Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2716245465",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716245465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 315,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716254648",
      "pull_request_review_id": 3691689081,
      "id": 2716254648,
      "node_id": "PRRC_kwDOAN28mc6h5sG4",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 435,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "...which comprises the value triple...\r\nMinor typo: triple â†’ pair",
      "created_at": "2026-01-22T10:23:03Z",
      "updated_at": "2026-01-22T11:20:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2716254648",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716254648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 435,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716310520",
      "pull_request_review_id": 3691689081,
      "id": 2716310520,
      "node_id": "PRRC_kwDOAN28mc6h55v4",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*",
      "path": "bip-0445.md",
      "position": 428,
      "original_position": 427,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "While reading the implementation, I noticed that it includes a check ensuring that `k_1 != k_2`. At first glance, omitting this check does not appear to introduce any vulnerabilities, and we have verified this. However, I would appreciate hearing your opinion on this point.",
      "created_at": "2026-01-22T10:38:30Z",
      "updated_at": "2026-01-22T11:20:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2716310520",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716310520"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 428,
      "original_line": 427,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716459467",
      "pull_request_review_id": 3691689081,
      "id": 2716459467,
      "node_id": "PRRC_kwDOAN28mc6h6eHL",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*",
      "path": "bip-0445.md",
      "position": 330,
      "original_position": 331,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In fact, the specification very subtly avoids an explicit global shift of all identifiers, simplifying the description to the use of `id+1` only in the numerator. However, will not this create possible misunderstandings in the future? Perhaps it would make sense to mention this earlier in the specification? I would be glad to hear your thoughts!",
      "created_at": "2026-01-22T11:13:40Z",
      "updated_at": "2026-01-22T11:20:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2716459467",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716459467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 330,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2717872165",
      "pull_request_review_id": 3693637663,
      "id": 2717872165,
      "node_id": "PRRC_kwDOAN28mc6h_3Al",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 99,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2689921315,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah yes, thank you! I left this one in by mistake.",
      "created_at": "2026-01-22T17:20:49Z",
      "updated_at": "2026-01-22T17:20:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2717872165",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2717872165"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2717912357",
      "pull_request_review_id": 3693689480,
      "id": 2717912357,
      "node_id": "PRRC_kwDOAN28mc6iAA0l",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*",
      "path": "bip-0445.md",
      "position": 288,
      "original_position": 289,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2689949680,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I don't understand what you're suggesting. Should I use `mod n` explicitly in the equations instead of adding the note? Or are you saying to remove the repeated footnote? \r\n\r\nI've removed the duplicate footnote for now.",
      "created_at": "2026-01-22T17:30:08Z",
      "updated_at": "2026-01-22T17:30:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2717912357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2717912357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 288,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2718755558",
      "pull_request_review_id": 3694738936,
      "id": 2718755558,
      "node_id": "PRRC_kwDOAN28mc6iDOrm",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*",
      "path": "bip-0445.md",
      "position": 288,
      "original_position": 289,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2689949680,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I apologize for the confusion - I overlooked that `n` is already used as one of the threshold scheme parameters.\r\nThis was our alternative proposal, use `mod order` wherever scalar arithmetic is used, as we think this is an area where mistakes can easily occur and could be critical. For example, MuSig2 explicitly uses `mod order`, which helps eliminate potential misunderstandings in the future. \r\nIf using the term `order` is undesirable, an alternative would be to denote it by `q`.",
      "created_at": "2026-01-22T21:46:37Z",
      "updated_at": "2026-01-22T21:46:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2718755558",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2718755558"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 288,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2718917375",
      "pull_request_review_id": 3694925537,
      "id": 2718917375,
      "node_id": "PRRC_kwDOAN28mc6iD2L_",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*",
      "path": "bip-0445.md",
      "position": 298,
      "original_position": 299,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "How is the signing context supposed to be derived for [`sign_verify_vectors.json`](https://github.com/bitcoin/bips/blob/ec46a20323840b1a6aba83bc2d18b34dd0811245/bip-frost-signing/python/vectors/sign_verify_vectors.json). The test file has an `n` and a `t` encoded, however no `u`. \r\n\r\nIs `u` implied by the number of indices provided in `id_indices`, `pubshare_indices` etc? \r\n\r\nI assume an invariant that could be added to this is that `pubshares` and `participant_ids` length is equal to `u` ? \r\n\r\nAlso why is `u` not available in the [SignersContext](https://github.com/siv2r/bips/blob/ec46a20323840b1a6aba83bc2d18b34dd0811245/bip-frost-signing/python/frost_ref/signing.py#L75) in the python implementation? L304 in this BIP seems to infer that it can be pulled out of the `SignersContext`\r\n\r\n>Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\"",
      "created_at": "2026-01-22T22:50:52Z",
      "updated_at": "2026-01-23T00:52:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2718917375",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2718917375"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 299,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724275898",
      "pull_request_review_id": 3701858306,
      "id": 2724275898,
      "node_id": "PRRC_kwDOAN28mc6iYSa6",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*",
      "path": "bip-0445.md",
      "position": 298,
      "original_position": 299,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2718917375,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yes, you're correct. The `u` is implied by the length of `ids` and `pubshares` in `SignersContext`, `u = len(ids) = len(pubshares)`. Also, `t <= u <= n`. The `validate_signers_ctx` function asserts this relationship. In python, we can infer `u` to be the length of `ids` or `pubshares`. I've explicitly added `u` in the specification for clarity.",
      "created_at": "2026-01-24T15:44:27Z",
      "updated_at": "2026-01-24T17:36:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2724275898",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724275898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 299,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724357386",
      "pull_request_review_id": 3702021123,
      "id": 2724357386,
      "node_id": "PRRC_kwDOAN28mc6iYmUK",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*",
      "path": "bip-0445.md",
      "position": 330,
      "original_position": 331,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716459467,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I agree the `DeriveInterpolatingValue` formula isn't conventional, and someone looking at it directly might think it's incorrect without the context that ids are in the range `0..n-1`. \r\n\r\nI initially considered having the caller increment the ids, but that would require modifying many callers: `DeriveThresPubkey`, `Sign`, and `PartialSigVerifyInternal`. I think adding a footnote on the `id+1` line is the better option. What do you think?",
      "created_at": "2026-01-24T16:52:12Z",
      "updated_at": "2026-01-24T16:52:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2724357386",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724357386"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 330,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724371511",
      "pull_request_review_id": 3702091065,
      "id": 2724371511,
      "node_id": "PRRC_kwDOAN28mc6iYpw3",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*",
      "path": "bip-0445.md",
      "position": 428,
      "original_position": 427,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716310520,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Which function are you referring to? I don't see a `k_1 != k_2` check in the `nonce_gen_internal` or `deterministic_sign` functions. \r\n\r\nThis is an interesting question though. I never considered adding this check, primarily because BIP327's reference implementation doesn't have it either.",
      "created_at": "2026-01-24T17:04:33Z",
      "updated_at": "2026-01-24T17:04:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2724371511",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724371511"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 428,
      "original_line": 427,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724396670",
      "pull_request_review_id": 3702177410,
      "id": 2724396670,
      "node_id": "PRRC_kwDOAN28mc6iYv5-",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*",
      "path": "bip-0445.md",
      "position": 315,
      "original_position": 316,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716245465,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`ValidateSignersCtx()` checks the sanity of `u` signing participants (represented by `ids` and `pubshares`). So it only made sense to fail for all faults, like `ids` being out of range or containing duplicates. So, it's better to have it in the higher level?\r\n\r\nI added `has_duplicates` again inside `DeriveInterpolatingValue()` because it has many other callers, just to be safe. Now that I look at it closely, all these calls get the `ids` & `pubshares` list after running `ValidateSignersCtx()` (through `GetSessionValues`), so we could technically remove the `has_duplicates` check from `DeriveInterpolatingValue()`.\r\n\r\n> Therefore, it would be clearer to replace the condition â€œFail if t > nâ€ with â€œFail if not 1 <= t <= nâ€.\r\n\r\nI agree.",
      "created_at": "2026-01-24T17:22:12Z",
      "updated_at": "2026-01-24T17:22:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2724396670",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724396670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 315,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724416314",
      "pull_request_review_id": 3702222824,
      "id": 2724416314,
      "node_id": "PRRC_kwDOAN28mc6iY0s6",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*\n+- LetÂ *pubshare = cbytes(P)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d'*Â (SeeÂ [*Negation of Secret Share When Signing*](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:",
      "path": "bip-0445.md",
      "position": 526,
      "original_position": 526,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2690026960,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`v` isn't explicitly taken as input. It's mentioned in the input argument description to provide better context for the length of the `tweaks` and `is_xonly_t` lists.",
      "created_at": "2026-01-24T17:32:43Z",
      "updated_at": "2026-01-24T17:32:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2724416314",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724416314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 526,
      "original_line": 526,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724441307",
      "pull_request_review_id": 3702284519,
      "id": 2724441307,
      "node_id": "PRRC_kwDOAN28mc6iY6zb",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*",
      "path": "bip-0445.md",
      "position": 288,
      "original_position": 289,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2689949680,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Great point! I agree that explicitly mentioning it helps avoid mistakes. I initially removed it because, like you said, `n` was used in `t`-of-`n`, and `mod order` seemed a bit weird. I also considered `q`, but we use `Q` almost everywhere to represent the threshold public key, so I decided to remove the `mod <x>` altogether.\r\n\r\nI think it might be okay to use `q` since it's lowercase and shouldn't be too confusing with the uppercase pubkey point `Q`. Maybe `mod ord` is better? I'll update this.",
      "created_at": "2026-01-24T17:50:29Z",
      "updated_at": "2026-01-24T17:50:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2724441307",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2724441307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 288,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2725187143",
      "pull_request_review_id": 3703535110,
      "id": 2725187143,
      "node_id": "PRRC_kwDOAN28mc6ibw5H",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*",
      "path": "bip-0445.md",
      "position": 288,
      "original_position": 289,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2689949680,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I've used `mod ord` for now",
      "created_at": "2026-01-25T09:29:45Z",
      "updated_at": "2026-01-25T09:29:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2725187143",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2725187143"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 288,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2725192145",
      "pull_request_review_id": 3703539672,
      "id": 2725192145,
      "node_id": "PRRC_kwDOAN28mc6ibyHR",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*",
      "path": "bip-0445.md",
      "position": 330,
      "original_position": 331,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716459467,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I've added a footnote. Do let me know your thoughts on it.",
      "created_at": "2026-01-25T09:31:13Z",
      "updated_at": "2026-01-25T09:31:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2725192145",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2725192145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 330,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2726940801",
      "pull_request_review_id": 3705290985,
      "id": 2726940801,
      "node_id": "PRRC_kwDOAN28mc6iidCB",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*",
      "path": "bip-0445.md",
      "position": 428,
      "original_position": 427,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716310520,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Which function are you referring to? I don't see a `k_1 != k_2` check in the `nonce_gen_internal` or `deterministic_sign` functions.\r\n\r\nI apologize for not mentioning which implementation I was referring to. I meant the _secp256k1-zkp FROST module_, where the `secp256k1_frost_nonce_gen()` function performs this check. However, I think this verification is redundant, as I have not found any paper or specification that requires it. At first glance, it may seem that manipulation with Wagner attacks could apply, but I do not see any concrete attack vectors.\r\n",
      "created_at": "2026-01-26T09:45:50Z",
      "updated_at": "2026-01-26T09:45:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2726940801",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2726940801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 428,
      "original_line": 427,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2726950116",
      "pull_request_review_id": 3705301600,
      "id": 2726950116,
      "node_id": "PRRC_kwDOAN28mc6iifTk",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*",
      "path": "bip-0445.md",
      "position": 330,
      "original_position": 331,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716459467,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> I've added a footnote. Do let me know your thoughts on it.\r\n\r\nI think this is the best solution.",
      "created_at": "2026-01-26T09:49:04Z",
      "updated_at": "2026-01-26T09:49:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2726950116",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2726950116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 330,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2727132801",
      "pull_request_review_id": 3705502160,
      "id": 2727132801,
      "node_id": "PRRC_kwDOAN28mc6ijL6B",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*",
      "path": "bip-0445.md",
      "position": 315,
      "original_position": 316,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716245465,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": ">  all these calls get the `ids` & `pubshares` list after running `ValidateSignersCtx()` (through `GetSessionValues`), so we could technically remove the `has_duplicates` check from `DeriveInterpolatingValue()`.\r\n\r\nYes, I agree with you, since we call `GetSessionValues()` at the beginning of both functions that independently invoke `DeriveInterpolatingValue()`. Thus, we can remove the check from the `DeriveInterpolatingValue()` and keep it only in `ValidateSignersCtx()`.",
      "created_at": "2026-01-26T10:44:47Z",
      "updated_at": "2026-01-26T10:44:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2727132801",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2727132801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 315,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2732616574",
      "pull_request_review_id": 3711925165,
      "id": 2732616574,
      "node_id": "PRRC_kwDOAN28mc6i4Gt-",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*",
      "path": "bip-0445.md",
      "position": 428,
      "original_position": 427,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716310520,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Oh, I was not aware of this. Thank you! I checked the Olaf paper as well, and it didn't have this requirement. I haven't thought about this from security proof perspective. Will keep this open till then :)",
      "created_at": "2026-01-27T15:38:38Z",
      "updated_at": "2026-01-27T15:38:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2732616574",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2732616574"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 428,
      "original_line": 427,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2732618219",
      "pull_request_review_id": 3711927137,
      "id": 2732618219,
      "node_id": "PRRC_kwDOAN28mc6i4HHr",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*",
      "path": "bip-0445.md",
      "position": 315,
      "original_position": 316,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716245465,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Alright. I'll update this.",
      "created_at": "2026-01-27T15:39:03Z",
      "updated_at": "2026-01-27T15:39:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2732618219",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2732618219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 315,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2733994163",
      "pull_request_review_id": 3713655608,
      "id": 2733994163,
      "node_id": "PRRC_kwDOAN28mc6i9XCz",
      "diff_hunk": "@@ -0,0 +1,821 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 11,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Since BIPâ€¯3 activated now:\r\n\r\n```suggestion\r\nBIP: ?\r\nTitle: FROST Signing Protocol for BIP340 Signatures\r\nAuthors: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\r\nStatus: Draft\r\nType: Specification\r\nAssigned: ?\r\nLicense: CC0-1.0 or MIT\r\nDiscussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\r\nRequires: 32, 340, 341\r\n```",
      "created_at": "2026-01-27T21:59:43Z",
      "updated_at": "2026-01-27T22:20:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2733994163",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2733994163"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 2,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2734016692",
      "pull_request_review_id": 3713655608,
      "id": 2734016692,
      "node_id": "PRRC_kwDOAN28mc6i9ci0",
      "diff_hunk": "@@ -0,0 +1,821 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 9,
      "commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "original_commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The header value you used indicates that the BIP (including all auxiliary files) is made available under the terms of both CC0 1.0 Universal as well as the MIT License, and anyone may modify and redistribute it provided they comply with the terms of _either_ license. However, this contradicts the text in the Copyright section which states that the proposal is licensed under CC0-1.0 and the code is licensed under MIT. To express what the Copyright section indicates, you would please only put CC0-1.0 here, and include either a license header in each file, or a COPYING/LICENSE file in the folder with the auxiliary files to express that different licensing agrees to the code files. You can find more information here: https://github.com/bitcoin/bips/blob/master/bip-0003.md#bip-licensing\r\n\r\n```suggestion\r\nLicense: CC0-1.0\r\n```",
      "created_at": "2026-01-27T22:07:43Z",
      "updated_at": "2026-01-27T22:20:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2734016692",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2734016692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 9,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737257379",
      "pull_request_review_id": 3717447807,
      "id": 2737257379,
      "node_id": "PRRC_kwDOAN28mc6jJzuj",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*",
      "path": "bip-0445.md",
      "position": 315,
      "original_position": 316,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2716245465,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'd like to keep this redundant check in `DeriveInterpolatingValue()` for now. Just looked at [RFC 9591](https://datatracker.ietf.org/doc/html/rfc9591#section-4.2) which defines their `derive_interpolating_value` function as:\r\n\r\n> def derive_interpolating_value(L, x_i):\r\n>   if x_i not in L:\r\n>     raise \"invalid parameters\"\r\n>   for x_j in L:\r\n>     if count(x_j, L) > 1:\r\n>       raise \"invalid parameters\"\r\n> ...\r\n> ...\r\n\r\nWe can remove this `has_duplicates` check later, if we really need to.",
      "created_at": "2026-01-28T15:42:04Z",
      "updated_at": "2026-01-28T15:42:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737257379",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737257379"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 315,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737339515",
      "pull_request_review_id": 3717552046,
      "id": 2737339515,
      "node_id": "PRRC_kwDOAN28mc6jKHx7",
      "diff_hunk": "@@ -0,0 +1,821 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 11,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "in_reply_to_id": 2733994163,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 6ea53f2",
      "created_at": "2026-01-28T15:59:10Z",
      "updated_at": "2026-01-28T15:59:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737339515",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737339515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 2,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737371263",
      "pull_request_review_id": 3717593535,
      "id": 2737371263,
      "node_id": "PRRC_kwDOAN28mc6jKPh_",
      "diff_hunk": "@@ -0,0 +1,821 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 9,
      "commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "original_commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "in_reply_to_id": 2734016692,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thank you for the detailed explanation. I'm usually confused when it comes to license files, so I took some time to read about them now. I've added a MIT COPYING file in the `bips/bip-frost-signing/` directory. That should fix this issue.",
      "created_at": "2026-01-28T16:06:37Z",
      "updated_at": "2026-01-28T16:06:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737371263",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737371263"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 9,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737712711",
      "pull_request_review_id": 3718016896,
      "id": 2737712711,
      "node_id": "PRRC_kwDOAN28mc6jLi5H",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 25,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> \"Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does?\"\n\nSounds reasonable to add that. If I'm not missing anything, the [two paragraphs in BIP327](https://github.com/bitcoin/bips/blob/3177af3bbf84d2d7e19ef5d7d707807f961af029/bip-0327.mediawiki?plain=1#L38-L41) would fully apply to FROST as well (after minor adaptions, s/MuSig2/FROST/ and s/n-of-n/t-of-n/).",
      "created_at": "2026-01-28T17:24:30Z",
      "updated_at": "2026-01-28T17:35:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737712711",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737712711"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737718506",
      "pull_request_review_id": 3718016896,
      "id": 2737718506,
      "node_id": "PRRC_kwDOAN28mc6jLkTq",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 111,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: should \"MuSig2\" replaced with \"FROST\" here?",
      "created_at": "2026-01-28T17:25:40Z",
      "updated_at": "2026-01-28T17:35:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737718506",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737718506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 110,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737721994",
      "pull_request_review_id": 3718016896,
      "id": 2737721994,
      "node_id": "PRRC_kwDOAN28mc6jLlKK",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 244,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: the constant is also available as `Scalar.SIZE` in secp256k1lab",
      "created_at": "2026-01-28T17:26:28Z",
      "updated_at": "2026-01-28T17:35:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737721994",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737721994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737727982",
      "pull_request_review_id": 3718016896,
      "id": 2737727982,
      "node_id": "PRRC_kwDOAN28mc6jLmnu",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 247,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n| *is_infinity(P)* | *P.infinity* | Returns whether *P* is the point at infinity |\n```\n(since `infinity` is a property rather than a method within `GE`)",
      "created_at": "2026-01-28T17:27:51Z",
      "updated_at": "2026-01-28T17:35:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737727982",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737727982"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737739678",
      "pull_request_review_id": 3718016896,
      "id": 2737739678,
      "node_id": "PRRC_kwDOAN28mc6jLpee",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *ord* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *ord* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *ord* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if not *1 â‰¤ t â‰¤ n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)[^lagrange-shift] &ensp;(mod ord)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id) &ensp;(mod ord)*\n+- *&lambda; = num &middot; deno<sup>-1</sup> &ensp;(mod ord)*\n+- Return *&lambda;*\n+\n+[^lagrange-shift]: The standard Lagrange interpolation coefficient uses the formula *id<sub>i</sub> / (id<sub>i</sub> - my_id)* for each term in the product, where ids are in the range *1..n*. However, since participant identifiers in this protocol are zero-indexed (range *0..n-1*), we shift them by adding 1. This transforms each term to *(id<sub>i</sub>+1) / (id<sub>i</sub> - my_id)*.\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 351,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "pedantic nit: could swap these two lines, so the order matches the one of unpacking `tweak_ctx` (and the order of `TweakCtxInit` return values) below",
      "created_at": "2026-01-28T17:30:38Z",
      "updated_at": "2026-01-28T17:35:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737739678",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737739678"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 350,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737745081",
      "pull_request_review_id": 3718016896,
      "id": 2737745081,
      "node_id": "PRRC_kwDOAN28mc6jLqy5",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *ord* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *ord* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *ord* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if not *1 â‰¤ t â‰¤ n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)[^lagrange-shift] &ensp;(mod ord)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id) &ensp;(mod ord)*\n+- *&lambda; = num &middot; deno<sup>-1</sup> &ensp;(mod ord)*\n+- Return *&lambda;*\n+\n+[^lagrange-shift]: The standard Lagrange interpolation coefficient uses the formula *id<sub>i</sub> / (id<sub>i</sub> - my_id)* for each term in the product, where ids are in the range *1..n*. However, since participant identifiers in this protocol are zero-indexed (range *0..n-1*), we shift them by adding 1. This transforms each term to *(id<sub>i</sub>+1) / (id<sub>i</sub> - my_id)*.\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc &ensp;(mod ord)*\n+- LetÂ *tacc' = t + g &middot; tacc &ensp;(mod ord)*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 429,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: could use `scalar_to_bytes` here instead",
      "created_at": "2026-01-28T17:31:54Z",
      "updated_at": "2026-01-28T17:35:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737745081",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737745081"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737749501",
      "pull_request_review_id": 3718016896,
      "id": 2737749501,
      "node_id": "PRRC_kwDOAN28mc6jLr39",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *ord* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *ord* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *ord* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if not *1 â‰¤ t â‰¤ n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)[^lagrange-shift] &ensp;(mod ord)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id) &ensp;(mod ord)*\n+- *&lambda; = num &middot; deno<sup>-1</sup> &ensp;(mod ord)*\n+- Return *&lambda;*\n+\n+[^lagrange-shift]: The standard Lagrange interpolation coefficient uses the formula *id<sub>i</sub> / (id<sub>i</sub> - my_id)* for each term in the product, where ids are in the range *1..n*. However, since participant identifiers in this protocol are zero-indexed (range *0..n-1*), we shift them by adding 1. This transforms each term to *(id<sub>i</sub>+1) / (id<sub>i</sub> - my_id)*.\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc &ensp;(mod ord)*\n+- LetÂ *tacc' = t + g &middot; tacc &ensp;(mod ord)*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value pair *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 445,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "pedantic nit, for consistency with other functions:\n```suggestion\n  - The list of participant identifiers *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* <= *n-1*\n```",
      "created_at": "2026-01-28T17:33:06Z",
      "updated_at": "2026-01-28T17:35:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737749501",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737749501"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 445,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737751388",
      "pull_request_review_id": 3718016896,
      "id": 2737751388,
      "node_id": "PRRC_kwDOAN28mc6jLsVc",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *ord* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *ord* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *ord* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if not *1 â‰¤ t â‰¤ n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)[^lagrange-shift] &ensp;(mod ord)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id) &ensp;(mod ord)*\n+- *&lambda; = num &middot; deno<sup>-1</sup> &ensp;(mod ord)*\n+- Return *&lambda;*\n+\n+[^lagrange-shift]: The standard Lagrange interpolation coefficient uses the formula *id<sub>i</sub> / (id<sub>i</sub> - my_id)* for each term in the product, where ids are in the range *1..n*. However, since participant identifiers in this protocol are zero-indexed (range *0..n-1*), we shift them by adding 1. This transforms each term to *(id<sub>i</sub>+1) / (id<sub>i</sub> - my_id)*.\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc &ensp;(mod ord)*\n+- LetÂ *tacc' = t + g &middot; tacc &ensp;(mod ord)*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value pair *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)\\*33:j\\*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *pubshare = cbytes(d' &middot; G)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d' &ensp;(mod ord)*Â (SeeÂ [Negation of Secret Share When Signing](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d &ensp;(mod ord)*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:\n+\n+- Inputs:\n+  - The partial signatureÂ *psig*: a 32-byte array, serialized scalar\n+  - The list public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte arrays, each an output of *NonceGen*",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 528,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n  - The list of public nonces *pubnonce<sub>1..u</sub>*: *u* 66-byte arrays, each an output of *NonceGen*\n```",
      "created_at": "2026-01-28T17:33:40Z",
      "updated_at": "2026-01-28T17:35:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2737751388",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2737751388"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 528,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2738025924",
      "pull_request_review_id": 3718423913,
      "id": 2738025924,
      "node_id": "PRRC_kwDOAN28mc6jMvXE",
      "diff_hunk": "@@ -0,0 +1,821 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 9,
      "commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "original_commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "in_reply_to_id": 2734016692,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Youâ€™re welcome, thanks for the quick turnaround.",
      "created_at": "2026-01-28T18:46:12Z",
      "updated_at": "2026-01-28T18:46:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2738025924",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2738025924"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 9,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2738288392",
      "pull_request_review_id": 3718749658,
      "id": 2738288392,
      "node_id": "PRRC_kwDOAN28mc6jNvcI",
      "diff_hunk": "@@ -0,0 +1,509 @@\n+{\n+    \"n\": 3,\n+    \"t\": 2,\n+    \"threshold_pubkey\": \"03B02645D79ABFC494338139410F9D7F0A72BE86C952D6BDE1A66447B8A8D69237\",\n+    \"secshare_p0\": \"CCD2EF4559DB05635091D80189AB3544D6668EFC0500A8D5FF51A1F4D32CC1F1\",\n+    \"identifiers\": [\n+        0,\n+        1,\n+        2\n+    ],\n+    \"pubshares\": [\n+        \"022B02109FBCFB4DA3F53C7393B22E72A2A51C4AFBF0C01AAF44F73843CFB4B74B\",\n+        \"02EC6444271D791A1DA95300329DB2268611B9C60E193DABFDEE0AA816AE512583\",\n+        \"03113F810F612567D9552F46AF9BDA21A67D52060F95BD4A723F4B60B1820D3676\",\n+        \"020000000000000000000000000000000000000000000000000000000000000007\"\n+    ],\n+    \"secnonces_p0\": [\n+        \"DB26CEB14C1CF111274574860A4667E3305B9C8D47E48861562445CF2E7D2277D17751A6F6972FD753CF2B2784CF5193ADBEA4DA066526D0A9984E9C1C07179F\",\n+        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+    ],\n+    \"pubnonces\": [\n+        \"0330935948101543C50AF2FA7A7A4F7073CEB73290CA141497EF06E0269363162D0358785EB5CD7C1626CAB55C59B484E1B3147FA4EB919224ECB04BAB1271022A5C\",\n+        \"0244D225137BC9390069C9D4D230B6D0942A1A3D72678B638B81F3416B6FEA719C02B1C7E637FD51FE2BC2C91CB6ACA0EA6A8BB30A33A0589D369687EAA33BFC5FA8\",\n+        \"0332DAA54E451217D6F14747B72634D1E9E21B247C8E92397ABFEE296BD714772403FE1674C2B2B8076D641CEC4B2E6DF054C3D60AA77352A55233B40AC12046C312\",\n+        \"0200000000000000000000000000000000000000000000000000000000000000090287BF891D2A6DEAEBADC909352AA9405D1428C15F4B75F04DAE642A95C2548480\",\n+        \"032AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3503178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\"\n+    ],\n+    \"aggnonces\": [\n+        \"022AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3502178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\",\n+        \"020C800916841C67A0261D280120246C2DB4DB930FD6963633DC9B59F026B0EA4B03E5178080C6B5F53C3EE78297D518969CF21DDD7FDAF7C861F7BDD2C48532A6CA\",\n+        \"0282E58B733AB1B74D1C54B960D668E4298C3EF9F406D44249FB30C403568A1B14039B38604D0FD33E07C3EB81BBDAE39A38A82A1D9E325112A24F0F5480582C9CEE\",\n+        \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n+        \"048465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61037496A3CC86926D452CAFCFD55D25972CA1675D549310DE296BFF42F72EEEA8C9\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61020000000000000000000000000000000000000000000000000000000000000009\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD6102FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30\"\n+    ],\n+    \"msgs\": [\n+        \"F95466D086770E689964664219266FE5ED215C92AE20BAB5C9D79ADDDDF3C0CF\",\n+        \"\",\n+        \"2626262626262626262626262626262626262626262626262626262626262626262626262626\"\n+    ],\n+    \"valid_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Signing with minimum number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubshare_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubnonce_indices\": [\n+                1,\n+                0\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Partial-signature doesn't change if the order of signers set changes (without changing secnonces)\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                2\n+            ],\n+            \"aggnonce_index\": 1,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"39C84732FA3A9EBAF568AB269A18632E8CD62EEE3FE39F0799071FEFB71CAFC2\",\n+            \"comment\": \"Partial-signature changes if the members of signers set changes\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"aggnonce_index\": 2,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"304337D1F0BEF7F3FAFB8F5D165F77D6F511CEA3E0375F9B7EF5579A2314004E\",\n+            \"comment\": \"Signing with max number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                4\n+            ],\n+            \"aggnonce_index\": 3,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"F6A823D47F626D7106D65F7F83AAB8B4C4E2B7DC1CC036A66C747786659FED8D\",\n+            \"comment\": \"Both halves of aggregate nonce correspond to point at infinity\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 1,\n+            \"signer_index\": 0,\n+            \"expected\": \"679F7A5282BC979090AA7167499C27F64BDB562A791AE60DEBAF40F01E7CED40\",\n+            \"comment\": \"Empty message\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 2,\n+            \"signer_index\": 0,\n+            \"expected\": \"FBE3883C9C8D3CA5010A649689CBB54BC429A58CBD4CD2B3347629558536EBD6\",\n+            \"comment\": \"Message longer than 32 bytes (38-byte msg)\"\n+        }\n+    ],\n+    \"sign_error_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": null,\n+            \"signer_id\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's id is not in the participant identifier list\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The participant identifier list contains duplicate elements.\"\n+            },\n+            \"comment\": \"The participant identifier list contains duplicate elements\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares. This test case is optional: it can be skipped by implementations that do not check that the signer's pubshare is included in the list of pubshares.\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The pubshares and ids arrays must have the same length.\"\n+            },\n+            \"comment\": \"The participant identifiers count exceed the participant public shares count\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                3\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": 1,\n+                \"contrib\": \"pubshare\"\n+            },\n+            \"comment\": \"Signer 1 provided an invalid participant public share\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 4,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid due wrong tag, 0x04, in the first half\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 5,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because the second half does not correspond to an X coordinate\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 6,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because second half exceeds field size\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 1,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"first secnonce value is out of range.\"\n+            },\n+            \"comment\": \"Secnonce is invalid which may indicate nonce reuse\"\n+        }\n+    ],\n+    \"verify_fail_test_cases\": [\n+        {\n+            \"psig\": \"86210398630BE64583B750706AD94A29AA0438D55443C16DE1C18FEECA25EE0D\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"Wrong signature (which is equal to the negation of valid signature)\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"comment\": \"Wrong signer index\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares\"",
      "path": "bip-0445/python/vectors/sign_verify_vectors.json",
      "position": 417,
      "original_position": 417,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": null,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I believe this test should be moved into `sign_error_test_cases`  since this would cause an error when deriving the threshold public key from the pubshares? \n\nhttps://github.com/bitcoin/bips/blob/ec46a20323840b1a6aba83bc2d18b34dd0811245/bip-frost-signing.md#signers-context\n\n>Fail if DeriveThreshPubkey(id1..u, pubshare1..u) â‰  thresh_pk",
      "created_at": "2026-01-28T19:38:22Z",
      "updated_at": "2026-01-28T19:38:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2738288392",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2738288392"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 417,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741382058",
      "pull_request_review_id": 3722367851,
      "id": 2741382058,
      "node_id": "PRRC_kwDOAN28mc6jZiuq",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 25,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2737712711,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yes, prior versions of this BIP had those two paragraphs. I removed them in https://github.com/siv2r/bip-frost-signing/commit/5e7e913782ec9c11951be19bb1308a26e0a60294 wanting to make the motivation section more concise. These paragraphs seem important to ignore though. I'll add it back.",
      "created_at": "2026-01-29T12:23:31Z",
      "updated_at": "2026-01-29T12:42:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741382058",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741382058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741534905",
      "pull_request_review_id": 3722562988,
      "id": 2741534905,
      "node_id": "PRRC_kwDOAN28mc6jaIC5",
      "diff_hunk": "@@ -0,0 +1,509 @@\n+{\n+    \"n\": 3,\n+    \"t\": 2,\n+    \"threshold_pubkey\": \"03B02645D79ABFC494338139410F9D7F0A72BE86C952D6BDE1A66447B8A8D69237\",\n+    \"secshare_p0\": \"CCD2EF4559DB05635091D80189AB3544D6668EFC0500A8D5FF51A1F4D32CC1F1\",\n+    \"identifiers\": [\n+        0,\n+        1,\n+        2\n+    ],\n+    \"pubshares\": [\n+        \"022B02109FBCFB4DA3F53C7393B22E72A2A51C4AFBF0C01AAF44F73843CFB4B74B\",\n+        \"02EC6444271D791A1DA95300329DB2268611B9C60E193DABFDEE0AA816AE512583\",\n+        \"03113F810F612567D9552F46AF9BDA21A67D52060F95BD4A723F4B60B1820D3676\",\n+        \"020000000000000000000000000000000000000000000000000000000000000007\"\n+    ],\n+    \"secnonces_p0\": [\n+        \"DB26CEB14C1CF111274574860A4667E3305B9C8D47E48861562445CF2E7D2277D17751A6F6972FD753CF2B2784CF5193ADBEA4DA066526D0A9984E9C1C07179F\",\n+        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+    ],\n+    \"pubnonces\": [\n+        \"0330935948101543C50AF2FA7A7A4F7073CEB73290CA141497EF06E0269363162D0358785EB5CD7C1626CAB55C59B484E1B3147FA4EB919224ECB04BAB1271022A5C\",\n+        \"0244D225137BC9390069C9D4D230B6D0942A1A3D72678B638B81F3416B6FEA719C02B1C7E637FD51FE2BC2C91CB6ACA0EA6A8BB30A33A0589D369687EAA33BFC5FA8\",\n+        \"0332DAA54E451217D6F14747B72634D1E9E21B247C8E92397ABFEE296BD714772403FE1674C2B2B8076D641CEC4B2E6DF054C3D60AA77352A55233B40AC12046C312\",\n+        \"0200000000000000000000000000000000000000000000000000000000000000090287BF891D2A6DEAEBADC909352AA9405D1428C15F4B75F04DAE642A95C2548480\",\n+        \"032AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3503178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\"\n+    ],\n+    \"aggnonces\": [\n+        \"022AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3502178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\",\n+        \"020C800916841C67A0261D280120246C2DB4DB930FD6963633DC9B59F026B0EA4B03E5178080C6B5F53C3EE78297D518969CF21DDD7FDAF7C861F7BDD2C48532A6CA\",\n+        \"0282E58B733AB1B74D1C54B960D668E4298C3EF9F406D44249FB30C403568A1B14039B38604D0FD33E07C3EB81BBDAE39A38A82A1D9E325112A24F0F5480582C9CEE\",\n+        \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n+        \"048465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61037496A3CC86926D452CAFCFD55D25972CA1675D549310DE296BFF42F72EEEA8C9\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61020000000000000000000000000000000000000000000000000000000000000009\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD6102FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30\"\n+    ],\n+    \"msgs\": [\n+        \"F95466D086770E689964664219266FE5ED215C92AE20BAB5C9D79ADDDDF3C0CF\",\n+        \"\",\n+        \"2626262626262626262626262626262626262626262626262626262626262626262626262626\"\n+    ],\n+    \"valid_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Signing with minimum number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubshare_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubnonce_indices\": [\n+                1,\n+                0\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Partial-signature doesn't change if the order of signers set changes (without changing secnonces)\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                2\n+            ],\n+            \"aggnonce_index\": 1,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"39C84732FA3A9EBAF568AB269A18632E8CD62EEE3FE39F0799071FEFB71CAFC2\",\n+            \"comment\": \"Partial-signature changes if the members of signers set changes\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"aggnonce_index\": 2,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"304337D1F0BEF7F3FAFB8F5D165F77D6F511CEA3E0375F9B7EF5579A2314004E\",\n+            \"comment\": \"Signing with max number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                4\n+            ],\n+            \"aggnonce_index\": 3,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"F6A823D47F626D7106D65F7F83AAB8B4C4E2B7DC1CC036A66C747786659FED8D\",\n+            \"comment\": \"Both halves of aggregate nonce correspond to point at infinity\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 1,\n+            \"signer_index\": 0,\n+            \"expected\": \"679F7A5282BC979090AA7167499C27F64BDB562A791AE60DEBAF40F01E7CED40\",\n+            \"comment\": \"Empty message\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 2,\n+            \"signer_index\": 0,\n+            \"expected\": \"FBE3883C9C8D3CA5010A649689CBB54BC429A58CBD4CD2B3347629558536EBD6\",\n+            \"comment\": \"Message longer than 32 bytes (38-byte msg)\"\n+        }\n+    ],\n+    \"sign_error_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": null,\n+            \"signer_id\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's id is not in the participant identifier list\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The participant identifier list contains duplicate elements.\"\n+            },\n+            \"comment\": \"The participant identifier list contains duplicate elements\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares. This test case is optional: it can be skipped by implementations that do not check that the signer's pubshare is included in the list of pubshares.\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The pubshares and ids arrays must have the same length.\"\n+            },\n+            \"comment\": \"The participant identifiers count exceed the participant public shares count\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                3\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": 1,\n+                \"contrib\": \"pubshare\"\n+            },\n+            \"comment\": \"Signer 1 provided an invalid participant public share\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 4,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid due wrong tag, 0x04, in the first half\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 5,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because the second half does not correspond to an X coordinate\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 6,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because second half exceeds field size\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 1,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"first secnonce value is out of range.\"\n+            },\n+            \"comment\": \"Secnonce is invalid which may indicate nonce reuse\"\n+        }\n+    ],\n+    \"verify_fail_test_cases\": [\n+        {\n+            \"psig\": \"86210398630BE64583B750706AD94A29AA0438D55443C16DE1C18FEECA25EE0D\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"Wrong signature (which is equal to the negation of valid signature)\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"comment\": \"Wrong signer index\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares\"",
      "path": "bip-0445/python/vectors/sign_verify_vectors.json",
      "position": 417,
      "original_position": 417,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2738288392,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "That's a great observation! The `DeriveThreshPubkey` function would fail if we gave it a pubshare that's not part of the `t`-of-`n` FROST key (i.e., any pubshare other than the `n` generated during keygen). Here, we're providing a pubshare that was generated during keygen, so `DeriveThreshPubkey` passes. However, `partial_sig_verify` fails because we're not providing the correct pubshare whose secshare was used to generate `psig`.\n\nTL;DR: We're generating `psig` with `secshare`, but using a different pubshare (one that exists in the `t`-of-`n` FROST key) for verification. That's why the pubshare indices list in this test vector looks like:\n\n```\n            \"pubshare_indices\": [\n                2, # not signer's pubshare\n                1\n            ],\n```\n\ninstead of\n\n```\n            \"pubshare_indices\": [\n                0, # signer's pubshare\n                1\n            ],\n```",
      "created_at": "2026-01-29T13:00:55Z",
      "updated_at": "2026-01-29T13:01:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741534905",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741534905"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 417,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741543368",
      "pull_request_review_id": 3722576877,
      "id": 2741543368,
      "node_id": "PRRC_kwDOAN28mc6jaKHI",
      "diff_hunk": "@@ -0,0 +1,509 @@\n+{\n+    \"n\": 3,\n+    \"t\": 2,\n+    \"threshold_pubkey\": \"03B02645D79ABFC494338139410F9D7F0A72BE86C952D6BDE1A66447B8A8D69237\",\n+    \"secshare_p0\": \"CCD2EF4559DB05635091D80189AB3544D6668EFC0500A8D5FF51A1F4D32CC1F1\",\n+    \"identifiers\": [\n+        0,\n+        1,\n+        2\n+    ],\n+    \"pubshares\": [\n+        \"022B02109FBCFB4DA3F53C7393B22E72A2A51C4AFBF0C01AAF44F73843CFB4B74B\",\n+        \"02EC6444271D791A1DA95300329DB2268611B9C60E193DABFDEE0AA816AE512583\",\n+        \"03113F810F612567D9552F46AF9BDA21A67D52060F95BD4A723F4B60B1820D3676\",\n+        \"020000000000000000000000000000000000000000000000000000000000000007\"\n+    ],\n+    \"secnonces_p0\": [\n+        \"DB26CEB14C1CF111274574860A4667E3305B9C8D47E48861562445CF2E7D2277D17751A6F6972FD753CF2B2784CF5193ADBEA4DA066526D0A9984E9C1C07179F\",\n+        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+    ],\n+    \"pubnonces\": [\n+        \"0330935948101543C50AF2FA7A7A4F7073CEB73290CA141497EF06E0269363162D0358785EB5CD7C1626CAB55C59B484E1B3147FA4EB919224ECB04BAB1271022A5C\",\n+        \"0244D225137BC9390069C9D4D230B6D0942A1A3D72678B638B81F3416B6FEA719C02B1C7E637FD51FE2BC2C91CB6ACA0EA6A8BB30A33A0589D369687EAA33BFC5FA8\",\n+        \"0332DAA54E451217D6F14747B72634D1E9E21B247C8E92397ABFEE296BD714772403FE1674C2B2B8076D641CEC4B2E6DF054C3D60AA77352A55233B40AC12046C312\",\n+        \"0200000000000000000000000000000000000000000000000000000000000000090287BF891D2A6DEAEBADC909352AA9405D1428C15F4B75F04DAE642A95C2548480\",\n+        \"032AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3503178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\"\n+    ],\n+    \"aggnonces\": [\n+        \"022AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3502178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\",\n+        \"020C800916841C67A0261D280120246C2DB4DB930FD6963633DC9B59F026B0EA4B03E5178080C6B5F53C3EE78297D518969CF21DDD7FDAF7C861F7BDD2C48532A6CA\",\n+        \"0282E58B733AB1B74D1C54B960D668E4298C3EF9F406D44249FB30C403568A1B14039B38604D0FD33E07C3EB81BBDAE39A38A82A1D9E325112A24F0F5480582C9CEE\",\n+        \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n+        \"048465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61037496A3CC86926D452CAFCFD55D25972CA1675D549310DE296BFF42F72EEEA8C9\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61020000000000000000000000000000000000000000000000000000000000000009\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD6102FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30\"\n+    ],\n+    \"msgs\": [\n+        \"F95466D086770E689964664219266FE5ED215C92AE20BAB5C9D79ADDDDF3C0CF\",\n+        \"\",\n+        \"2626262626262626262626262626262626262626262626262626262626262626262626262626\"\n+    ],\n+    \"valid_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Signing with minimum number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubshare_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubnonce_indices\": [\n+                1,\n+                0\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Partial-signature doesn't change if the order of signers set changes (without changing secnonces)\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                2\n+            ],\n+            \"aggnonce_index\": 1,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"39C84732FA3A9EBAF568AB269A18632E8CD62EEE3FE39F0799071FEFB71CAFC2\",\n+            \"comment\": \"Partial-signature changes if the members of signers set changes\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"aggnonce_index\": 2,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"304337D1F0BEF7F3FAFB8F5D165F77D6F511CEA3E0375F9B7EF5579A2314004E\",\n+            \"comment\": \"Signing with max number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                4\n+            ],\n+            \"aggnonce_index\": 3,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"F6A823D47F626D7106D65F7F83AAB8B4C4E2B7DC1CC036A66C747786659FED8D\",\n+            \"comment\": \"Both halves of aggregate nonce correspond to point at infinity\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 1,\n+            \"signer_index\": 0,\n+            \"expected\": \"679F7A5282BC979090AA7167499C27F64BDB562A791AE60DEBAF40F01E7CED40\",\n+            \"comment\": \"Empty message\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 2,\n+            \"signer_index\": 0,\n+            \"expected\": \"FBE3883C9C8D3CA5010A649689CBB54BC429A58CBD4CD2B3347629558536EBD6\",\n+            \"comment\": \"Message longer than 32 bytes (38-byte msg)\"\n+        }\n+    ],\n+    \"sign_error_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": null,\n+            \"signer_id\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's id is not in the participant identifier list\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The participant identifier list contains duplicate elements.\"\n+            },\n+            \"comment\": \"The participant identifier list contains duplicate elements\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares. This test case is optional: it can be skipped by implementations that do not check that the signer's pubshare is included in the list of pubshares.\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The pubshares and ids arrays must have the same length.\"\n+            },\n+            \"comment\": \"The participant identifiers count exceed the participant public shares count\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                3\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": 1,\n+                \"contrib\": \"pubshare\"\n+            },\n+            \"comment\": \"Signer 1 provided an invalid participant public share\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 4,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid due wrong tag, 0x04, in the first half\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 5,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because the second half does not correspond to an X coordinate\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 6,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because second half exceeds field size\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 1,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"first secnonce value is out of range.\"\n+            },\n+            \"comment\": \"Secnonce is invalid which may indicate nonce reuse\"\n+        }\n+    ],\n+    \"verify_fail_test_cases\": [\n+        {\n+            \"psig\": \"86210398630BE64583B750706AD94A29AA0438D55443C16DE1C18FEECA25EE0D\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"Wrong signature (which is equal to the negation of valid signature)\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"comment\": \"Wrong signer index\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares\"",
      "path": "bip-0445/python/vectors/sign_verify_vectors.json",
      "position": 417,
      "original_position": 417,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2738288392,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The test vectors covers a lot of cases (some of which may not be useful) if you find something unncessary or if I missed an essential edge case, please let me know I'll add/remove them accordingly.",
      "created_at": "2026-01-29T13:02:53Z",
      "updated_at": "2026-01-29T13:02:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741543368",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741543368"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 417,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741713709",
      "pull_request_review_id": 3722803621,
      "id": 2741713709,
      "node_id": "PRRC_kwDOAN28mc6jazst",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 25,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2737712711,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 5d87f56.",
      "created_at": "2026-01-29T13:41:14Z",
      "updated_at": "2026-01-29T13:41:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741713709",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741713709"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741714225",
      "pull_request_review_id": 3722804328,
      "id": 2741714225,
      "node_id": "PRRC_kwDOAN28mc6jaz0x",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 111,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2737718506,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 5d87f56.",
      "created_at": "2026-01-29T13:41:22Z",
      "updated_at": "2026-01-29T13:41:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741714225",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741714225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 110,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741714723",
      "pull_request_review_id": 3722804981,
      "id": 2741714723,
      "node_id": "PRRC_kwDOAN28mc6jaz8j",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 244,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2737721994,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 5d87f56.",
      "created_at": "2026-01-29T13:41:27Z",
      "updated_at": "2026-01-29T13:41:28Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741714723",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741714723"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741715064",
      "pull_request_review_id": 3722805359,
      "id": 2741715064,
      "node_id": "PRRC_kwDOAN28mc6ja0B4",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 247,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2737727982,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 5d87f56.",
      "created_at": "2026-01-29T13:41:32Z",
      "updated_at": "2026-01-29T13:41:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741715064",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741715064"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741715668",
      "pull_request_review_id": 3722806038,
      "id": 2741715668,
      "node_id": "PRRC_kwDOAN28mc6ja0LU",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *ord* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *ord* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *ord* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if not *1 â‰¤ t â‰¤ n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)[^lagrange-shift] &ensp;(mod ord)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id) &ensp;(mod ord)*\n+- *&lambda; = num &middot; deno<sup>-1</sup> &ensp;(mod ord)*\n+- Return *&lambda;*\n+\n+[^lagrange-shift]: The standard Lagrange interpolation coefficient uses the formula *id<sub>i</sub> / (id<sub>i</sub> - my_id)* for each term in the product, where ids are in the range *1..n*. However, since participant identifiers in this protocol are zero-indexed (range *0..n-1*), we shift them by adding 1. This transforms each term to *(id<sub>i</sub>+1) / (id<sub>i</sub> - my_id)*.\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 351,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2737739678,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 5d87f56.",
      "created_at": "2026-01-29T13:41:41Z",
      "updated_at": "2026-01-29T13:41:41Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741715668",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741715668"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 350,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741716072",
      "pull_request_review_id": 3722806642,
      "id": 2741716072,
      "node_id": "PRRC_kwDOAN28mc6ja0Ro",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *ord* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *ord* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *ord* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if not *1 â‰¤ t â‰¤ n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)[^lagrange-shift] &ensp;(mod ord)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id) &ensp;(mod ord)*\n+- *&lambda; = num &middot; deno<sup>-1</sup> &ensp;(mod ord)*\n+- Return *&lambda;*\n+\n+[^lagrange-shift]: The standard Lagrange interpolation coefficient uses the formula *id<sub>i</sub> / (id<sub>i</sub> - my_id)* for each term in the product, where ids are in the range *1..n*. However, since participant identifiers in this protocol are zero-indexed (range *0..n-1*), we shift them by adding 1. This transforms each term to *(id<sub>i</sub>+1) / (id<sub>i</sub> - my_id)*.\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc &ensp;(mod ord)*\n+- LetÂ *tacc' = t + g &middot; tacc &ensp;(mod ord)*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 429,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2737745081,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 5d87f56.",
      "created_at": "2026-01-29T13:41:47Z",
      "updated_at": "2026-01-29T13:41:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741716072",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741716072"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741716698",
      "pull_request_review_id": 3722807317,
      "id": 2741716698,
      "node_id": "PRRC_kwDOAN28mc6ja0ba",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *ord* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *ord* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *ord* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if not *1 â‰¤ t â‰¤ n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)[^lagrange-shift] &ensp;(mod ord)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id) &ensp;(mod ord)*\n+- *&lambda; = num &middot; deno<sup>-1</sup> &ensp;(mod ord)*\n+- Return *&lambda;*\n+\n+[^lagrange-shift]: The standard Lagrange interpolation coefficient uses the formula *id<sub>i</sub> / (id<sub>i</sub> - my_id)* for each term in the product, where ids are in the range *1..n*. However, since participant identifiers in this protocol are zero-indexed (range *0..n-1*), we shift them by adding 1. This transforms each term to *(id<sub>i</sub>+1) / (id<sub>i</sub> - my_id)*.\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc &ensp;(mod ord)*\n+- LetÂ *tacc' = t + g &middot; tacc &ensp;(mod ord)*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value pair *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 445,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2737749501,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 5d87f56.",
      "created_at": "2026-01-29T13:41:57Z",
      "updated_at": "2026-01-29T13:41:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741716698",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741716698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 445,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741717073",
      "pull_request_review_id": 3722808001,
      "id": 2741717073,
      "node_id": "PRRC_kwDOAN28mc6ja0hR",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0\n+Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t*-of-*n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n*-of-*n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[RRJSS][roast], [CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of *n* participants with a *threshold public key* (representing a *t*-of-*n* threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all *n* participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least *t* participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementation's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negate *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the *t*-of-*n* threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are *u* (where *t <= u <= n < 2^32*) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* (individual to each participant, not shared with the coordinator) and a [Signers Context](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The Signers Context represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication *secshare \\* G*.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible *u* signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+The signing participants information is stored in a [Signers Context](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [Tweak Context](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to *t-1* signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or Signers Context[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the Signers Context can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+<!-- markdownlint-disable-next-line MD011 -->\n+The bit can be obtained with *GetPlainPubkey(tweak_ctx)[0] & 1*.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:** When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *ord* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *ord* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *ord* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *ord* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if not *1 â‰¤ t â‰¤ n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)[^lagrange-shift] &ensp;(mod ord)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id) &ensp;(mod ord)*\n+- *&lambda; = num &middot; deno<sup>-1</sup> &ensp;(mod ord)*\n+- Return *&lambda;*\n+\n+[^lagrange-shift]: The standard Lagrange interpolation coefficient uses the formula *id<sub>i</sub> / (id<sub>i</sub> - my_id)* for each term in the product, where ids are in the range *1..n*. However, since participant identifiers in this protocol are zero-indexed (range *0..n-1*), we shift them by adding 1. This transforms each term to *(id<sub>i</sub>+1) / (id<sub>i</sub> - my_id)*.\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc &ensp;(mod ord)*\n+- LetÂ *tacc' = t + g &middot; tacc &ensp;(mod ord)*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value pair *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)\\*33:j\\*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *pubshare = cbytes(d' &middot; G)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d' &ensp;(mod ord)*Â (SeeÂ [Negation of Secret Share When Signing](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d &ensp;(mod ord)*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:\n+\n+- Inputs:\n+  - The partial signatureÂ *psig*: a 32-byte array, serialized scalar\n+  - The list public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte arrays, each an output of *NonceGen*",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 528,
      "commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2737751388,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 5d87f56.",
      "created_at": "2026-01-29T13:42:03Z",
      "updated_at": "2026-01-29T13:42:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2741717073",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2741717073"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 528,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2743407007",
      "pull_request_review_id": 3724888250,
      "id": 2743407007,
      "node_id": "PRRC_kwDOAN28mc6jhRGf",
      "diff_hunk": "@@ -0,0 +1,509 @@\n+{\n+    \"n\": 3,\n+    \"t\": 2,\n+    \"threshold_pubkey\": \"03B02645D79ABFC494338139410F9D7F0A72BE86C952D6BDE1A66447B8A8D69237\",\n+    \"secshare_p0\": \"CCD2EF4559DB05635091D80189AB3544D6668EFC0500A8D5FF51A1F4D32CC1F1\",\n+    \"identifiers\": [\n+        0,\n+        1,\n+        2\n+    ],\n+    \"pubshares\": [\n+        \"022B02109FBCFB4DA3F53C7393B22E72A2A51C4AFBF0C01AAF44F73843CFB4B74B\",\n+        \"02EC6444271D791A1DA95300329DB2268611B9C60E193DABFDEE0AA816AE512583\",\n+        \"03113F810F612567D9552F46AF9BDA21A67D52060F95BD4A723F4B60B1820D3676\",\n+        \"020000000000000000000000000000000000000000000000000000000000000007\"\n+    ],\n+    \"secnonces_p0\": [\n+        \"DB26CEB14C1CF111274574860A4667E3305B9C8D47E48861562445CF2E7D2277D17751A6F6972FD753CF2B2784CF5193ADBEA4DA066526D0A9984E9C1C07179F\",\n+        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+    ],\n+    \"pubnonces\": [\n+        \"0330935948101543C50AF2FA7A7A4F7073CEB73290CA141497EF06E0269363162D0358785EB5CD7C1626CAB55C59B484E1B3147FA4EB919224ECB04BAB1271022A5C\",\n+        \"0244D225137BC9390069C9D4D230B6D0942A1A3D72678B638B81F3416B6FEA719C02B1C7E637FD51FE2BC2C91CB6ACA0EA6A8BB30A33A0589D369687EAA33BFC5FA8\",\n+        \"0332DAA54E451217D6F14747B72634D1E9E21B247C8E92397ABFEE296BD714772403FE1674C2B2B8076D641CEC4B2E6DF054C3D60AA77352A55233B40AC12046C312\",\n+        \"0200000000000000000000000000000000000000000000000000000000000000090287BF891D2A6DEAEBADC909352AA9405D1428C15F4B75F04DAE642A95C2548480\",\n+        \"032AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3503178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\"\n+    ],\n+    \"aggnonces\": [\n+        \"022AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3502178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\",\n+        \"020C800916841C67A0261D280120246C2DB4DB930FD6963633DC9B59F026B0EA4B03E5178080C6B5F53C3EE78297D518969CF21DDD7FDAF7C861F7BDD2C48532A6CA\",\n+        \"0282E58B733AB1B74D1C54B960D668E4298C3EF9F406D44249FB30C403568A1B14039B38604D0FD33E07C3EB81BBDAE39A38A82A1D9E325112A24F0F5480582C9CEE\",\n+        \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n+        \"048465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61037496A3CC86926D452CAFCFD55D25972CA1675D549310DE296BFF42F72EEEA8C9\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61020000000000000000000000000000000000000000000000000000000000000009\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD6102FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30\"\n+    ],\n+    \"msgs\": [\n+        \"F95466D086770E689964664219266FE5ED215C92AE20BAB5C9D79ADDDDF3C0CF\",\n+        \"\",\n+        \"2626262626262626262626262626262626262626262626262626262626262626262626262626\"\n+    ],\n+    \"valid_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Signing with minimum number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubshare_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubnonce_indices\": [\n+                1,\n+                0\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Partial-signature doesn't change if the order of signers set changes (without changing secnonces)\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                2\n+            ],\n+            \"aggnonce_index\": 1,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"39C84732FA3A9EBAF568AB269A18632E8CD62EEE3FE39F0799071FEFB71CAFC2\",\n+            \"comment\": \"Partial-signature changes if the members of signers set changes\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"aggnonce_index\": 2,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"304337D1F0BEF7F3FAFB8F5D165F77D6F511CEA3E0375F9B7EF5579A2314004E\",\n+            \"comment\": \"Signing with max number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                4\n+            ],\n+            \"aggnonce_index\": 3,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"F6A823D47F626D7106D65F7F83AAB8B4C4E2B7DC1CC036A66C747786659FED8D\",\n+            \"comment\": \"Both halves of aggregate nonce correspond to point at infinity\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 1,\n+            \"signer_index\": 0,\n+            \"expected\": \"679F7A5282BC979090AA7167499C27F64BDB562A791AE60DEBAF40F01E7CED40\",\n+            \"comment\": \"Empty message\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 2,\n+            \"signer_index\": 0,\n+            \"expected\": \"FBE3883C9C8D3CA5010A649689CBB54BC429A58CBD4CD2B3347629558536EBD6\",\n+            \"comment\": \"Message longer than 32 bytes (38-byte msg)\"\n+        }\n+    ],\n+    \"sign_error_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": null,\n+            \"signer_id\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's id is not in the participant identifier list\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The participant identifier list contains duplicate elements.\"\n+            },\n+            \"comment\": \"The participant identifier list contains duplicate elements\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares. This test case is optional: it can be skipped by implementations that do not check that the signer's pubshare is included in the list of pubshares.\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The pubshares and ids arrays must have the same length.\"\n+            },\n+            \"comment\": \"The participant identifiers count exceed the participant public shares count\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                3\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": 1,\n+                \"contrib\": \"pubshare\"\n+            },\n+            \"comment\": \"Signer 1 provided an invalid participant public share\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 4,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid due wrong tag, 0x04, in the first half\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 5,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because the second half does not correspond to an X coordinate\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 6,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because second half exceeds field size\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 1,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"first secnonce value is out of range.\"\n+            },\n+            \"comment\": \"Secnonce is invalid which may indicate nonce reuse\"\n+        }\n+    ],\n+    \"verify_fail_test_cases\": [\n+        {\n+            \"psig\": \"86210398630BE64583B750706AD94A29AA0438D55443C16DE1C18FEECA25EE0D\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"Wrong signature (which is equal to the negation of valid signature)\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"comment\": \"Wrong signer index\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares\"",
      "path": "bip-0445/python/vectors/sign_verify_vectors.json",
      "position": 417,
      "original_position": 417,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2738288392,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Doesn't this compute the wrong pubkey because the lagrange coefficient ends up being incorrect - `id` should be `2` and ends it ends up being `0` because of the `id_indices` provided in this test case\r\n\r\n```\r\n\"id_indices\": [\r\n    0,\r\n    1\r\n],\r\n```\r\n\r\nBigger picture, I don't understand why we don't call [`ValidateSignersCtx`](https://github.com/bitcoin/bips/blob/ec46a20323840b1a6aba83bc2d18b34dd0811245/bip-frost-signing.md#signers-context) in either [`PartialSignatureVerify`](https://github.com/bitcoin/bips/blob/ec46a20323840b1a6aba83bc2d18b34dd0811245/bip-frost-signing.md#partial-signature-verification) or [`PartialSignatureVerifyInternal`](https://github.com/bitcoin/bips/blob/ec46a20323840b1a6aba83bc2d18b34dd0811245/bip-frost-signing.md#partial-signature-verification) as the BIP is written.\r\n\r\nIt appears in the python implementation in this PR, we do call [`validate_signers_ctx`](https://github.com/siv2r/bips/blob/5d87f5626edf3885ab258fe7ef3b438814fdeb96/bip-frost-signing/python/frost_ref/signing.py#L436). However in the test cases, you call [`partial_sig_verify_internal`](https://github.com/siv2r/bips/blob/a88f033df7a2361c700f205ced6b50d49871c696/bip-frost-signing/python/tests.py#L236) directly which circumvents the check. This is probably a signal that there should be some encapsulation of `partial_sig_verify_internal` - does this actually need to be in a separate method in the BIP? If so - and we allow it to be called directly - we need to redo any context validation in that function.\r\n\r\nIs this an oversight or an intentional choice ? If the former, i think we should add validating the signer context inside of `partial_sig_verify_internal`, if the latter I would be interested in hearing the reasoning.\r\n\r\n\r\n\r\n",
      "created_at": "2026-01-29T20:31:55Z",
      "updated_at": "2026-01-29T20:32:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2743407007",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2743407007"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 417,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2744835406",
      "pull_request_review_id": 3726592287,
      "id": 2744835406,
      "node_id": "PRRC_kwDOAN28mc6jmt1O",
      "diff_hunk": "@@ -0,0 +1,509 @@\n+{\n+    \"n\": 3,\n+    \"t\": 2,\n+    \"threshold_pubkey\": \"03B02645D79ABFC494338139410F9D7F0A72BE86C952D6BDE1A66447B8A8D69237\",\n+    \"secshare_p0\": \"CCD2EF4559DB05635091D80189AB3544D6668EFC0500A8D5FF51A1F4D32CC1F1\",\n+    \"identifiers\": [\n+        0,\n+        1,\n+        2\n+    ],\n+    \"pubshares\": [\n+        \"022B02109FBCFB4DA3F53C7393B22E72A2A51C4AFBF0C01AAF44F73843CFB4B74B\",\n+        \"02EC6444271D791A1DA95300329DB2268611B9C60E193DABFDEE0AA816AE512583\",\n+        \"03113F810F612567D9552F46AF9BDA21A67D52060F95BD4A723F4B60B1820D3676\",\n+        \"020000000000000000000000000000000000000000000000000000000000000007\"\n+    ],\n+    \"secnonces_p0\": [\n+        \"DB26CEB14C1CF111274574860A4667E3305B9C8D47E48861562445CF2E7D2277D17751A6F6972FD753CF2B2784CF5193ADBEA4DA066526D0A9984E9C1C07179F\",\n+        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+    ],\n+    \"pubnonces\": [\n+        \"0330935948101543C50AF2FA7A7A4F7073CEB73290CA141497EF06E0269363162D0358785EB5CD7C1626CAB55C59B484E1B3147FA4EB919224ECB04BAB1271022A5C\",\n+        \"0244D225137BC9390069C9D4D230B6D0942A1A3D72678B638B81F3416B6FEA719C02B1C7E637FD51FE2BC2C91CB6ACA0EA6A8BB30A33A0589D369687EAA33BFC5FA8\",\n+        \"0332DAA54E451217D6F14747B72634D1E9E21B247C8E92397ABFEE296BD714772403FE1674C2B2B8076D641CEC4B2E6DF054C3D60AA77352A55233B40AC12046C312\",\n+        \"0200000000000000000000000000000000000000000000000000000000000000090287BF891D2A6DEAEBADC909352AA9405D1428C15F4B75F04DAE642A95C2548480\",\n+        \"032AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3503178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\"\n+    ],\n+    \"aggnonces\": [\n+        \"022AAC6A4960DE35FC36D8E2DC06255C5CB7FD28250DFD84EBF1AC943B1EA22C3502178AD06BB0490BAD857446FEF55C15FD9FF4329F4EE2F23CA8B7CA0598014910\",\n+        \"020C800916841C67A0261D280120246C2DB4DB930FD6963633DC9B59F026B0EA4B03E5178080C6B5F53C3EE78297D518969CF21DDD7FDAF7C861F7BDD2C48532A6CA\",\n+        \"0282E58B733AB1B74D1C54B960D668E4298C3EF9F406D44249FB30C403568A1B14039B38604D0FD33E07C3EB81BBDAE39A38A82A1D9E325112A24F0F5480582C9CEE\",\n+        \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n+        \"048465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61037496A3CC86926D452CAFCFD55D25972CA1675D549310DE296BFF42F72EEEA8C9\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD61020000000000000000000000000000000000000000000000000000000000000009\",\n+        \"028465FCF0BBDBCF443AABCCE533D42B4B5A10966AC09A49655E8C42DAAB8FCD6102FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30\"\n+    ],\n+    \"msgs\": [\n+        \"F95466D086770E689964664219266FE5ED215C92AE20BAB5C9D79ADDDDF3C0CF\",\n+        \"\",\n+        \"2626262626262626262626262626262626262626262626262626262626262626262626262626\"\n+    ],\n+    \"valid_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Signing with minimum number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubshare_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubnonce_indices\": [\n+                1,\n+                0\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"expected\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"comment\": \"Partial-signature doesn't change if the order of signers set changes (without changing secnonces)\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                2\n+            ],\n+            \"aggnonce_index\": 1,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"39C84732FA3A9EBAF568AB269A18632E8CD62EEE3FE39F0799071FEFB71CAFC2\",\n+            \"comment\": \"Partial-signature changes if the members of signers set changes\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"aggnonce_index\": 2,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"304337D1F0BEF7F3FAFB8F5D165F77D6F511CEA3E0375F9B7EF5579A2314004E\",\n+            \"comment\": \"Signing with max number of participants\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1,\n+                4\n+            ],\n+            \"aggnonce_index\": 3,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": \"F6A823D47F626D7106D65F7F83AAB8B4C4E2B7DC1CC036A66C747786659FED8D\",\n+            \"comment\": \"Both halves of aggregate nonce correspond to point at infinity\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 1,\n+            \"signer_index\": 0,\n+            \"expected\": \"679F7A5282BC979090AA7167499C27F64BDB562A791AE60DEBAF40F01E7CED40\",\n+            \"comment\": \"Empty message\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 2,\n+            \"signer_index\": 0,\n+            \"expected\": \"FBE3883C9C8D3CA5010A649689CBB54BC429A58CBD4CD2B3347629558536EBD6\",\n+            \"comment\": \"Message longer than 32 bytes (38-byte msg)\"\n+        }\n+    ],\n+    \"sign_error_test_cases\": [\n+        {\n+            \"id_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": null,\n+            \"signer_id\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's id is not in the participant identifier list\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The participant identifier list contains duplicate elements.\"\n+            },\n+            \"comment\": \"The participant identifier list contains duplicate elements\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The provided key material is incorrect.\"\n+            },\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares. This test case is optional: it can be skipped by implementations that do not check that the signer's pubshare is included in the list of pubshares.\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"The pubshares and ids arrays must have the same length.\"\n+            },\n+            \"comment\": \"The participant identifiers count exceed the participant public shares count\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                3\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": 1,\n+                \"contrib\": \"pubshare\"\n+            },\n+            \"comment\": \"Signer 1 provided an invalid participant public share\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 4,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid due wrong tag, 0x04, in the first half\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 5,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because the second half does not correspond to an X coordinate\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 6,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 0,\n+            \"error\": {\n+                \"type\": \"InvalidContributionError\",\n+                \"id\": null,\n+                \"contrib\": \"aggnonce\"\n+            },\n+            \"comment\": \"Aggregate nonce is invalid because second half exceeds field size\"\n+        },\n+        {\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"aggnonce_index\": 0,\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"secnonce_index\": 1,\n+            \"error\": {\n+                \"type\": \"ValueError\",\n+                \"message\": \"first secnonce value is out of range.\"\n+            },\n+            \"comment\": \"Secnonce is invalid which may indicate nonce reuse\"\n+        }\n+    ],\n+    \"verify_fail_test_cases\": [\n+        {\n+            \"psig\": \"86210398630BE64583B750706AD94A29AA0438D55443C16DE1C18FEECA25EE0D\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"Wrong signature (which is equal to the negation of valid signature)\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"comment\": \"Wrong signer index\"\n+        },\n+        {\n+            \"psig\": \"79DEFC679CF419BA7C48AF8F9526B5D510AAA4115B04DECDDE10CE9E06105334\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                2,\n+                1\n+            ],\n+            \"pubnonce_indices\": [\n+                0,\n+                1\n+            ],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"comment\": \"The signer's pubshare is not in the list of pubshares\"",
      "path": "bip-0445/python/vectors/sign_verify_vectors.json",
      "position": 417,
      "original_position": 417,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "6ea53f248b6d8350262fad4aba2f69fd0b2dd93d",
      "in_reply_to_id": 2738288392,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah yes, you're correct. I missed the incorrect `id_indices`. The `DeriveThresPubkey` should fail here.\r\n\r\nHmm, `PartialSignatureVerify` must call `ValidateSignersCtx`. The Python code does this, but it's not reflected in the BIP text. I'll update it. Thanks!\r\n\r\n`PartialSignatureVerifyInternal` does call `ValidateSignersCtx` in both the BIP text and Python code. It's not apparent because it calls `GetSessionValues`, which internally calls `ValidateSignersCtx`. I think it's useful to explicitly call it in `PartialSignatureVerifyInternal` (even though it's redundant) to prevent implementers from making mistakes.\r\n\r\nI was wondering why the test vector passes in the code even though both `partial_sig_verify_internal` and `partial_sig_verify` call `validate_signers_ctx`. Apparently, there's a bug in the test code. The [`verify_fail_test_cases` reuses an old valid `session_ctx`](https://github.com/siv2r/bip-frost-signing/blob/8155f5cb60cdb75793cac1f0bab5c2eafc54461b/python/tests.py#L227-L242) (and fails to create a correct new one), so `DeriveThresPubkey` passes. It would have failed with the new `session_ctx`. I'll fix this.",
      "created_at": "2026-01-30T06:30:28Z",
      "updated_at": "2026-01-30T06:30:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2744835406",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2744835406"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 417,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748150992",
      "pull_request_review_id": 3730605974,
      "id": 2748150992,
      "node_id": "PRRC_kwDOAN28mc6jzXTQ",
      "diff_hunk": "@@ -0,0 +1,821 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 11,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "a88f033df7a2361c700f205ced6b50d49871c696",
      "in_reply_to_id": 2733994163,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I had proposed a few more changes. Please:\n\n- Rename the Author header to Authors\n- Drop the Comments-URI header\n- Update the Type from Standards Track to Specification",
      "created_at": "2026-01-30T22:03:44Z",
      "updated_at": "2026-01-30T22:03:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2748150992",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748150992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 2,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748157878",
      "pull_request_review_id": 3730614122,
      "id": 2748157878,
      "node_id": "PRRC_kwDOAN28mc6jzY-2",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 4,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\nAuthors: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n```",
      "created_at": "2026-01-30T22:05:37Z",
      "updated_at": "2026-01-30T22:06:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2748157878",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748157878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748158192",
      "pull_request_review_id": 3730614122,
      "id": 2748158192,
      "node_id": "PRRC_kwDOAN28mc6jzZDw",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 5,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n```",
      "created_at": "2026-01-30T22:05:42Z",
      "updated_at": "2026-01-30T22:06:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2748158192",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748158192"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748158998",
      "pull_request_review_id": 3730614122,
      "id": 2748158998,
      "node_id": "PRRC_kwDOAN28mc6jzZQW",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 7,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\nType: Specification\n```",
      "created_at": "2026-01-30T22:05:55Z",
      "updated_at": "2026-01-30T22:06:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2748158998",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748158998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 7,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748159860",
      "pull_request_review_id": 3730614122,
      "id": 2748159860,
      "node_id": "PRRC_kwDOAN28mc6jzZd0",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 8,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\nAssigned: 2026-01-30\n```",
      "created_at": "2026-01-30T22:06:08Z",
      "updated_at": "2026-01-30T22:06:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2748159860",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748159860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748160271",
      "pull_request_review_id": 3730614122,
      "id": 2748160271,
      "node_id": "PRRC_kwDOAN28mc6jzZkP",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 2,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\nBIP: 445\n```",
      "created_at": "2026-01-30T22:06:15Z",
      "updated_at": "2026-01-30T22:06:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2748160271",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2748160271"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2750193415",
      "pull_request_review_id": 3733918058,
      "id": 2750193415,
      "node_id": "PRRC_kwDOAN28mc6j7J8H",
      "diff_hunk": "@@ -0,0 +1,400 @@\n+{\n+    \"n\": 3,\n+    \"t\": 2,\n+    \"threshold_pubkey\": \"03B02645D79ABFC494338139410F9D7F0A72BE86C952D6BDE1A66447B8A8D69237\",\n+    \"secshare_p0\": \"CCD2EF4559DB05635091D80189AB3544D6668EFC0500A8D5FF51A1F4D32CC1F1\",\n+    \"identifiers\": [\n+        0,\n+        1,\n+        2\n+    ],\n+    \"pubshares\": [\n+        \"022B02109FBCFB4DA3F53C7393B22E72A2A51C4AFBF0C01AAF44F73843CFB4B74B\",\n+        \"02EC6444271D791A1DA95300329DB2268611B9C60E193DABFDEE0AA816AE512583\",\n+        \"03113F810F612567D9552F46AF9BDA21A67D52060F95BD4A723F4B60B1820D3676\",\n+        \"020000000000000000000000000000000000000000000000000000000000000007\"\n+    ],\n+    \"msgs\": [\n+        \"F95466D086770E689964664219266FE5ED215C92AE20BAB5C9D79ADDDDF3C0CF\",\n+        \"\",\n+        \"2626262626262626262626262626262626262626262626262626262626262626262626262626\"\n+    ],\n+    \"valid_test_cases\": [\n+        {\n+            \"rand\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"aggothernonce\": \"0353BC2314D46C813AF81317AF1BDF99816B6444E416BB8D3DC04ACB2F5388D1AC02B13BC644F720223B547DB344C94E0F5E769B674D8A9C3F5E86A5231A5B9C3297\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": [\n+                \"02ECF1B7C1C3675E9EC605D95EAFF24CD7A4A0F8DAD89F8A9B6050F78F0C33522103B4368C46B3A9DA59EC52BB1A4B27A0446A302A046E593723E111FECEDE04CC30\",\n+                \"572A5EED305B5533A4EC73D40B4645C5559BF2C137D57F1EBA974DA84B13B8D7\"\n+            ],\n+            \"comment\": \"Signing with minimum number of participants\"\n+        },\n+        {\n+            \"rand\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"aggothernonce\": \"02A8B5F064871F3BBB06D325F5B4A2B51487E0AE24F14E2A121C39B9F7CBDE7474038161382177105511164E63DD2C73138EDB271CF11B922DBA54CA4A9B365EDB55\",\n+            \"id_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubshare_indices\": [\n+                1,\n+                0\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"expected\": [\n+                \"03D1F0BE59DFDC6E9BA09C830FB60B95CA154904F4919D080CF085A86F383EC66E024D3002A880C72187F62A041E01C0A356284C82BA2688DF2CB58B66DF28F75295\",\n+                \"3BEEB13926DAAF6AA6F042FB20B2C33D5887EA8127B94197D8213474DAA1EF49\"\n+            ],\n+            \"comment\": \"Partial-signature shouldn't change if the order of signers set changes. Note: The deterministic sign will generate the same secnonces due to unchanged parameters\"\n+        },\n+        {\n+            \"rand\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"aggothernonce\": \"022260912C9999C9EC5A3B8E493F5DEB76DCA3E772345905E12C24D281612DA403022508B1A355D6E94A5BB239441B38971716031EF05DE9AF952BAB69799621AE52\",\n+            \"id_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                2\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": [\n+                \"03C71C9C0B81BE5F3501553182252266CC935E5D2A900C376CCEC8EDF78BB3F8A903585BF5D830984908F0F3B090CBE8C32B3CCE9719F941B27D7E128F475F22EE14\",\n+                \"62B7FC46552F3E3F3F7B07596FE9E73817A1576F4D0E850015334CE340434CC3\"\n+            ],\n+            \"comment\": \"Partial-signature changes if the members of signers set changes\"\n+        },\n+        {\n+            \"rand\": null,\n+            \"aggothernonce\": \"0220E5B590F7058B5E88593C8635411767B416EB53378AEE7E40CD1D35329AD2C302164F00762CDFFF9138C43884661CC93FF53D61B4BFD3CD2BD7265F41775A4F0F\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": [\n+                \"036BF6DCC0A80061CC2CCA7A8BB20448534BEFDCCB9A2E23714F5AB1112CA3098A03D68C52E4D90D3951B19D3BC3BB7411066F4AAE6F4B91BEC1B811C1CDD38E1D9F\",\n+                \"4F464D1B1F3EF7CABFBC446BBB1D226F82AC56B7DC1DAD4EF7A641E0A8F378FD\"\n+            ],\n+            \"comment\": \"Signing without auxiliary randomness\"\n+        },\n+        {\n+            \"rand\": \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",",
      "path": "bip-0445/python/vectors/det_sign_vectors.json",
      "position": 108,
      "original_position": 108,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": null,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I believe this isn't a valid scalar as per the BIP: \n\nhttps://github.com/bitcoin/bips/blob/ec46a20323840b1a6aba83bc2d18b34dd0811245/bip-frost-signing.md#deterministic-and-stateless-signing-for-a-single-signer\n\n>The auxiliary randomness rand: a 32-byte array, serialized scalar (optional argument)",
      "created_at": "2026-01-31T23:37:09Z",
      "updated_at": "2026-01-31T23:37:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2750193415",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2750193415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 108,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2750737152",
      "pull_request_review_id": 3735215754,
      "id": 2750737152,
      "node_id": "PRRC_kwDOAN28mc6j9OsA",
      "diff_hunk": "@@ -0,0 +1,400 @@\n+{\n+    \"n\": 3,\n+    \"t\": 2,\n+    \"threshold_pubkey\": \"03B02645D79ABFC494338139410F9D7F0A72BE86C952D6BDE1A66447B8A8D69237\",\n+    \"secshare_p0\": \"CCD2EF4559DB05635091D80189AB3544D6668EFC0500A8D5FF51A1F4D32CC1F1\",\n+    \"identifiers\": [\n+        0,\n+        1,\n+        2\n+    ],\n+    \"pubshares\": [\n+        \"022B02109FBCFB4DA3F53C7393B22E72A2A51C4AFBF0C01AAF44F73843CFB4B74B\",\n+        \"02EC6444271D791A1DA95300329DB2268611B9C60E193DABFDEE0AA816AE512583\",\n+        \"03113F810F612567D9552F46AF9BDA21A67D52060F95BD4A723F4B60B1820D3676\",\n+        \"020000000000000000000000000000000000000000000000000000000000000007\"\n+    ],\n+    \"msgs\": [\n+        \"F95466D086770E689964664219266FE5ED215C92AE20BAB5C9D79ADDDDF3C0CF\",\n+        \"\",\n+        \"2626262626262626262626262626262626262626262626262626262626262626262626262626\"\n+    ],\n+    \"valid_test_cases\": [\n+        {\n+            \"rand\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"aggothernonce\": \"0353BC2314D46C813AF81317AF1BDF99816B6444E416BB8D3DC04ACB2F5388D1AC02B13BC644F720223B547DB344C94E0F5E769B674D8A9C3F5E86A5231A5B9C3297\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": [\n+                \"02ECF1B7C1C3675E9EC605D95EAFF24CD7A4A0F8DAD89F8A9B6050F78F0C33522103B4368C46B3A9DA59EC52BB1A4B27A0446A302A046E593723E111FECEDE04CC30\",\n+                \"572A5EED305B5533A4EC73D40B4645C5559BF2C137D57F1EBA974DA84B13B8D7\"\n+            ],\n+            \"comment\": \"Signing with minimum number of participants\"\n+        },\n+        {\n+            \"rand\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"aggothernonce\": \"02A8B5F064871F3BBB06D325F5B4A2B51487E0AE24F14E2A121C39B9F7CBDE7474038161382177105511164E63DD2C73138EDB271CF11B922DBA54CA4A9B365EDB55\",\n+            \"id_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubshare_indices\": [\n+                1,\n+                0\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"expected\": [\n+                \"03D1F0BE59DFDC6E9BA09C830FB60B95CA154904F4919D080CF085A86F383EC66E024D3002A880C72187F62A041E01C0A356284C82BA2688DF2CB58B66DF28F75295\",\n+                \"3BEEB13926DAAF6AA6F042FB20B2C33D5887EA8127B94197D8213474DAA1EF49\"\n+            ],\n+            \"comment\": \"Partial-signature shouldn't change if the order of signers set changes. Note: The deterministic sign will generate the same secnonces due to unchanged parameters\"\n+        },\n+        {\n+            \"rand\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"aggothernonce\": \"022260912C9999C9EC5A3B8E493F5DEB76DCA3E772345905E12C24D281612DA403022508B1A355D6E94A5BB239441B38971716031EF05DE9AF952BAB69799621AE52\",\n+            \"id_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                2\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": [\n+                \"03C71C9C0B81BE5F3501553182252266CC935E5D2A900C376CCEC8EDF78BB3F8A903585BF5D830984908F0F3B090CBE8C32B3CCE9719F941B27D7E128F475F22EE14\",\n+                \"62B7FC46552F3E3F3F7B07596FE9E73817A1576F4D0E850015334CE340434CC3\"\n+            ],\n+            \"comment\": \"Partial-signature changes if the members of signers set changes\"\n+        },\n+        {\n+            \"rand\": null,\n+            \"aggothernonce\": \"0220E5B590F7058B5E88593C8635411767B416EB53378AEE7E40CD1D35329AD2C302164F00762CDFFF9138C43884661CC93FF53D61B4BFD3CD2BD7265F41775A4F0F\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": [\n+                \"036BF6DCC0A80061CC2CCA7A8BB20448534BEFDCCB9A2E23714F5AB1112CA3098A03D68C52E4D90D3951B19D3BC3BB7411066F4AAE6F4B91BEC1B811C1CDD38E1D9F\",\n+                \"4F464D1B1F3EF7CABFBC446BBB1D226F82AC56B7DC1DAD4EF7A641E0A8F378FD\"\n+            ],\n+            \"comment\": \"Signing without auxiliary randomness\"\n+        },\n+        {\n+            \"rand\": \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",",
      "path": "bip-0445/python/vectors/det_sign_vectors.json",
      "position": 108,
      "original_position": 108,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": 2750193415,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yes, the value is not a valid scalar, but it's the BIP text that is incorrect here. `rand` doesn't need to be a scalar, it can be any 32-byte array. I'll update the text. Good catch, thanks!\r\n\r\nIn `DeterministicSign`, `rand` is XORed with `sk` and supplied to a hash function for generating the nonce. We never convert it to a scalar, so it should be okay to allow any 32-byte array.",
      "created_at": "2026-02-01T08:21:49Z",
      "updated_at": "2026-02-01T16:21:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2750737152",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2750737152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 108,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2750931486",
      "pull_request_review_id": 3735408160,
      "id": 2750931486,
      "node_id": "PRRC_kwDOAN28mc6j9-Ie",
      "diff_hunk": "@@ -0,0 +1,400 @@\n+{\n+    \"n\": 3,\n+    \"t\": 2,\n+    \"threshold_pubkey\": \"03B02645D79ABFC494338139410F9D7F0A72BE86C952D6BDE1A66447B8A8D69237\",\n+    \"secshare_p0\": \"CCD2EF4559DB05635091D80189AB3544D6668EFC0500A8D5FF51A1F4D32CC1F1\",\n+    \"identifiers\": [\n+        0,\n+        1,\n+        2\n+    ],\n+    \"pubshares\": [\n+        \"022B02109FBCFB4DA3F53C7393B22E72A2A51C4AFBF0C01AAF44F73843CFB4B74B\",\n+        \"02EC6444271D791A1DA95300329DB2268611B9C60E193DABFDEE0AA816AE512583\",\n+        \"03113F810F612567D9552F46AF9BDA21A67D52060F95BD4A723F4B60B1820D3676\",\n+        \"020000000000000000000000000000000000000000000000000000000000000007\"\n+    ],\n+    \"msgs\": [\n+        \"F95466D086770E689964664219266FE5ED215C92AE20BAB5C9D79ADDDDF3C0CF\",\n+        \"\",\n+        \"2626262626262626262626262626262626262626262626262626262626262626262626262626\"\n+    ],\n+    \"valid_test_cases\": [\n+        {\n+            \"rand\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"aggothernonce\": \"0353BC2314D46C813AF81317AF1BDF99816B6444E416BB8D3DC04ACB2F5388D1AC02B13BC644F720223B547DB344C94E0F5E769B674D8A9C3F5E86A5231A5B9C3297\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": [\n+                \"02ECF1B7C1C3675E9EC605D95EAFF24CD7A4A0F8DAD89F8A9B6050F78F0C33522103B4368C46B3A9DA59EC52BB1A4B27A0446A302A046E593723E111FECEDE04CC30\",\n+                \"572A5EED305B5533A4EC73D40B4645C5559BF2C137D57F1EBA974DA84B13B8D7\"\n+            ],\n+            \"comment\": \"Signing with minimum number of participants\"\n+        },\n+        {\n+            \"rand\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"aggothernonce\": \"02A8B5F064871F3BBB06D325F5B4A2B51487E0AE24F14E2A121C39B9F7CBDE7474038161382177105511164E63DD2C73138EDB271CF11B922DBA54CA4A9B365EDB55\",\n+            \"id_indices\": [\n+                1,\n+                0\n+            ],\n+            \"pubshare_indices\": [\n+                1,\n+                0\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 1,\n+            \"expected\": [\n+                \"03D1F0BE59DFDC6E9BA09C830FB60B95CA154904F4919D080CF085A86F383EC66E024D3002A880C72187F62A041E01C0A356284C82BA2688DF2CB58B66DF28F75295\",\n+                \"3BEEB13926DAAF6AA6F042FB20B2C33D5887EA8127B94197D8213474DAA1EF49\"\n+            ],\n+            \"comment\": \"Partial-signature shouldn't change if the order of signers set changes. Note: The deterministic sign will generate the same secnonces due to unchanged parameters\"\n+        },\n+        {\n+            \"rand\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"aggothernonce\": \"022260912C9999C9EC5A3B8E493F5DEB76DCA3E772345905E12C24D281612DA403022508B1A355D6E94A5BB239441B38971716031EF05DE9AF952BAB69799621AE52\",\n+            \"id_indices\": [\n+                0,\n+                2\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                2\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": [\n+                \"03C71C9C0B81BE5F3501553182252266CC935E5D2A900C376CCEC8EDF78BB3F8A903585BF5D830984908F0F3B090CBE8C32B3CCE9719F941B27D7E128F475F22EE14\",\n+                \"62B7FC46552F3E3F3F7B07596FE9E73817A1576F4D0E850015334CE340434CC3\"\n+            ],\n+            \"comment\": \"Partial-signature changes if the members of signers set changes\"\n+        },\n+        {\n+            \"rand\": null,\n+            \"aggothernonce\": \"0220E5B590F7058B5E88593C8635411767B416EB53378AEE7E40CD1D35329AD2C302164F00762CDFFF9138C43884661CC93FF53D61B4BFD3CD2BD7265F41775A4F0F\",\n+            \"id_indices\": [\n+                0,\n+                1\n+            ],\n+            \"pubshare_indices\": [\n+                0,\n+                1\n+            ],\n+            \"tweaks\": [],\n+            \"is_xonly\": [],\n+            \"msg_index\": 0,\n+            \"signer_index\": 0,\n+            \"expected\": [\n+                \"036BF6DCC0A80061CC2CCA7A8BB20448534BEFDCCB9A2E23714F5AB1112CA3098A03D68C52E4D90D3951B19D3BC3BB7411066F4AAE6F4B91BEC1B811C1CDD38E1D9F\",\n+                \"4F464D1B1F3EF7CABFBC446BBB1D226F82AC56B7DC1DAD4EF7A641E0A8F378FD\"\n+            ],\n+            \"comment\": \"Signing without auxiliary randomness\"\n+        },\n+        {\n+            \"rand\": \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",",
      "path": "bip-0445/python/vectors/det_sign_vectors.json",
      "position": 108,
      "original_position": 108,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": 2750193415,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 289286c.",
      "created_at": "2026-02-01T09:55:50Z",
      "updated_at": "2026-02-01T10:33:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2750931486",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2750931486"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 108,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751026208",
      "pull_request_review_id": 3735508276,
      "id": 2751026208,
      "node_id": "PRRC_kwDOAN28mc6j-VQg",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 2,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": 2748160271,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 289286c9.",
      "created_at": "2026-02-01T10:38:37Z",
      "updated_at": "2026-02-01T10:38:37Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2751026208",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751026208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751026674",
      "pull_request_review_id": 3735508658,
      "id": 2751026674,
      "node_id": "PRRC_kwDOAN28mc6j-VXy",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 8,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": 2748159860,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 289286c9",
      "created_at": "2026-02-01T10:38:45Z",
      "updated_at": "2026-02-01T10:38:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2751026674",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751026674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751026945",
      "pull_request_review_id": 3735508891,
      "id": 2751026945,
      "node_id": "PRRC_kwDOAN28mc6j-VcB",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 7,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": 2748158998,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 289286c9",
      "created_at": "2026-02-01T10:38:51Z",
      "updated_at": "2026-02-01T10:38:51Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2751026945",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751026945"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 7,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751027113",
      "pull_request_review_id": 3735509006,
      "id": 2751027113,
      "node_id": "PRRC_kwDOAN28mc6j-Vep",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 5,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": 2748158192,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 289286c9",
      "created_at": "2026-02-01T10:38:55Z",
      "updated_at": "2026-02-01T10:38:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2751027113",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751027113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751027571",
      "pull_request_review_id": 3735509423,
      "id": 2751027571,
      "node_id": "PRRC_kwDOAN28mc6j-Vlz",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 4,
      "commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "original_commit_id": "5d87f5626edf3885ab258fe7ef3b438814fdeb96",
      "in_reply_to_id": 2748157878,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in 289286c9",
      "created_at": "2026-02-01T10:39:03Z",
      "updated_at": "2026-02-01T10:39:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2751027571",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2751027571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2755999062",
      "pull_request_review_id": 3741555342,
      "id": 2755999062,
      "node_id": "PRRC_kwDOAN28mc6kRTVW",
      "diff_hunk": "@@ -0,0 +1,825 @@\n+```\n+  BIP: 445\n+  Title: FROST Signing Protocol for BIP340 Signatures\n+  Authors: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+  Status: Draft\n+  Type: Specification\n+  Assigned: 2026-01-30\n+  License: CC0-1.0\n+  Discussion: 2024-07-31: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+  Requires: 340\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a *t-of-n* threshold configuration, any *t*[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than *t* participants are corrupted. The signing protocol remains functional provided that at least *t* honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While *t = n* and *t = 1* are in principle supported, simpler alternatives are available in these cases. In the case *t = n*, using a dedicated *n-of-n* multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case *t = 1* can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.",
      "path": "bip-0445.md",
      "position": 28,
      "original_position": 28,
      "commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "original_commit_id": "289286c95bd719cdd0fb3c2d3ad19a64193d614c",
      "in_reply_to_id": null,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm not sure where to best recommend putting this (here, or the tweaking section?) but I think it could be a good idea to mention that this BIP (AFAICT) follows the [tweak handling of BIP327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki#applying-tweaks). \r\n\r\nThis would give people a heads up that you may be able to reuse code from your existing MuSig implementation if you have one.\r\n\r\nWe call it the [\"Tweak Context\"](https://github.com/bitcoin/bips/blob/ec46a20323840b1a6aba83bc2d18b34dd0811245/bip-frost-signing.md#tweak-context) in this BIP. In BIP327, they call it the [\"KeyAgg Context\"](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki#keyagg-context). At minimum, it seems preferable to use the same nomenclature. \r\n\r\nI would guess that this data structure is gonna become more popular as taproot native protocols will have to handle x-only keys - perhaps its worth having a BIP of its own ðŸ¤·â€â™‚ï¸ .",
      "created_at": "2026-02-02T20:15:29Z",
      "updated_at": "2026-02-02T20:20:06Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2755999062",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2755999062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 28,
      "original_line": 28,
      "side": "RIGHT"
    }
  ]
}