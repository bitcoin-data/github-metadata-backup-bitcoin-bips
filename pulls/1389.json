{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1389",
    "id": 1124681288,
    "node_id": "PR_kwDOAN28mc5DCUZI",
    "html_url": "https://github.com/bitcoin/bips/pull/1389",
    "diff_url": "https://github.com/bitcoin/bips/pull/1389.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1389.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1389/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/7d0c08e38acac3ef14095d0e8664c7332b7be381",
    "number": 1389,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "BIP 388: Wallet Policies for Descriptor Wallets",
    "user": {
      "login": "bigspider",
      "id": 6681844,
      "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bigspider",
      "html_url": "https://github.com/bigspider",
      "followers_url": "https://api.github.com/users/bigspider/followers",
      "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
      "organizations_url": "https://api.github.com/users/bigspider/orgs",
      "repos_url": "https://api.github.com/users/bigspider/repos",
      "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/bigspider/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Initial version posted to [bitcoin-dev in May](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html).\r\n\r\nWallet policies are implemented in the [Ledger bitcoin app](https://github.com/LedgerHQ/app-bitcoin-new) (since version 2.1.0).\r\n\r\nThe following PR experimenting with an HWI integration might provide more context and an end-to-end demo:\r\n  - https://github.com/bitcoin-core/HWI/pull/647",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2022-11-16T15:34:23Z",
    "updated_at": "2024-07-10T14:10:05Z",
    "closed_at": "2024-05-08T12:54:43Z",
    "mergeable_state": "unknown",
    "merged_at": "2024-05-08T12:54:43Z",
    "merge_commit_sha": "56575ff5334f98481f310c9ce94c07e7d6a1cdd3",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "bigspider:bip-wallet-policies",
      "ref": "bip-wallet-policies",
      "sha": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 416262417,
        "node_id": "R_kgDOGM-pEQ",
        "name": "bips",
        "full_name": "bigspider/bips",
        "owner": {
          "login": "bigspider",
          "id": 6681844,
          "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
          "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bigspider",
          "html_url": "https://github.com/bigspider",
          "followers_url": "https://api.github.com/users/bigspider/followers",
          "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
          "organizations_url": "https://api.github.com/users/bigspider/orgs",
          "repos_url": "https://api.github.com/users/bigspider/repos",
          "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bigspider/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bigspider/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/bigspider/bips",
        "archive_url": "https://api.github.com/repos/bigspider/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bigspider/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bigspider/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bigspider/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bigspider/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bigspider/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bigspider/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bigspider/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bigspider/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bigspider/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bigspider/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bigspider/bips/downloads",
        "events_url": "https://api.github.com/repos/bigspider/bips/events",
        "forks_url": "https://api.github.com/repos/bigspider/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bigspider/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bigspider/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bigspider/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bigspider/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bigspider/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bigspider/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bigspider/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bigspider/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bigspider/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bigspider/bips/languages",
        "merges_url": "https://api.github.com/repos/bigspider/bips/merges",
        "milestones_url": "https://api.github.com/repos/bigspider/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bigspider/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bigspider/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bigspider/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bigspider/bips.git",
        "stargazers_url": "https://api.github.com/repos/bigspider/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bigspider/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bigspider/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bigspider/bips/subscription",
        "tags_url": "https://api.github.com/repos/bigspider/bips/tags",
        "teams_url": "https://api.github.com/repos/bigspider/bips/teams",
        "trees_url": "https://api.github.com/repos/bigspider/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bigspider/bips.git",
        "hooks_url": "https://api.github.com/repos/bigspider/bips/hooks",
        "svn_url": "https://github.com/bigspider/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 14891,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-10T14:10:05Z",
        "created_at": "2021-10-12T09:08:05Z",
        "updated_at": "2024-07-10T14:04:24Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "c4c5c69bdf260513377929c3748c8c95fe18d9a2",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5306,
        "stargazers_count": 9119,
        "watchers_count": 9119,
        "size": 15112,
        "default_branch": "master",
        "open_issues_count": 43,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-10T08:55:21Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2024-07-10T14:48:58Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 513,
    "deletions": 0,
    "changed_files": 3,
    "commits": 7,
    "review_comments": 81,
    "comments": 22
  },
  "events": [
    {
      "event": "reviewed",
      "id": 1199012337,
      "node_id": "PRR_kwDOAN28mc5Hd3nx",
      "url": null,
      "actor": null,
      "commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Good to see progress on this! Just a small comment about only mentioning Bitcoin Core: i know of several projects using descriptors, and even more of them using descriptors without Miniscript.",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1199012337",
      "submitted_at": "2022-11-30T10:01:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "labeled",
      "id": 8147220601,
      "node_id": "LE_lADOAN28mc5WiQDdzwAAAAHlnLh5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147220601",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T01:34:43Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8342131034,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAHxOtFa",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8342131034",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-24T09:19:45Z"
    },
    {
      "event": "commented",
      "id": 1401619046,
      "node_id": "IC_kwDOAN28mc5TiwJm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1401619046",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-24T09:25:35Z",
      "updated_at": "2023-01-24T09:25:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "In dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c, I added the possibility of using unhardened derivation steps in the key origin information (while keeping the restriction for `change`/`address_index` in the key placeholders).\r\nWhile most wallets use hardened derivations for all but the last two steps, there are deployed use cases with unhardened derivations, and this only adds negligible implementation complexity to wallet policies.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1401619046",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "referenced",
      "id": 8502859196,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAH6z1W8",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8502859196",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "873942a31c00ab2cf6a0f679b763bf053c18db2c",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/873942a31c00ab2cf6a0f679b763bf053c18db2c",
      "created_at": "2023-02-13T10:41:30Z"
    },
    {
      "event": "referenced",
      "id": 8502902787,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAH60AAD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8502902787",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "9883c6ca10fd4fdd5653cdf2281f366a9adfd1db",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/9883c6ca10fd4fdd5653cdf2281f366a9adfd1db",
      "created_at": "2023-02-13T10:46:03Z"
    },
    {
      "event": "reviewed",
      "id": 1295456080,
      "node_id": "PRR_kwDOAN28mc5NNxdQ",
      "url": null,
      "actor": null,
      "commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1295456080",
      "submitted_at": "2023-02-13T11:52:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "reviewed",
      "id": 1300535952,
      "node_id": "PRR_kwDOAN28mc5NhJqQ",
      "url": null,
      "actor": null,
      "commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1300535952",
      "submitted_at": "2023-02-15T23:41:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8568161101,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAH-s8NN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568161101",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:30:09Z"
    },
    {
      "event": "commented",
      "id": 1438086314,
      "node_id": "IC_kwDOAN28mc5Vt3Sq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1438086314",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:05Z",
      "updated_at": "2023-02-21T08:55:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks @jgriffiths and @bucko13 for the reviews!\r\nI addressed most of the comments in da3e117d075f4428f14d4120124d840682e5587d.\r\n\r\nIn bb98f8017a883262e03127ab718514abf4a5e5f9 I deleted the examples coming from HTLC miniscripts; they don't quite make sense as wallet policies.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1438086314",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 8568390758,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAH-t0Rm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390758",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "subscribed",
      "id": 8568390779,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAH-t0R7",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390779",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "mentioned",
      "id": 8568390809,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAH-t0SZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390809",
      "actor": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "subscribed",
      "id": 8568390849,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAH-t0TB",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390849",
      "actor": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "reviewed",
      "id": 1409290224,
      "node_id": "PRR_kwDOAN28mc5UAA_w",
      "url": null,
      "actor": null,
      "commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1409290224",
      "submitted_at": "2023-05-02T14:54:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "reviewed",
      "id": 1409307273,
      "node_id": "PRR_kwDOAN28mc5UAFKJ",
      "url": null,
      "actor": null,
      "commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1409307273",
      "submitted_at": "2023-05-02T15:02:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "reviewed",
      "id": 1476612443,
      "node_id": "PRR_kwDOAN28mc5YA1Fb",
      "url": null,
      "actor": null,
      "commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1476612443",
      "submitted_at": "2023-06-13T08:49:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "referenced",
      "id": 9574418529,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rghh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574418529",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "08845763542f78f068031e66f36b5167d87b6782",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/08845763542f78f068031e66f36b5167d87b6782",
      "created_at": "2023-06-20T03:18:04Z"
    },
    {
      "event": "referenced",
      "id": 9574418538,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rghq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574418538",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "996cb79f357a7304c6ce3477c78e9726592ffc12",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/996cb79f357a7304c6ce3477c78e9726592ffc12",
      "created_at": "2023-06-20T03:18:04Z"
    },
    {
      "event": "referenced",
      "id": 9574425845,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6riT1",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574425845",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "59b047a96f92203a89e22b9cd1adc1fe648cfd43",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/59b047a96f92203a89e22b9cd1adc1fe648cfd43",
      "created_at": "2023-06-20T03:20:17Z"
    },
    {
      "event": "referenced",
      "id": 9574443465,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rmnJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574443465",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "78671aec91f39690a463835670320784815eae4c",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/78671aec91f39690a463835670320784815eae4c",
      "created_at": "2023-06-20T03:25:29Z"
    },
    {
      "event": "referenced",
      "id": 9574449109,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rn_V",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574449109",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0468931b933eb39676ca48f1e5b0a655e6054982",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/0468931b933eb39676ca48f1e5b0a655e6054982",
      "created_at": "2023-06-20T03:27:09Z"
    },
    {
      "event": "referenced",
      "id": 9583233465,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI7NIm5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9583233465",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0a88519fe2ad1e109278e34d20cbf8acd7a4c5ab",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/0a88519fe2ad1e109278e34d20cbf8acd7a4c5ab",
      "created_at": "2023-06-20T18:57:39Z"
    },
    {
      "event": "referenced",
      "id": 9583233496,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI7NInY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9583233496",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4069cb5c352c4f6007b8766972194536cbd005ea",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/4069cb5c352c4f6007b8766972194536cbd005ea",
      "created_at": "2023-06-20T18:57:40Z"
    },
    {
      "event": "referenced",
      "id": 9583687445,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI7O3cV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9583687445",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "808dc7c3ffb925176751129d8f3c8aa452d24f81",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/808dc7c3ffb925176751129d8f3c8aa452d24f81",
      "created_at": "2023-06-20T19:50:51Z"
    },
    {
      "event": "referenced",
      "id": 9671202515,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJActbT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9671202515",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5196443f10052be0ac4317d23f9ad3c422263368",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/5196443f10052be0ac4317d23f9ad3c422263368",
      "created_at": "2023-06-29T00:14:49Z"
    },
    {
      "event": "referenced",
      "id": 9671202524,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJActbc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9671202524",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5625aec043480ea48c9cf6e1a8d6d7ac032008d3",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/5625aec043480ea48c9cf6e1a8d6d7ac032008d3",
      "created_at": "2023-06-29T00:14:49Z"
    },
    {
      "event": "commented",
      "id": 1671755616,
      "node_id": "IC_kwDOAN28mc5jpPdg",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1671755616",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T16:27:39Z",
      "updated_at": "2023-08-09T16:27:39Z",
      "author_association": "MEMBER",
      "body": "@luke-jr can this be assigned a BIP number?",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1671755616",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10049842647,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJXBG3X",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10049842647",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T16:27:40Z"
    },
    {
      "event": "subscribed",
      "id": 10049842660,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJXBG3k",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10049842660",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T16:27:40Z"
    },
    {
      "event": "referenced",
      "id": 10294491363,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJlmXjj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10294491363",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2dff714959917b44043e033469f9d876951bb81a",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/2dff714959917b44043e033469f9d876951bb81a",
      "created_at": "2023-09-06T11:08:33Z"
    },
    {
      "event": "referenced",
      "id": 10306742071,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJmVGc3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10306742071",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8e4fc85ab53883505ed7d65aee4eec25478d98bc",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/8e4fc85ab53883505ed7d65aee4eec25478d98bc",
      "created_at": "2023-09-07T12:21:48Z"
    },
    {
      "event": "commented",
      "id": 1713259908,
      "node_id": "IC_kwDOAN28mc5mHkWE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713259908",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T06:40:59Z",
      "updated_at": "2023-09-11T06:40:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "After @benma suggestion I propose to merge my recent proposal <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-September/021946.html> with this standard. \r\n\r\nSpecifically, I think we can remove unnecessary remaining ambiguity, when multiple keys need to repeat the same data (BIP44 purpose, coin, change derivation path segments) and make descriptors even shorter, more readable and standards, removing key list as a separate structure.\r\n\r\nWhat can be done in this regard:\r\n- Descriptor is equipped with prefix and suffix containing information to reconstruct all shared key components: `wsh/testnet(...)/<0;1>/*#checksum`\r\n- Keys do not list shared components, skipping them: `[f149e757//0h]xpub` (where `0h` is the account number and \"terminal derivation\" from the suffix is appended to all keys, such that they all follow uniform derivation);\r\n- Instead of a separate key list the keys go into the descriptor referenced in full only the first time they appear;\r\n- Each key has an alphanumeric alias, separated using `@`: `alice@[f149e757//0h]xpub`; the same key can be referred to in other descriptor places as `@alice`;\r\n- Keys in different spending paths, when necessary (since in Taproot it is not necessary) are distinguished by an additional derivation path segment called \"branch\". It is a non-hardened index going before the change index: `alice@[f149e757//0h]xpub/1` (which after expansion with prefix and suffix becomes `[f149e757/89h/1h/0h]xpub/1/<0;1>/*`;\r\n\r\nOverall, with these changes, the descriptors will look like\r\n```\r\nwsh/test(or(\r\n    and(alice@[fe569a81//1']xpub1..., bob@[8871bad9//1']xpub2..., carol@[beafcafe//1']xpub3...), \r\n    and(older(1000), thresh(2, @alice, @bob, @carol))\r\n))/<0;1>/*\r\n```\r\n\r\nThe benefits of the proposal are:\r\n- Remove separate key list;\r\n- Use human-readable aliaces;\r\n- Avoid conflicting descriptors using different BIP44 purposes, networks or terminal indexes;\r\n- Separate from previous descriptor standard using new BIP44 purpose value;\r\n- Do not assign new meaning for the change index and make the standard compatible with RGB protocol (which uses change index for specifying derivations containing assigned client-side state or tapret commitments). This also makes wallet implementation easier, helping to clearly understand which indexes to use when deriving external or internal (change) addresses.\r\n\r\nI can work on a PR to this PR to put this proposals into the text.",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713259908",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10329746359,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJns2u3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10329746359",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T06:40:59Z"
    },
    {
      "event": "subscribed",
      "id": 10329746366,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJns2u-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10329746366",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T06:40:59Z"
    },
    {
      "event": "commented",
      "id": 1713337351,
      "node_id": "IC_kwDOAN28mc5mH3QH",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713337351",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T07:40:24Z",
      "updated_at": "2023-09-11T07:40:24Z",
      "author_association": "NONE",
      "body": "> Remove separate key list;\r\n\r\nThe separate key list is very nice though. On the hardware wallets, being able to verify the descriptor without all the xpub/fingerprint/path-prefix noise is much better UX and I think the main purpose of this BIP.\r\n\r\n",
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713337351",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "commented",
      "id": 1713341317,
      "node_id": "IC_kwDOAN28mc5mH4OF",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713341317",
      "actor": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T07:43:12Z",
      "updated_at": "2023-09-11T07:43:12Z",
      "author_association": "NONE",
      "body": "> * Descriptor is equipped with prefix and suffix containing information to reconstruct all shared key components: `wsh/testnet(...)/<0;1>/*#checksum`\r\n\r\nIn my mind including the network identifier outside of the xpub is good from a global pov but bad on the UX pov: you asking all signer vendors/user to change they way of export xpubs.....\r\n\r\n> * Instead of a separate key list the keys go into the descriptor referenced in full only the first time they appear;\r\n\r\nI personally feel that a separate list of keys is more clear/clean to read/use\r\n\r\n> * Each key has an alphanumeric alias, separated using `@`: `alice@[f149e757//0h]xpub`; the same key can be referred to in other descriptor places as `@alice`;\r\n\r\nIn my mind the key should have a numeric alias, this numeric alias can be replaced by some kind of alphanumeric 'mnemonic' by the hardware that handles the display\r\n\r\n> * Keys in different spending paths, when necessary (since in Taproot it is not necessary) are distinguished by an additional derivation path segment called \"branch\". It is a non-hardened index going before the change index: `alice@[f149e757//0h]xpub/1` (which after expansion with prefix and suffix becomes `[f149e757/89h/1h/0h]xpub/1/<0;1>/*`;\r\n\r\nThe 'branch' should be allowed with `@`, it's needed for actual miniscripts.\r\n\r\n\r\nLooks like you forgot to talk about  not limit (or increase limit) the number of change segments to allow you to use `<0;1;9;10>` with RGB\r\n\r\n",
      "user": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713341317",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "commented",
      "id": 1713444950,
      "node_id": "IC_kwDOAN28mc5mIRhW",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713444950",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:34Z",
      "updated_at": "2023-09-11T08:46:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "@benma:\r\n> The separate key list is very nice though. On the hardware wallets, being able to verify the descriptor without all the xpub/fingerprint/path-prefix noise is much better UX and I think the main purpose of this BIP.\r\n\r\nYou are right that displaying that in the UI is terrible. Instead, my understanding is that the descriptor will be parsed by the wallet and the keys and policy will be present in the UI in separate form\r\n\r\n\r\n@pythcoiner:\r\n> I personally feel that a separate list of keys is more clear/clean to read/use\r\n\r\nI am not insisting on merging them; however, to import/export descriptors and pass them between software wallets it will be desirable to have a joined form.\r\n\r\n> In my mind including the network identifier outside of the xpub is good from a global pov but bad on the UX pov: you asking all signer vendors/user to change they way of export xpubs.....\r\n\r\nNo, the xpubs are exported the same way. However, when they are used in the descriptor, their shared parts are moved to prefix/suffix, ensuring they can be combined into the same descriptor (i.e. do not belong to different networks, which is hard to check otherwise).\r\n\r\n> In my mind the key should have a numeric alias, this numeric alias can be replaced by some kind of alphanumeric 'mnemonic' by the hardware that handles the display\r\n\r\nPutting additional requirements on having ints and having them in a strictly incremental manner just bloats validation code with no clear benefits\r\n\r\n> The 'branch' should be allowed with @, it's needed for actual miniscripts.\r\n\r\nOptionally. If not provided with a branch, then each time the key appears the branch number is automatically incremented. This reduces the visual load and size of the descriptor validation code (you can't write it in the wrong way).\r\n",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713444950",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10331085523,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJnx9rT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10331085523",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:34Z"
    },
    {
      "event": "subscribed",
      "id": 10331085538,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJnx9ri",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10331085538",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:34Z"
    },
    {
      "event": "mentioned",
      "id": 10331086798,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJnx9_O",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10331086798",
      "actor": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:42Z"
    },
    {
      "event": "subscribed",
      "id": 10331086809,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJnx9_Z",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10331086809",
      "actor": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:42Z"
    },
    {
      "event": "commented",
      "id": 1713484825,
      "node_id": "IC_kwDOAN28mc5mIbQZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713484825",
      "actor": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T09:11:05Z",
      "updated_at": "2023-09-11T09:11:05Z",
      "author_association": "NONE",
      "body": "> No, the xpubs are exported the same way. However, when they are used in the descriptor, their shared parts are moved to prefix/suffix, ensuring they can be combined into the same descriptor (i.e. do not belong to different networks, which is hard to check otherwise).\r\n\r\nso it's mean the key/xpub a user supply to a wallet/coordinator will look differently than the one in the descriptor, how they can check accurately?\r\n\r\n\r\n\r\n> Putting additional requirements on having ints and having them in a strictly incremental manner just bloats validation code with no clear benefits\r\n\r\nshould we allow arabic/chinese/japanese/koreans/cyrillic/.... alphabets?\r\nthe benefit i found is just KISS, let the fancy stuff optionnaly on the display side, not on the communication side.\r\n\r\n\r\n> Optionally. If not provided with a branch, then each time the key appears the branch number is automatically incremented. This reduces the visual load and size of the descriptor validation code (you can't write it in the wrong way).\r\n\r\ni wonder if the order the key are passed to the miniscript 'compiler_that_is_not_compiler' are the same order in the output descriptor?",
      "user": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713484825",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "commented",
      "id": 1714641245,
      "node_id": "IC_kwDOAN28mc5mM1ld",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1714641245",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T21:58:12Z",
      "updated_at": "2023-09-11T21:59:00Z",
      "author_association": "NONE",
      "body": "@dr-orlovsky I feel like your suggestion would be better as a separate BIP as it appears to have slightly different goals and tradeoffs than this one. I don't think it would be feasible to merge these two proposals without morphing one into the other. If you do this and link it here I'd be happy to provide feedback on that issue or PR.",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1714641245",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10339353132,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJoRgIs",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339353132",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T21:58:13Z"
    },
    {
      "event": "subscribed",
      "id": 10339353142,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJoRgI2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339353142",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T21:58:13Z"
    },
    {
      "event": "comment_deleted",
      "id": 10339730001,
      "node_id": "CDE_lADOAN28mc5WiQDdzwAAAAJoS8JR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339730001",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T23:07:46Z"
    },
    {
      "event": "comment_deleted",
      "id": 10339730435,
      "node_id": "CDE_lADOAN28mc5WiQDdzwAAAAJoS8QD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339730435",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T23:07:50Z"
    },
    {
      "event": "commented",
      "id": 1715275415,
      "node_id": "IC_kwDOAN28mc5mPQaX",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1715275415",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T08:46:21Z",
      "updated_at": "2023-09-12T08:46:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "> * Descriptor is equipped with prefix and suffix containing information to reconstruct all shared key components: `wsh/testnet(...)/<0;1>/*#checksum`\r\n> * Keys do not list shared components, skipping them: `[f149e757//0h]xpub` (where `0h` is the account number and \"terminal derivation\" from the suffix is appended to all keys, such that they all follow uniform derivation);\r\n> * Instead of a separate key list the keys go into the descriptor referenced in full only the first time they appear;\r\n> * Each key has an alphanumeric alias, separated using `@`: `alice@[f149e757//0h]xpub`; the same key can be referred to in other descriptor places as `@alice`;\r\n> * Keys in different spending paths, when necessary (since in Taproot it is not necessary) are distinguished by an additional derivation path segment called \"branch\". It is a non-hardened index going before the change index: `alice@[f149e757//0h]xpub/1` (which after expansion with prefix and suffix becomes `[f149e757/89h/1h/0h]xpub/1/<0;1>/*`;\r\n\r\nThe proposed changes undo most of the design choices of this BIP proposal (like separating the actual keys from the \"descriptor template\" − something I consider a core feature and benefit!), while making the resulting language a lot more incompatible with output descriptor; moreover, it would make parsing a lot more complicated, as parsing a key expression is no longer context-free, because aliases are back-references to the previously-parsed part of the string.\r\n\r\nIn wallet policies, aliases for keys could easily be introduced as additional metadata associated to the elements of the keys information vector.\r\n\r\nThis BIP proposal wants to model in the most minimal way the object that software/hardware wallets (and their users) think of as \"accounts\". Application-specific use cases could be implemented either by building on top of it (if there is a desire / need to stay compatible), or with completely independent approaches.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1715275415",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "reviewed",
      "id": 1621791213,
      "node_id": "PRR_kwDOAN28mc5gqpHt",
      "url": null,
      "actor": null,
      "commit_id": "4b1f826217ab8f99c9484fbd6f1b1f88fa0c3bc0",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1621791213",
      "submitted_at": "2023-09-12T09:40:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "commented",
      "id": 1718020670,
      "node_id": "IC_kwDOAN28mc5mZuo-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1718020670",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:09Z",
      "updated_at": "2023-09-13T17:18:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "@jgriffiths: \r\n\r\n> I feel like your suggestion would be better as a separate BIP as it appears to have slightly different goals and tradeoffs than this one.\r\n\r\nThat was what I began with:\r\n\r\n> After @benma suggestion I propose to merge my recent proposal https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-September/021946.html with this standard.\r\n\r\nand was suggested to merge into this standard\r\n\r\nAnyway, I see that it doesn't fit the hardware wallet devs, so I rest my case. The only part which is essential is to remember that RGB and other client-side-validation may require more derivation indexes in the change segment.",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1718020670",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10362337971,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJppLqz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10362337971",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:10Z"
    },
    {
      "event": "subscribed",
      "id": 10362337983,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJppLq_",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10362337983",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:10Z"
    },
    {
      "event": "mentioned",
      "id": 10362337997,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJppLrN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10362337997",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:10Z"
    },
    {
      "event": "subscribed",
      "id": 10362338009,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJppLrZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10362338009",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:10Z"
    },
    {
      "event": "commented",
      "id": 1734400528,
      "node_id": "IC_kwDOAN28mc5nYNoQ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1734400528",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-25T20:15:30Z",
      "updated_at": "2023-09-25T20:15:30Z",
      "author_association": "NONE",
      "body": "> RGB and other client-side-validation may require more derivation indexes in the change segment.\r\n\r\nIf this doesn't fit the existing patterns or the single derivation case (for example if the solved cardinality of such descriptors is > 2, and/or they contain more than one multi-path expression), I think this can be added as an optional extension as the single derivation case (non-bip44-style) was. As long as every key expression in a policy has the same solved cardinality this should work (disclaimer: I'm not following RGB development).",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1734400528",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "commented",
      "id": 1818792106,
      "node_id": "IC_kwDOAN28mc5saJCq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1818792106",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-20T10:37:58Z",
      "updated_at": "2023-11-20T10:37:58Z",
      "author_association": "NONE",
      "body": "@bigspider Policy support for the Jade HWW is now released as of firmware version 1.0.24 (https://github.com/Blockstream/Jade/releases/tag/1.0.24), if you'd like to update the `Reference Implementation` section.\r\n\r\nJade support is implemented via libwally-core (C/C++/Python/Java/JS) v1.0.0 (https://github.com/ElementsProject/libwally-core/releases/tag/release_1.0.0) if you want to link a general purpose implementation. Both Jade and wally implement the single-path derivation `/*` extension for non-bip44 wallets.\r\n\r\nFrom my POV review is otherwise complete, ACK for this to receive a BIP number and be merged.",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1818792106",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 11010003917,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAKQP1PN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11010003917",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-20T10:37:58Z"
    },
    {
      "event": "subscribed",
      "id": 11010003939,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAKQP1Pj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11010003939",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-20T10:37:58Z"
    },
    {
      "event": "commented",
      "id": 1820680728,
      "node_id": "IC_kwDOAN28mc5shWIY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1820680728",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:51:49Z",
      "updated_at": "2023-11-21T10:51:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the update, @jgriffiths! I added Jade/libwally support in 3c97885, and did a couple of small improvements to the python demo.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1820680728",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 11022703640,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAKRARwY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022703640",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:51:49Z"
    },
    {
      "event": "subscribed",
      "id": 11022703661,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAKRARwt",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022703661",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:51:49Z"
    },
    {
      "event": "commented",
      "id": 1820691997,
      "node_id": "IC_kwDOAN28mc5shY4d",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1820691997",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:58:49Z",
      "updated_at": "2023-11-21T10:58:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "@luke-jr, please let me know if this can be assigned a BIP number, or if something is missing.\r\n\r\nThere are now three hardware signers already using these specs in production.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1820691997",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 11022782668,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAKRAlDM",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022782668",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:58:50Z"
    },
    {
      "event": "subscribed",
      "id": 11022782694,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAKRAlDm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022782694",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:58:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11022847855,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAKRA09v",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022847855",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T11:04:42Z"
    },
    {
      "event": "reviewed",
      "id": 1796535592,
      "node_id": "PRR_kwDOAN28mc5rFPUo",
      "url": null,
      "actor": null,
      "commit_id": "07f0fcf5f4f2f857b03ab77fbc99a33ba1a34325",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Assigned BIP 388",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1796535592",
      "submitted_at": "2023-12-26T18:55:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "renamed",
      "id": 11340813975,
      "node_id": "RTE_lADOAN28mc5WiQDdzwAAAAKj9xaX",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11340813975",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-26T19:18:05Z",
      "rename": {
        "from": "[New BIP] Wallet Policies",
        "to": "BIP 388: Wallet Policies for Descriptor Wallets"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11416016310,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAKocpW2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11416016310",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T10:50:06Z"
    },
    {
      "event": "commented",
      "id": 1880771969,
      "node_id": "IC_kwDOAN28mc5wGk2B",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1880771969",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T10:51:56Z",
      "updated_at": "2024-01-08T11:20:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "I squashed the history, rebased and updated BIP number and type in <del>3bb2cfe4751313470b98c9aaaff9322078fb8e3c</del> d4c650bad3ac190c9106d059b1ed5b110f2660bb.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1880771969",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11416311514,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAKodxba",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11416311514",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T11:18:49Z"
    },
    {
      "event": "commented",
      "id": 1927369947,
      "node_id": "IC_kwDOAN28mc5y4VTb",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1927369947",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-05T16:21:55Z",
      "updated_at": "2024-02-05T16:21:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "@luke-jr, is there any other further change that I missed?\r\n\r\nOtherwise, it would be great to have this merged so I can start linking to it in docs.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1927369947",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 11706600865,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAK5xI2h",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11706600865",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-05T16:21:55Z"
    },
    {
      "event": "subscribed",
      "id": 11706600903,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAK5xI3H",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11706600903",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-05T16:21:56Z"
    },
    {
      "event": "commented",
      "id": 2032123831,
      "node_id": "IC_kwDOAN28mc55H7-3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2032123831",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-02T13:59:25Z",
      "updated_at": "2024-04-02T13:59:25Z",
      "author_association": "MEMBER",
      "body": "@luke-jr could you merge this when you've got a minute?",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-2032123831",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 12326490132,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAALet1AU",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12326490132",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-02T13:59:26Z"
    },
    {
      "event": "subscribed",
      "id": 12326490160,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAALet1Aw",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12326490160",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-02T13:59:26Z"
    },
    {
      "event": "reviewed",
      "id": 2015533272,
      "node_id": "PRR_kwDOAN28mc54IpjY",
      "url": null,
      "actor": null,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "This looks ready for merge to me, although I have a few nits that you might want to address.\r\n\r\nACK d4c650bad3ac190c9106d059b1ed5b110f2660bb\r\n",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-2015533272",
      "submitted_at": "2024-04-22T19:33:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "commented",
      "id": 2070987774,
      "node_id": "IC_kwDOAN28mc57cMP-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2070987774",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-22T21:32:02Z",
      "updated_at": "2024-04-22T21:33:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "I also noticed that this BIP does not have a Rationale section, although it seems to me that the rationale is sufficiently covered in Motivation and Specification (and therefore _no change is necessary_ in that regard).",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-2070987774",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "reviewed",
      "id": 2041001519,
      "node_id": "PRR_kwDOAN28mc55pzYv",
      "url": null,
      "actor": null,
      "commit_id": "84e691bf2b062a59f88dd7bda602ea2c9f43bf1d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "One of the automated checks is failing, because the BIP is not added to the overview table. Please add your BIP to the table in `README.mediawiki`. You can find the expected table entry in the error message of the failed check.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-2041001519",
      "submitted_at": "2024-05-06T15:02:24Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "commented",
      "id": 2096389872,
      "node_id": "IC_kwDOAN28mc589F7w",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2096389872",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-06T15:59:29Z",
      "updated_at": "2024-05-06T15:59:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, it's nice that the check is working now. Here's the entry it suggests:\r\n\r\n```\r\n+> | [[bip-0388.mediawiki|388]]\r\n+> | Applications\r\n+> | Wallet Policies for Descriptor Wallets\r\n+> | Salvatore Ingala\r\n+> | Standard\r\n+> | Draft\r\n+> |-\r\n```\r\n",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-2096389872",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDQ0Nzk4YTJhOWUxOTY0MzA0MGFmNjE4MThhN2FjYjRjZGVkNDdlMDA",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/44798a2a9e19643040af61818a7acb4cded47e00",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/44798a2a9e19643040af61818a7acb4cded47e00",
      "tree": {
        "sha": "dc51a723c3264f2b81639d73ac4979f5da118ed5",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/dc51a723c3264f2b81639d73ac4979f5da118ed5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree dc51a723c3264f2b81639d73ac4979f5da118ed5\nparent c4c5c69bdf260513377929c3748c8c95fe18d9a2\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1662039054 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715072281 +0200\n\nNew BIP: Wallet Policies\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmY57RkACgkQdAYP+Bsz\n5PjCrwwAi11/xe3gSs1dZyAnpJ/WU3qXRrB2EFQE+0hN7LGlKln0CGmr904fcLRY\n2DliCV8Za+G5rThdnFkvbwFZXa301XBcO10EEAh+N1loG9SAkRzaMxGpOiFzml03\nkf7F/bDIi3LW3aubUcTAGN6u7gw8sxrcA5zaxaLWbnHI9fwgdjDorWFlCA6tDL/u\nafpWv1Z9axCPjeOaSDk9jAzA4WNCHT2B1LRrXD2tg023nfJLRbgba9vbaQkFv98p\nr716kajSGCUuLY50vP7HdGBxrFLZIGkK9RmF6vlo/4vNEBhOkzgQLhcNpf3hDm5V\nnH5dF/Cy0DZCnZUu7d5wZeFsjvE+hanZhHFO9LJWhU1Cv1jVYaziVJhkP7/1LcrB\n9GQVDFUAKG99DFFG4RUnabXDQ7L2E6jjkQD1TsUq3sBxv/pU6ANHI0otnxxyOH5n\n8x5oTCiRg20iSL2kynLWD+otW60P79lESWcxMU1B/ORnZYi2UI2LmV5EjY7dlNRG\naGIZ/sTL\n=j7lF\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/c4c5c69bdf260513377929c3748c8c95fe18d9a2",
          "sha": "c4c5c69bdf260513377929c3748c8c95fe18d9a2",
          "html_url": "https://github.com/bitcoin/bips/commit/c4c5c69bdf260513377929c3748c8c95fe18d9a2"
        }
      ],
      "message": "New BIP: Wallet Policies",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T08:58:01Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2022-09-01T13:30:54Z"
      },
      "sha": "44798a2a9e19643040af61818a7acb4cded47e00"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDI1NjU3Y2JlZTY0MWZhNjM5MzZhMDMxMzcwMGMwMDk0NjZjZDU2ZDY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/25657cbee641fa63936a0313700c009466cd56d6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/25657cbee641fa63936a0313700c009466cd56d6",
      "tree": {
        "sha": "dc2f09bfe540d20c530252f8102299c40b3bfa2b",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/dc2f09bfe540d20c530252f8102299c40b3bfa2b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree dc2f09bfe540d20c530252f8102299c40b3bfa2b\nparent 44798a2a9e19643040af61818a7acb4cded47e00\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1704710477 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715072281 +0200\n\nUpdate assigned BIP number; change type to \"Standards Track\"\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmY57RkACgkQdAYP+Bsz\n5PhHpAv9FhzmFzXcBitRsJr02uE/WQp5YwHQK3G5s/eWrKlV1Pk7PliW2KWHPK/O\n1os5rJYTNCf3ySK201lMxBFJo57JkHo7mWXBQvGXRVc3wv+1fnCiQgy6NMi6QFl5\nrtLBp+yoojRYTtDoRTH2l4UZeSzlkSA82jAITDQS97A79YiNO0gwMCT+eM2HzxrD\nORtQM9jl6Qw2yh5elyM1p7dj+1Z5VhI6VousYYEAwwLqwh6yAJF8SlAuE/vMN5KQ\nne2jZKX9UqbKu03nT+lPTIbFoSkh0rLzk0mh7RGIfGmU1ZOFm6SZ2acjirLtzHcM\n3xDFEqn/xoMJC8emx/+IPLdICdPpQoCJo9Z39uwf1i+JzUzkfPxh36vX8Rku80l0\nIG9azyKxDk17pqg/KhhvKcgIoFRhpZtDdW3zllccCQqMFrohWoUf707/TNok5wa1\nFJn/SaHYELjE/TNrtmtUHYSsa69J/wp0BmKWJ9s1zY7lrcJCWnevEk+lko1OV81o\n7ykHmxoA\n=60gd\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/44798a2a9e19643040af61818a7acb4cded47e00",
          "sha": "44798a2a9e19643040af61818a7acb4cded47e00",
          "html_url": "https://github.com/bitcoin/bips/commit/44798a2a9e19643040af61818a7acb4cded47e00"
        }
      ],
      "message": "Update assigned BIP number; change type to \"Standards Track\"",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T08:58:01Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-01-08T10:41:17Z"
      },
      "sha": "25657cbee641fa63936a0313700c009466cd56d6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDQwYzc3NjBkNzgxZTc2MGZlMDFiYjZmZTg2YTc3MzFmNTA2ZGFhMDc",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/40c7760d781e760fe01bb6fe86a7731f506daa07",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/40c7760d781e760fe01bb6fe86a7731f506daa07",
      "tree": {
        "sha": "6d5b968dd4f8057db09171dab0efdf9a5b86b081",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/6d5b968dd4f8057db09171dab0efdf9a5b86b081"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 6d5b968dd4f8057db09171dab0efdf9a5b86b081\nparent 25657cbee641fa63936a0313700c009466cd56d6\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1714927129 -0500\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715072282 +0200\n\nApply suggestions from code review\n\nCo-authored-by: Mark \"Murch\" Erhardt <murch@murch.one>",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmY57RoACgkQdAYP+Bsz\n5PjcSgv9Gg6yrgiaPTt1B/prp4gOBLlKhy3iR0c04swU4DtTQdbpcJMgHEgU2vzF\n49cVH/pNilWkpmF/Fb2yT7cMs1KgsY1mdnsld6nWLJz5019KVvFGvcYdLW1GqGDQ\nDzDdxIMiKcoWhqiKCrNgI2KN+QZeXRuPfUD8ixK/YMxzCCx7abKyhGmbdJp1UP11\nDXdeQ9a9GIe0jvj7AaBV5XjaR+DE7u9vLHr4hVjTgNqJCL/3kyPcpsxBCsLZFCll\nGkHlkwpXoSwJhGO/eF3YwbZpXzdSole83zJgN03oJ3p+piJQbDIyYRruW0EMyasy\nmG9SN6TpzxNDrTZyaqJiFKhoHPZy+o3DOJgBa3EwpvczfKtjwEgK72AI/gXGDSva\nUhl26HE58k8Se1KmuQPRmwbnfTlqBB2lj3Fh0J6whGvWmIOfi+g2lI6eG4k+W4Pm\nSJ83hkbgw3OeJVtz9oCFHQgO0S1Z1OzYHHIs6FNCMsfvuAq0Xs5RToyhIGXWlHQU\nbeRmQWew\n=a/xu\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/25657cbee641fa63936a0313700c009466cd56d6",
          "sha": "25657cbee641fa63936a0313700c009466cd56d6",
          "html_url": "https://github.com/bitcoin/bips/commit/25657cbee641fa63936a0313700c009466cd56d6"
        }
      ],
      "message": "Apply suggestions from code review\n\nCo-authored-by: Mark \"Murch\" Erhardt <murch@murch.one>",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T08:58:02Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-05T16:38:49Z"
      },
      "sha": "40c7760d781e760fe01bb6fe86a7731f506daa07"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDk1Y2Y1MzkxNjExM2E0NDQ4N2UwMzgxMDI5ZDM2MDJlNWJiMWRiNmE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/95cf53916113a44487e0381029d3602e5bb1db6a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/95cf53916113a44487e0381029d3602e5bb1db6a",
      "tree": {
        "sha": "1b41262879413c84fe371ccda36bc7572ed4afcd",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/1b41262879413c84fe371ccda36bc7572ed4afcd"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 1b41262879413c84fe371ccda36bc7572ed4afcd\nparent 40c7760d781e760fe01bb6fe86a7731f506daa07\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715071906 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715072282 +0200\n\nImprovements from PR review.\n\n- Removed large example of taproot policy; replaced with the textual description\n- Added an example of a taproot wallet policy containing miniscript\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmY57RoACgkQdAYP+Bsz\n5Pg7Pgv9F+qikEbW/geGRQtUUc7Yu4qI8y2pRJHykyNXNS38TQ16FE+S1lQfJH1K\ne6VUPD0FzLKZb51Y+6nMLiSbHqwJfbGi3BXoUtJjVaY3lrSAAVX1CBLJzyymGtpH\ngV4V9GSCzsaGNRr23bawtUCde3i9vFfU9eGqEiAyIYjsNNs2lxBWEBQkqIjfJPLu\nU23S1k0JOr9HJapMOCoJuAxHEP2MmSK1skNg7Hc/jpipzISW7Z3VbzoOabNyFWMU\nE8UVPYa9aE5JM78tT/c4yCHXqtNRTA/YU8dLss3uVrsNL83UYQ593+nAbXx3E57A\n/SNXqbtpp97Zqrm8+kMiaYVsYQoLb343Tgofht4b3l23JHaQUCGjSxxIUz8Ygg7W\nIcXclgvsbgt2jRdwOg3NzCVQE/8zao0WxfXTrlhjHsM3aAHJ7LlEsMaes7E6Hpc/\nYICa9S2ebfzhH34+C6cxqyg9F7bV/MkfUivJ55iHUrih+orY/G7jVReEEPLBVcrh\nZD0o4jqz\n=CvXE\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/40c7760d781e760fe01bb6fe86a7731f506daa07",
          "sha": "40c7760d781e760fe01bb6fe86a7731f506daa07",
          "html_url": "https://github.com/bitcoin/bips/commit/40c7760d781e760fe01bb6fe86a7731f506daa07"
        }
      ],
      "message": "Improvements from PR review.\n\n- Removed large example of taproot policy; replaced with the textual description\n- Added an example of a taproot wallet policy containing miniscript",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T08:58:02Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T08:51:46Z"
      },
      "sha": "95cf53916113a44487e0381029d3602e5bb1db6a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGEwYzg1MDFmOTYwYWMyOTg3OGUxMzdjMDNkY2Q2ZDhhM2I5MDk2YjU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "tree": {
        "sha": "2771f3955c5f5dc2aa308f6cdbe122fcbc5ccedb",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/2771f3955c5f5dc2aa308f6cdbe122fcbc5ccedb"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2771f3955c5f5dc2aa308f6cdbe122fcbc5ccedb\nparent 95cf53916113a44487e0381029d3602e5bb1db6a\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715072155 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715072423 +0200\n\nAdded BIP-388 to README\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmY57akACgkQdAYP+Bsz\n5Piy6Av8DAsivH3w3KcQVAqJfkvhSw5rp2KCEuCnYfRExRqWFfAo/sm9NUDCHhZn\nSFg/Bj7F4n/5LgzlR4tOoVdrmyhLA5G+5isj/kJFqupt/p3KrC5ByspewLJnVz7q\nCFGK9kMcJtWyksD8m9q/O2HMHqCpRWGXvF/X9rh/pmQj8bBcM30np6AyU9qy4KgF\nfC0bR2LB4VP79yHzbRFGMBBzafP655L/ZQBiub0LCqB4oQ2TYyBJXhSwb+ONAkZX\n4lRTv81aNrZ5Zdgng0ifKfFThhs/8g1ufJv+yy25302v5hN23ce6mH5h0UunvBav\nTya5PzWrz2IAWKXsFUGdjY4xzC31VzARiqogs+V9z/zq8Tk2ySV29tPOrXSgUsce\nFY6rBvljopGBSPtxoNA8bZtc/0TZp3lp/hZnqP9bTDyNYFZLQM+BNFh1FQEYI68e\nbAdzE6F81UYPPSzH6Dda7rRi5hedSJlm64wAYD+NrK4aUZwWyo+S1I8OlJBDJ4Dp\nl2ZzP2Vj\n=V1pq\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/95cf53916113a44487e0381029d3602e5bb1db6a",
          "sha": "95cf53916113a44487e0381029d3602e5bb1db6a",
          "html_url": "https://github.com/bitcoin/bips/commit/95cf53916113a44487e0381029d3602e5bb1db6a"
        }
      ],
      "message": "Added BIP-388 to README",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T09:00:23Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T08:55:55Z"
      },
      "sha": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12725886706,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAL2hZ7y",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12725886706",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T09:00:51Z"
    },
    {
      "event": "commented",
      "id": 2097811122,
      "node_id": "IC_kwDOAN28mc59Cg6y",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2097811122",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T09:06:25Z",
      "updated_at": "2024-05-07T09:06:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased, and addressed the final comments (thank you!).\r\nPlease let me know if you prefer me to squash the new commits.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-2097811122",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "reviewed",
      "id": 2043264446,
      "node_id": "PRR_kwDOAN28mc55yb2-",
      "url": null,
      "actor": null,
      "commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I did another thorough read and noticed a few style and grammar nits. I did not review the examples or technical details of the proposal. I do not consider any of these comments to be blockers, please feel free to adopt or ignore them at your leisure.\r\n\r\nIt is not necessary to squash the commits, please follow your own preference.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-2043264446",
      "submitted_at": "2024-05-07T14:54:12Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGNmMjI1MGUyN2NjNjgyMjg5ZmFjYzI3ZTFlMmZmMTZlOTRkMTJhYWI",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/cf2250e27cc682289facc27e1e2ff16e94d12aab",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/cf2250e27cc682289facc27e1e2ff16e94d12aab",
      "tree": {
        "sha": "99c129a507efd7598334189c4b2e4e6ae5c36cf1",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/99c129a507efd7598334189c4b2e4e6ae5c36cf1"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 99c129a507efd7598334189c4b2e4e6ae5c36cf1\nparent a0c8501f960ac29878e137c03dcd6d8a3b9096b5\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715112644 +0200\ncommitter GitHub <noreply@github.com> 1715112644 +0200\n\nApply suggestions from code review\n\nCo-authored-by: Mark \"Murch\" Erhardt <murch@murch.one>",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsFcBAABCAAQBQJmOorFCRC1aQ7uu5UhlAAAKbQQAKBwBTo2TAJBiR6DkDX3gRjp\nTT7SCHP0lHVaz5VLrBDjH5MI5ux0W01MjD+ga2fV5pgPGsleYKhAOscRkOJ3rAXu\ndnFea9D9p+BQ8HkoNGcKtdYum6p3OoOZVBs0EQ1gM/r2w6adcNAJXBRFLZ+uUpBA\nx9TeBZLEIdJtVPr1mAypCWH2APBlXnQIcZT5y8Kag9znsLXllGIjpt6cfBymq5q8\naSX2jL6rOOCP9iiNC3lkxTT6QS9cs65Ch/tTVKKroWIsJ72Og9oNYs21wKh3CA3D\nJ5JXq5RnF+p8H/xb9hOY0xA0GvIf/YmJIUYS+0lFHV5t5gQepAfkPCPcedbMYLoG\nzcdfAp4TaN5kZl8gr2vdpffZG4/tt4w3U0foTF+Fc675zCHo6Y0F0eHyj+VMJZut\nuYf1ojl/HH5U/iVv9pKgX5/yadWZnyHFk+3G5C6YPi4STO6Jgkq0EMXfnoZ3xVwY\nOB/aRJ9LyW8wW3DB9V8LDB2D9e8Uk6G9qG07/mih9S8FnpBJ/MeXNzqFECGIgBPk\n3woJ44WxDH8Sejtdt6nd7KUBmmVUNZntgrDnUf58QtlMzpk9U00NDXjmWT2iqLMb\nxo6JcrYpxmUaFGp77Iizks8qVHARPFRkZbXStzUfb3XKmMF32XG0z8N8mRC0U7cP\naQw3zHM1I8IJVJ55NNcC\n=H0M+\n-----END PGP SIGNATURE-----\n"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
          "sha": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
          "html_url": "https://github.com/bitcoin/bips/commit/a0c8501f960ac29878e137c03dcd6d8a3b9096b5"
        }
      ],
      "message": "Apply suggestions from code review\n\nCo-authored-by: Mark \"Murch\" Erhardt <murch@murch.one>",
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2024-05-07T20:10:44Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T20:10:44Z"
      },
      "sha": "cf2250e27cc682289facc27e1e2ff16e94d12aab"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDdkMGMwOGUzOGFjYWMzZWYxNDA5NWQwZTg2NjRjNzMzMmI3YmUzODE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "tree": {
        "sha": "d96a5f25c53c5d8adbf6c02d9113917de62dcd4f",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/d96a5f25c53c5d8adbf6c02d9113917de62dcd4f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree d96a5f25c53c5d8adbf6c02d9113917de62dcd4f\nparent cf2250e27cc682289facc27e1e2ff16e94d12aab\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715113463 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1715113463 +0200\n\nMore nits from PR review\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmY6jfcACgkQdAYP+Bsz\n5PjZiwv/UI9wi0ebicYCeGk4921FRDhbBMTOqu1VUnLnlMm8XfmQo0FFV9uwe8DE\nswApxBkwTJwMxiGDiaxVl//ezLE/ly6LybWKtP13zyv0pTSx42CDjGoi8i9c2OpO\n5oq2PZbdyXK/Gwd+fiRxAwAoOX/h4YQlFTutA0IFo0mZpo/B2nNxUJiRgAGDZFTl\nxJ1lqJnM3s/FluEVFCDVE5D6QIpuBJ4GwVAGP0no8xeDuQ8a99b3wC5XN823xE4d\n49h2Nn6NoC41h9e0tgTASAnNY7/nRuCWWuLsYWtXSLdquHWBSGmCSvJeRDFsbAAi\nAkq0iR4OMDwFonKr419H0n/dmqsQDjVerqMxLs6QnrI6Z1XwPyzpCjHLPGgwtUuy\nOAP4feXczAwvC2KkD8+lV8QUZMMjHwBzh2jWxKvqPEBqKT5Qmc2LS0XwQOMlQQQo\nEnp0C5oWd2p2ULTn15izyeOR3YdnoRizx5Aa5BPEjd2BzvWeGN7l4lydlFs5vbtS\nJS7ds8Kx\n=tLeG\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/cf2250e27cc682289facc27e1e2ff16e94d12aab",
          "sha": "cf2250e27cc682289facc27e1e2ff16e94d12aab",
          "html_url": "https://github.com/bitcoin/bips/commit/cf2250e27cc682289facc27e1e2ff16e94d12aab"
        }
      ],
      "message": "More nits from PR review",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T20:24:23Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-05-07T20:24:23Z"
      },
      "sha": "7d0c08e38acac3ef14095d0e8664c7332b7be381"
    },
    {
      "event": "commented",
      "id": 2099254315,
      "node_id": "IC_kwDOAN28mc59IBQr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2099254315",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T20:30:18Z",
      "updated_at": "2024-05-07T20:30:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks @murchandamus for the thorough suggestions!\r\nI accepted almost all directly, and slightly modified the remaining ones in 7d0c08e38acac3ef14095d0e8664c7332b7be381.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-2099254315",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 12735001244,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAL3ELKc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12735001244",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T20:30:19Z"
    },
    {
      "event": "subscribed",
      "id": 12735001266,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAL3ELKy",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12735001266",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T20:30:19Z"
    },
    {
      "event": "reviewed",
      "id": 2045575983,
      "node_id": "PRR_kwDOAN28mc557QMv",
      "url": null,
      "actor": null,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK [7d0c08e](https://github.com/bitcoin/bips/pull/1389/commits/7d0c08e38acac3ef14095d0e8664c7332b7be381)",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-2045575983",
      "submitted_at": "2024-05-08T12:53:56Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "merged",
      "id": 12743501684,
      "node_id": "ME_lADOAN28mc5WiQDdzwAAAAL3kmd0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12743501684",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "56575ff5334f98481f310c9ce94c07e7d6a1cdd3",
      "commit_url": "https://api.github.com/repos/bitcoin/bips/commits/56575ff5334f98481f310c9ce94c07e7d6a1cdd3",
      "created_at": "2024-05-08T12:54:43Z"
    },
    {
      "event": "closed",
      "id": 12743501732,
      "node_id": "CE_lADOAN28mc5WiQDdzwAAAAL3kmek",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12743501732",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-08T12:54:43Z"
    },
    {
      "event": "head_ref_deleted",
      "id": 13456978133,
      "node_id": "HRDE_lADOAN28mc5WiQDdzwAAAAMiGTDV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/13456978133",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T14:10:05Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035755474",
      "pull_request_review_id": 1199012337,
      "id": 1035755474,
      "node_id": "PRRC_kwDOAN28mc49vF_S",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 30,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": null,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not only in Bitcoin Core?",
      "created_at": "2022-11-30T09:53:14Z",
      "updated_at": "2022-11-30T10:01:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1035755474",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035755474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035758113",
      "pull_request_review_id": 1199012337,
      "id": 1035758113,
      "node_id": "PRRC_kwDOAN28mc49vGoh",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 42,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": null,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ":)",
      "created_at": "2022-11-30T09:55:19Z",
      "updated_at": "2022-11-30T10:01:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1035758113",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035758113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1084997183",
      "pull_request_review_id": 1267102523,
      "id": 1084997183,
      "node_id": "PRRC_kwDOAN28mc5Aq74_",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 42,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035758113,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Still open to suggestions for a less-ambiguous name!",
      "created_at": "2023-01-24T09:17:59Z",
      "updated_at": "2023-01-24T09:18:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1084997183",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1084997183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1085000432",
      "pull_request_review_id": 1267106948,
      "id": 1085000432,
      "node_id": "PRRC_kwDOAN28mc5Aq8rw",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 30,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035755474,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point, changed in 162c675415ef717a599cc899fc4a0b7617710a3e to \"any descriptor-based software wallet\".",
      "created_at": "2023-01-24T09:20:52Z",
      "updated_at": "2023-01-24T09:20:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1085000432",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1085000432"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341047",
      "pull_request_review_id": 1295456080,
      "id": 1104341047,
      "node_id": "PRRC_kwDOAN28mc5B0ug3",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 232,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: `for a complete list.` ?\r\n",
      "created_at": "2023-02-13T11:26:40Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104341047",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341904",
      "pull_request_review_id": 1295456080,
      "id": 1104341904,
      "node_id": "PRRC_kwDOAN28mc5B0uuQ",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 245,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you need to change:\r\n`key_user` -> `@0`\r\n`key_service` -> `@1`\r\n",
      "created_at": "2023-02-13T11:27:30Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104341904",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341904"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104344236",
      "pull_request_review_id": 1295456080,
      "id": 1104344236,
      "node_id": "PRRC_kwDOAN28mc5B0vSs",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(00112233445566778899aabbccddeeff00112233)))))</tt> - BOLT #3 offered HTLC policy.\n+* <tt>wsh(andor(pk(@0/**),or_i(and_v(v:pkh(@1/**),hash160(00112233445566778899aabbccddeeff00112233)),older(1008)),pk(@2/**)))</tt> - BOLT #3 received HTLC policy.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0))\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL))\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0,@1))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: BOLT #3 offered HTLC policy\n+ Descriptor template: wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(t:or_c(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),and_v(v:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),or_c(pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+\n+TBD: add examples with taproot scripts and miniscript.\n+\n+== Backwards Compatibility ==\n+\n+The <tt>@</tt> character used for key placeholders is not part of the syntax of output script descriptors, therefore any valid descriptor template is not a valid descriptor template. Vice versa, any descriptor template with at least one key placeholder is not a valid output script descriptor.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 298,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> therefore any valid descriptor template is not a valid descriptor template\r\n\r\nI think you mean `therefore any valid descriptor is not a valid descriptor template`. Is this because a descriptor template must contain at least one key placeholder? You might want to put that into 'Additional rules' if so.",
      "created_at": "2023-02-13T11:29:48Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104344236",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104344236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104355353",
      "pull_request_review_id": 1295456080,
      "id": 1104355353,
      "node_id": "PRRC_kwDOAN28mc5B0yAZ",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "While `/**` is shorter, it also looks to be easy to mistype/confuse with `/*`. Compare with something like `/+` or `/++` for example.",
      "created_at": "2023-02-13T11:40:47Z",
      "updated_at": "2023-02-13T12:14:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104355353",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104355353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104362160",
      "pull_request_review_id": 1295456080,
      "id": 1104362160,
      "node_id": "PRRC_kwDOAN28mc5B0zqw",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would it not be better to avoid listing the miniscript/descriptor elements that are supported, and just define this bip in terms of :\r\n\r\n1. A change to bip32 `KEY` expressions against miniscript/descriptors; they must be replaced with `@` placeholders\r\n2. Non-bip32 keys (e.g. raw and private keys) are not allowed (not sure if this is specified here)\r\n3. `/**` (or `/+` or whatever is decided on) is used for `<0;1>/*`, and presumably multi-path is disallowed elsewhere.\r\n\r\nGiven that implementations may only support a subset of elements, you might as well open it up to future elements and avoid needing to update this bip.",
      "created_at": "2023-02-13T11:47:25Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104362160",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104362160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853609",
      "pull_request_review_id": 1300535952,
      "id": 1107853609,
      "node_id": "PRRC_kwDOAN28mc5CCIEp",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Possible typo that the last key is `@3` instead of `@2`? ",
      "created_at": "2023-02-15T23:41:04Z",
      "updated_at": "2023-02-15T23:41:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1107853609",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853773",
      "pull_request_review_id": 1300536148,
      "id": 1107853773,
      "node_id": "PRRC_kwDOAN28mc5CCIHN",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1107853609,
      "user": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\r\n```",
      "created_at": "2023-02-15T23:41:20Z",
      "updated_at": "2023-02-15T23:41:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1107853773",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112720880",
      "pull_request_review_id": 1306924111,
      "id": 1112720880,
      "node_id": "PRRC_kwDOAN28mc5CUsXw",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 232,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104341047,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in da3e117d075f4428f14d4120124d840682e5587d with `for complete examples.`",
      "created_at": "2023-02-21T08:32:31Z",
      "updated_at": "2023-02-21T08:32:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112720880",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112720880"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112721484",
      "pull_request_review_id": 1306924894,
      "id": 1112721484,
      "node_id": "PRRC_kwDOAN28mc5CUshM",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 245,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104341904,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in da3e117d075f4428f14d4120124d840682e5587d.",
      "created_at": "2023-02-21T08:33:04Z",
      "updated_at": "2023-02-21T08:33:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112721484",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112721484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112722764",
      "pull_request_review_id": 1306926573,
      "id": 1112722764,
      "node_id": "PRRC_kwDOAN28mc5CUs1M",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(00112233445566778899aabbccddeeff00112233)))))</tt> - BOLT #3 offered HTLC policy.\n+* <tt>wsh(andor(pk(@0/**),or_i(and_v(v:pkh(@1/**),hash160(00112233445566778899aabbccddeeff00112233)),older(1008)),pk(@2/**)))</tt> - BOLT #3 received HTLC policy.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0))\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL))\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0,@1))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: BOLT #3 offered HTLC policy\n+ Descriptor template: wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(t:or_c(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),and_v(v:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),or_c(pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+\n+TBD: add examples with taproot scripts and miniscript.\n+\n+== Backwards Compatibility ==\n+\n+The <tt>@</tt> character used for key placeholders is not part of the syntax of output script descriptors, therefore any valid descriptor template is not a valid descriptor template. Vice versa, any descriptor template with at least one key placeholder is not a valid output script descriptor.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 298,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104344236,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed the sentence and added the additional rule in da3e117d075f4428f14d4120124d840682e5587d.",
      "created_at": "2023-02-21T08:34:10Z",
      "updated_at": "2023-02-21T08:34:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112722764",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112722764"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112737026",
      "pull_request_review_id": 1306946219,
      "id": 1112737026,
      "node_id": "PRRC_kwDOAN28mc5CUwUC",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I prefer `/**` as it has a similar meaning in other languages (and was used in [BIP-0129](https://github.com/bitcoin/bips/blob/master/bip-0129.mediawiki#user-content-Descriptor_Template) for almost the same meaning).\r\n\r\nAs the `/*` alone is invalid for wallet policies, I don't see the risk of confusing it as very dangerous.\r\n\r\nIt's been pointed out in the past that `/**` is redundant since the `/<M;N>/*` expression is already more general, but in practice my expectation is that the vast majority of the use cases will just be happy with using `/**` for all the key expressions (which makes it a lot easier to inspect).\r\nComplex taproot scripts with many leaves might find the `/<M;N>/*` notation more interesting, perhaps.",
      "created_at": "2023-02-21T08:44:18Z",
      "updated_at": "2023-02-21T08:44:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112737026",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112737026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747316",
      "pull_request_review_id": 1306960514,
      "id": 1112747316,
      "node_id": "PRRC_kwDOAN28mc5CUy00",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's an option, indeed.\r\n\r\nI opted for a bottom-up definition (explicitly whitelisting the parts of the descriptor language that we adopt) because there are some inherent incompatibilities, plus it is hard to predict if more will come in the future. For example:\r\n- The `combo` descriptor seems inherently not fitting for wallet policies\r\n- Likewise, extensions like [this](https://github.com/bitcoin/bitcoin/pull/26626) would have to be \"blacklisted\" explicitly\r\n\r\nOn the other hand, the bottom-up approach leaves the exact spec for miniscript descriptors templates in the air, until there is no corresponding BIP...",
      "created_at": "2023-02-21T08:53:08Z",
      "updated_at": "2023-02-21T08:53:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112747316",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747783",
      "pull_request_review_id": 1306961112,
      "id": 1112747783,
      "node_id": "PRRC_kwDOAN28mc5CUy8H",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1107853609,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in da3e117d075f4428f14d4120124d840682e5587d, thanks!",
      "created_at": "2023-02-21T08:53:31Z",
      "updated_at": "2023-02-21T08:53:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112747783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113854499",
      "pull_request_review_id": 1308551027,
      "id": 1113854499,
      "node_id": "PRRC_kwDOAN28mc5CZBIj",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, we have to hope that at some point we stop shoe-horning in descriptor extensions for obsolete cases. Doing so makes a complete implementation prohibitively difficult, makes universal descriptor support less likely, and disincentivizes the eventual/priority movement of coins to modern UTXO/key derivation schemes.\r\n\r\n`combo`, and the linked extension both have in common that they change the cardinality of the solved descriptor. I think you could get the benefit of forward compatibility for this BIP by just stating that final wildcards and multi-path are the only supported key expressions that change cardinality, and all others are forbidden. Then any future extensions to the path syntax, and any expression fragments that return multiple variants would automatically be excluded.",
      "created_at": "2023-02-22T05:30:44Z",
      "updated_at": "2023-02-22T05:30:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1113854499",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113854499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113860887",
      "pull_request_review_id": 1308559709,
      "id": 1113860887,
      "node_id": "PRRC_kwDOAN28mc5CZCsX",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, that's fair enough, I wasn't aware of BIP-0129. I'm OK with `/**` in that case. Given that:\r\n\r\n>It's been pointed out in the past that /** is redundant since the /<M;N>/* expression is already more general\r\n\r\nI think you should disallow `<0;1>/*` within wallet policies and require they be expressed as `/**`. Can't recall if that's already the case.\r\n\r\nIn fact I think you should go further and mandate the hardened indicator be only `'` (or `'h`, but only one or the other) in wallet policies. At the moment, the primary source of descriptor malleability (two textually different descriptors that describe the same thing, but have different checksums) is the key paths (plus no lexicographical sorting in the source `sortedmulti` key expression order). Given that you are replacing the keys with `@n` and enforcing monotonic numbering from left to right, doing the above will make it much simpler to identify standard policies/templates by not requiring all possible variants to be stored and compared. What do you think?\r\n\r\nedit: Forgot about multi-path. You need additionally to state that multi-path extensions of length 3 and greater must be sorted in numerical order.\r\n",
      "created_at": "2023-02-22T05:42:59Z",
      "updated_at": "2023-02-22T05:58:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1113860887",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113860887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113866551",
      "pull_request_review_id": 1308567444,
      "id": 1113866551,
      "node_id": "PRRC_kwDOAN28mc5CZEE3",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 42,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035758113,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the suggestions below to reduce/remove malleability are taken, I'd suggest `wallet patterns` as these strings describe the pattern of derivation without including the keys.",
      "created_at": "2023-02-22T05:52:52Z",
      "updated_at": "2023-02-22T05:52:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1113866551",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113866551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114137256",
      "pull_request_review_id": 1308960513,
      "id": 1114137256,
      "node_id": "PRRC_kwDOAN28mc5CaGKo",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Mandating `'` instead of `h` sounds good to me, but completely fixing malleability is probably a lost battle.\r\nFor example, impossible to make sure are not reused if descriptors are different because of `multi`/`sortedmulti`, as you pointed out. More crucially, you might or might not know the key origin info of some external xpub (although this is only within the key info vector, not in the _descriptor template_).\r\n\r\nI'm not sure about disallowing the `/<M;N>/*` notation; for one thing, it's already adopted for descriptors and used in many multisig wallets. Moreover, I suspect using `<M;N>` other than `0;1` will have use cases: you might have the same root xpub in different spending conditions, but using different values for `M;N`. One use case might be _delegation_: `or(and(Alice1,Bob),and(Alice2,Carl))`: Alice might want to allow Bob to sign, but not Carl, so she only signs with `Alice1`. If only the `/**` notations is present, then the only option for Alice is to use two different xpubs; instead, one could have `or(and(Alice/<0;1>/*,Bob),and(Alice/<2;3>/*, Carl))` and have a single xpub for Alice.",
      "created_at": "2023-02-22T10:32:14Z",
      "updated_at": "2023-02-22T10:32:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114137256",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114137256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114139394",
      "pull_request_review_id": 1308963519,
      "id": 1114139394,
      "node_id": "PRRC_kwDOAN28mc5CaGsC",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "My understanding is that the plan is for extending descriptors liberally, but then implementations can choose which subset to implement. So the bottom-up approach is imho more likely to stay well-defined (but it's certainly more work and will need updates in the future).",
      "created_at": "2023-02-22T10:34:02Z",
      "updated_at": "2023-02-22T10:34:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114139394",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114139394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114182992",
      "pull_request_review_id": 1309028734,
      "id": 1114182992,
      "node_id": "PRRC_kwDOAN28mc5CaRVQ",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> but completely fixing malleability is probably a lost battle.\r\n\r\nAgreed, it wasn't baked in at the start and can't be reliably added now. My goal is just to make sure that the common cases are all represented with the same pattern as much as possible.\r\n\r\n> I'm not sure about disallowing the /<M;N>/* notation\r\n\r\nTo be clear, I'm only suggesting this when M=0 and N=1, not in the general case! its just a simple text substitution much as the hardening indicator would be, that would go a long way to making common patterns trivially identifiable. Agreed that there are use cases for other values here.",
      "created_at": "2023-02-22T11:13:33Z",
      "updated_at": "2023-02-22T11:13:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114182992",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114182992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114186793",
      "pull_request_review_id": 1309033989,
      "id": 1114186793,
      "node_id": "PRRC_kwDOAN28mc5CaSQp",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll leave the approach here to your judgement, since there are arguments for both sides. My view is that descriptors become less useful the more incompatible implementations there are. In wally I'm likely just going to accept anything that looks like a correct pattern as long as it parses and doesn't change the cardinality when solved (assuming this BIP is accepted).",
      "created_at": "2023-02-22T11:17:18Z",
      "updated_at": "2023-02-22T11:17:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114186793",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114186793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182647115",
      "pull_request_review_id": 1409257811,
      "id": 1182647115,
      "node_id": "PRRC_kwDOAN28mc5GfcNL",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 42,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035758113,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I am wondering if `signing policy/pattern` as a name can be useful too. Thinking of constraining outputs to spend to a predefined wallet, which isn't necessarily the wallet that is being spend _from_.\r\n\r\nFor example a policy that only allows spending to cold storage addresses derived from a pre-registered xpub.",
      "created_at": "2023-05-02T14:38:45Z",
      "updated_at": "2023-05-02T15:05:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1182647115",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182647115"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182668361",
      "pull_request_review_id": 1409290224,
      "id": 1182668361,
      "node_id": "PRRC_kwDOAN28mc5GfhZJ",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 214,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": null,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could an alternative to using the `/**` suffix be to separate define the wallet policies for the inputs and outputs? The input policy can then specify `/0/*` and the output policy `/1/*`. Both would still reference the same entry in the key info vector. The added flexibility may also be useful to constrain outputs to a known-but-different wallet.",
      "created_at": "2023-05-02T14:54:22Z",
      "updated_at": "2023-05-02T14:54:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1182668361",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182668361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182679318",
      "pull_request_review_id": 1409307273,
      "id": 1182679318,
      "node_id": "PRRC_kwDOAN28mc5GfkEW",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 198,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": null,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Echoing the discussion in https://github.com/LedgerHQ/app-bitcoin-new/issues/153:\r\n\r\nIt would be great if a wallet policy can support 2-of-2 multisig transactions where one of the keys is ephemeral (completely random). This is useful when using presigned transactions to simulate covenants, for example to implement time-locked vaults.",
      "created_at": "2023-05-02T15:02:34Z",
      "updated_at": "2023-05-02T15:02:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1182679318",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182679318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227756655",
      "pull_request_review_id": 1476595838,
      "id": 1227756655,
      "node_id": "PRRC_kwDOAN28mc5JLhRv",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 214,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1182668361,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe I am misunderstanding you, but: inputs can be /0/* or /1/* (changes can be spent too)",
      "created_at": "2023-06-13T08:40:36Z",
      "updated_at": "2023-06-13T08:40:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1227756655",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227756655"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227768530",
      "pull_request_review_id": 1476612443,
      "id": 1227768530,
      "node_id": "PRRC_kwDOAN28mc5JLkLS",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": null,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The spec above says that the `@N` must always be followed by `/**` or `/<NUM:NUM>/*`, but some examples and test vectors don't have that suffix. \r\n\r\n```\r\n followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\r\n* ''always'' followed by either:\r\n** the string  <tt>/**</tt>, or\r\n...\r\n```\r\n\r\nIs `@0` the same as `@0/**`? Would be good to fix either the specification or the examples/test vectors. ",
      "created_at": "2023-06-13T08:49:08Z",
      "updated_at": "2023-06-13T08:49:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1227768530",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227768530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312907268",
      "pull_request_review_id": 1606764397,
      "id": 1312907268,
      "node_id": "PRRC_kwDOAN28mc5OQWAE",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We have to also allow `/*` following `@n` (i.e. a single asterisk instead of two), since not all wallets use 0/1 paths to differentiate change addresses.\r\n\r\nI'm OK with `@n` alone expanding to `@0/**` but this does add even more malleability to expressions. Regardless, the `always` section should be updated to allow single asterisks.",
      "created_at": "2023-09-01T11:23:35Z",
      "updated_at": "2023-09-01T11:23:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1312907268",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312907268"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316058847",
      "pull_request_review_id": 1611317016,
      "id": 1316058847,
      "node_id": "PRRC_kwDOAN28mc5OcXbf",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The naked `@N` was an oversight, I don't think it should be allowed as it would be confusing (Ledger's implementation doesn't permit it). I will fix it.\r\n\r\n--\r\n\r\nIf we generalize the suffix to expressions other than `<0;1>/*`, then we have to make sure that no pubkey is repeated.\r\nIn practice, for `/*`, that would mean that _all_ the placeholders must be followed by the exact suffix `/*`.\r\n\r\nOut of curiosity, what software wallets use that scheme?",
      "created_at": "2023-09-05T15:22:10Z",
      "updated_at": "2023-09-05T15:22:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1316058847",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316058847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316487474",
      "pull_request_review_id": 1612042278,
      "id": 1316487474,
      "node_id": "PRRC_kwDOAN28mc5OeAEy",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> If we generalize the suffix to expressions other than <0;1>/*\r\n\r\nI'm not sure I follow. I'm not suggesting generalizing the suffix, at least in the sense of allowing general path expressions to be used as suffixes. I'm saying the only key expression suffixes that should be allowed are `/**`, `/<m;n>/*` and `/*`.\r\n\r\n> If we generalize the suffix to expressions other than <0;1>/*, then we have to make sure that no pubkey is repeated.\r\n\r\nI assume you mean here that a key expression could be given as `[/a/b/c]foo/**` and then elsewhere as `[/a/b/c/0]bar/*` and/or `[/a/b/c/1]bar/*` giving rise to the same derived keys with different key identifiers.\r\n\r\n> In practice, for /*, that would mean that all the placeholders must be followed by the exact suffix /*\r\n\r\nFor a given key expression, yes. I'm fine with supporting `/*` being optional, and if present the implementation must ensure this.\r\n\r\nNote also that at present this BIP does not state that implementations must ensure that `KP` expressions refer to distinct keys when substituting them into a policy, although that appears to be a requirement. I think it would also be clearer to state that all key expressions in a policy must be replaced by `KP` expressions (i.e. that no non-`KP` keys are allowed).\r\n\r\nAlso missing are that `<m;n>` expressions should be numerically sorted, and that explicit `<0;1>` should be disallowed.\r\n\r\nI'm happy to make individual commits with suggested changes for the above for you to review/cherry-pick. Should I create a PR against your repo for this?.\r\n\r\n> Out of curiosity, what software wallets use that scheme?\r\n\r\nBlockstream Green multisig wallets do not use bip44 style paths (the wallet predates the BIP). Also descriptors themselves do not enforce bip44 derivation.",
      "created_at": "2023-09-05T22:36:40Z",
      "updated_at": "2023-09-05T22:36:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1316487474",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316487474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316995686",
      "pull_request_review_id": 1612884030,
      "id": 1316995686,
      "node_id": "PRRC_kwDOAN28mc5Of8Jm",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I'm not sure I follow. I'm not suggesting generalizing the suffix, at least in the sense of allowing general path expressions to be used as suffixes. I'm saying the only key expression suffixes that should be allowed are `/**`, `/<m;n>/*` and `/*`.\r\n\r\nWhat I mean is that if we allow mixing things like  `@0/*` with `@1/<m;n>/*`, then we for the xpub of `@1` we would need to derive `@1/m` and `@1/n` and compare with the pubkey of the xpub in `@0`, which is quite expensive on a hardware wallet.\r\n\r\nWith no mixing, for any two placeholders like `@0/<m;n>/*` and `@0/<p;q>/*`, I can just check that the sets `{m, n}` and `{p, q}` are disjoint.\r\n\r\n> For a given key expression, yes. I'm fine with supporting `/*` being optional, and if present the implementation must ensure this.\r\n\r\nNot just _for a given key expression_, I mean it across the entire wallet policy. That is, either the KPs all end with `/*`, or they all end with some `/<NUM;NUM>/*`.\r\n\r\n> Note also that at present this BIP does not state that implementations must ensure that `KP` expressions refer to distinct keys when substituting them into a policy, although that appears to be a requirement.\r\n\r\nGood point, worth adding explicitly the \"Additional rules\", with the motivation that it's required in miniscript (and it's simpler to add this restriction globally, rather than on the individual miniscript parts of the policy).\r\n\r\nSo basically:\r\n- all the public keys (deserialized from the corresponding xpubs in the keys information vector) must be distinct\r\n- all the derivations in each KP expression referring to the same index in the keys information vector must be distinct\r\n\r\nIn order to allow optional extensions like `/*`, perhaps I could mention that possibility in a separate section?\r\n\r\n> I think it would also be clearer to state that all key expressions in a policy must be replaced by `KP` expressions (i.e. that no non-`KP` keys are allowed).\r\n\r\nA wallet policy is the pair `(descriptor_template, keys_information_vector)`, so not sure what you mean here. The grammar seems to specify exactly what are the allowed KP and KEY expressions, as far as I can tell.\r\n\r\n> Also missing are that `<m;n>` expressions should be numerically sorted, and that explicit `<0;1>` should be disallowed.\r\n\r\nI like suggesting to sort `<m;n>` numerically, but not sure about disallowing `<0;1>`. I expect people to prefer not mixing `@0/**` with `@0/<2;3>/*`, as it's more explicit in that case to just write `@0/<0;1>/*`.\r\n\r\n> I'm happy to make individual commits with suggested changes for the above for you to review/cherry-pick. Should I create a PR against your repo for this?.\r\n\r\nSure, feel free to propose changes, but I'll try to incorporate the comments now. I'm also hoping to find the time for a general pass over the whole document to improve the Motivation section, as that was written before the BtcPrague meeting and it can surely be improved in hindsight.",
      "created_at": "2023-09-06T09:17:22Z",
      "updated_at": "2023-09-06T09:17:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1316995686",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316995686"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317001469",
      "pull_request_review_id": 1612892796,
      "id": 1317001469,
      "node_id": "PRRC_kwDOAN28mc5Of9j9",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I like suggesting to sort <m;n> numerically, but not sure about disallowing <0;1>. I expect people to prefer not mixing @0/** with @0/<2;3>/*, as it's more explicit in that case to just write @0/<0;1>/*.\r\n\r\nWhat's the reason for sorting? It's not mentioned in [BIP-389](https://github.com/bitcoin/bips/blob/master/bip-0389.mediawiki).\r\n\r\n+1 to keep allowing `<0;1>/*` for readability for the reason you stated.",
      "created_at": "2023-09-06T09:21:57Z",
      "updated_at": "2023-09-06T09:21:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317001469",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317001469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317058627",
      "pull_request_review_id": 1612981459,
      "id": 1317058627,
      "node_id": "PRRC_kwDOAN28mc5OgLhD",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Not just for a given key expression, I mean it across the entire wallet policy.\r\n\r\nOK, I understand where you are coming from now. Enforcing this across the entire policy is sensible (no-one should be mixing key expressions with different cardinalities), and its pretty easy to implement.\r\n\r\n> So basically:\r\n\r\nYes these 2 two points are whats missing IMO.\r\n\r\n> perhaps I could mention that possibility in a separate section?\r\n\r\nSure, that works, let me know if you'd like me to draft it or if you are happy to.\r\n\r\n> The grammar seems to specify exactly what are the allowed KP and KEY expressions, as far as I can tell.\r\n\r\nThis is true, I just prefer being more explicit. Feel free to ignore this if you disagree.\r\n\r\n> I expect people to prefer not mixing\r\n> +1 to keep allowing <0;1>/* for readability\r\n\r\nNo doubt its slightly better for human readability in the rare case where alternate multipath derivations are given. But its bad for comparing two such policies (or checking against a whitelist of supported policies) because it's another source of malleability. It also complicates logic to convert a descriptor to a human friendly policy automatically, because substitution of `/<0;1>/*` for `/**` as recommended in this BIP will not result in the human friendly format in this case. Complicated policies are far more likely to be automatically generated than human written, and so in practice I suspect the large majority will end up mixing `/**` and `/<M;N>/*` anyway. However its your decision.\r\n\r\n> What's the reason for sorting?\r\n\r\nMalleability and ease of comparing multipaths. Unfortunately 389 states that the meaning of all n=2 multipaths is fixed (receive addresses and change), and so sorting is probably not possible to enforce given some hypothetical wallet out there could use descending numbers for this purpose.\r\n\r\n>  It's not mentioned in BIP-389\r\n\r\nTrue, but we limit multipaths to length 2 in policies which is also not part of 389.",
      "created_at": "2023-09-06T10:10:37Z",
      "updated_at": "2023-09-06T10:12:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317058627",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317058627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317077214",
      "pull_request_review_id": 1613010541,
      "id": 1317077214,
      "node_id": "PRRC_kwDOAN28mc5OgQDe",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Unfortunately 389 states that the meaning of all n=2 multipaths is fixed (receive addresses and change), and so sorting is probably not possible \r\n\r\nI was actually thinking primarily about this case and wondered why one would restrict people from using receive and change indices to be ordered.\r\n\r\n> Malleability and ease of comparing multipaths.\r\n\r\n`/<1;2;3>*` is not the same as `<3;2;1>/*`, so why should they be compared or treated to be the same? Applications may assign meaning to the position (similar to receive and change with two elements).\r\n\r\nIn practice it probably does not matter much, but I wouldn't impose this restriction here.\r\n\r\n> Blockstream Green multisig wallets do not use bip44 style paths (the wallet predates the BIP). \r\n\r\nOut of curiosity, how does Green identify which UTXOs are change?",
      "created_at": "2023-09-06T10:28:23Z",
      "updated_at": "2023-09-06T10:28:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317077214",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317077214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317295697",
      "pull_request_review_id": 1613358030,
      "id": 1317295697,
      "node_id": "PRRC_kwDOAN28mc5OhFZR",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As per this discussion:\r\n- 3ade41fc6bc12461388f34d5aebe9ba60a008704 makes the rules on distinct pubkeys explicit;\r\n- 0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc adds a section for the optional additional derivations, pointing out the potential footguns I could think of.\r\n\r\nI didn't add any requirement/suggestion to sort `<m;n>` expressions. Thanks for the comments, and feel free to suggest further changes, of course!",
      "created_at": "2023-09-06T13:34:33Z",
      "updated_at": "2023-09-06T13:34:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317295697",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317295697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317822961",
      "pull_request_review_id": 1614200216,
      "id": 1317822961,
      "node_id": "PRRC_kwDOAN28mc5OjGHx",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@bigspider Thanks!\r\n\r\nComments on the current state:\r\n1. under `** a string of the form` there should be a new bullet point stating that any path expression as listed in the `Optional derivation paths` is optionally allowed.\r\n2. There still appear to be some bare `@n` references in the test vectors (e.g. multisig).\r\n3. The `Why must public keys be distinct?` reference doesn't appear to point anywhere. Do you have a reference to any docs/discussion on pubkey reuse in miniscript this can link to?\r\n4. Some invalid test vectors would be helpful for implementors to check against (see below).\r\n\r\nI'm fully implementing the BIP in wally now, and may have some further comments once that work is complete.\r\n\r\nSuggested invalid test vectors:\r\n1. `pkh(@0)` Key with no following path\r\n2. `pkh(@0/0/*)` Key with an explicit path present\r\n3. `sh(multi(1,@1/**,@0/**))` Keys used out of order\r\n5. `sh(multi(1,@0/**,@0/**))` Repeated keys w/same path expression\r\n6. `sh(multi(1,@0/<0;1>/*,@0/<1;2>/*))` Non-disjoint multipath expressions\r\n7. `sh(multi(1,@0/**,xpub6AHA9hZDN11k2ijHMeS5QqHx2KP9aMBRhTDqANMnwVtdyw2TDYRmF8PjpvwUFcL1Et8Hj59S3gTSMcUQ5gAqTz3Wd8EsMTmF3DChhqPQBnU/<0;1>/*))` Expression with a non `KP` key present\r\n8. `pkh(@0/<0;1;2>/*)` Solved cardinality > 2\r\n9. `combo(@0/**)` Disallowed expression type/Solved cardinality > 2",
      "created_at": "2023-09-06T20:54:07Z",
      "updated_at": "2023-09-11T22:26:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317822961",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317822961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317854062",
      "pull_request_review_id": 1614248571,
      "id": 1317854062,
      "node_id": "PRRC_kwDOAN28mc5OjNtu",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@benma \r\n\r\nnote slightly O/T to this BIP.\r\n\r\n> why one would restrict people from using receive and change indices to be ordered.\r\n> /<1;2;3>* is not the same as <3;2;1>/*, so why should they be compared or treated to be the same? Applications may assign meaning to the position (similar to receive and change with two elements).\r\n\r\nThey are the same assuming no other paths appear in the same expression; they both result in the same set of solutions, just in a different order. Of course this is not true with multiple keys: `<1;2;3>` and `<4;5;6>` have different solutions to `<3;2;1>` and `<4;5;6>` due to the stepwise resolution through path elements when generating the solutions. But in the single case its a cause of expression malleability.\r\n\r\nNote that ordering of expressions is not explicitly specified anywhere other than this stepwise derivation, and no meaning can be inferred except in the n=2 case (where all n=2 cases must be considered as receive/change even if this is not the intention). Consider expressions like `combo` or new extensions like explicit key lists. In what order is `combo(<key>/<1;2;3>/*)` solved, paths iterated first or the combo variants for each path?\r\n\r\nAs per my comments on the BIP the addition of extensions that change cardinality and the non-specification of ordering for N>3 means that we have the worst of all worlds: proscribed meaning for one case that prevents general use of N=2, and no ability to state anything about all the meaning of solutions when other expressions that change cardinality are present. Enforcing ordering and describing the expansion order of expressions would not have been onerous but would have allowed implementations to process them consistently instead of needing whitelists/understanding specific patterns.\r\n\r\n> In practice it probably does not matter much, but I wouldn't impose this restriction here.\r\n\r\nAgreed, this ship along with other malleability concerns has unfortunately sailed. Although it would be nice to enforce `'` rather than `h` for hardening in policies at least, @bigspider?\r\n\r\n> Out of curiosity, how does Green identify which UTXOs are change?\r\n\r\nFor singlesig wallets we use bip44 like everyone else, although you can't rely on the internal/external paths only for change detection, since its possible to create txs using either. For multisig we don't explicitly track change, the backend computes limits etc based on the net effect on the wallet, and displaying change is based on a simple check of the txs outputs (one output only to the wallet = redeposit, non-wallet output plus wallet output = payment and change etc).",
      "created_at": "2023-09-06T21:29:15Z",
      "updated_at": "2023-09-06T21:29:16Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317854062",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317854062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1318784475",
      "pull_request_review_id": 1615717273,
      "id": 1318784475,
      "node_id": "PRRC_kwDOAN28mc5Omw3b",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Agreed, this ship along with other malleability concerns has unfortunately sailed. Although it would be nice to enforce `'` rather than `h` for hardening in policies at least, @bigspider?\r\n\r\nI agree; Ledger's implementation only allows `'` (choice mostly because it looks better on a small screen).\r\nThe current specs indeed don't mention `h`.\r\n\r\nI'll go over the other comments (and add the failure cases, thanks!) next week.",
      "created_at": "2023-09-07T15:29:48Z",
      "updated_at": "2023-09-07T15:29:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1318784475",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1318784475"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322638320",
      "pull_request_review_id": 1621616177,
      "id": 1322638320,
      "node_id": "PRRC_kwDOAN28mc5O1dvw",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4b1f826217ab8f99c9484fbd6f1b1f88fa0c3bc0 should address all the remaining comments from this thread, thanks @jgriffiths!\r\n \r\n> Suggested invalid test vectors:\r\n> \r\n> 5. `sh(multi(1,@0/<0;1>/*,@1/<1;2>/*))` Non-disjoint multipath expressions\r\n\r\nThis is actually valid as <tt>@0</tt> and <tt>@1</tt> are independent; added an example where both are <tt>@0</tt> instead.",
      "created_at": "2023-09-12T08:22:02Z",
      "updated_at": "2023-09-12T08:22:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1322638320",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322638320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322706403",
      "pull_request_review_id": 1621709359,
      "id": 1322706403,
      "node_id": "PRRC_kwDOAN28mc5O1uXj",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For the miniscript reference, I suppose https://bitcoin.sipa.be/miniscript/ is the only one, although the mention of separate keys is quite [buried in the page](https://bitcoin.sipa.be/miniscript/#:~:text=We%20restrict%20this,using%20separate%20keys.) in the section on malleability.",
      "created_at": "2023-09-12T08:56:33Z",
      "updated_at": "2023-09-12T08:56:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1322706403",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322706403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322758217",
      "pull_request_review_id": 1621791213,
      "id": 1322758217,
      "node_id": "PRRC_kwDOAN28mc5O17BJ",
      "diff_hunk": "@@ -298,6 +301,21 @@ Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3\n \n TBD: add examples with taproot scripts and miniscript.\n \n+=== Invalid policies ===\n+\n+The following descriptor templates are invalid:\n+\n+* <tt>pkh(@0)</tt>: Key placeholder with no path following it\n+* <tt>pkh(@0/0/*)</tt>: Key placeholder with an explicit path present",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 65,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "4b1f826217ab8f99c9484fbd6f1b1f88fa0c3bc0",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This needs to change to `**` from `*` to be a valid case for the non-extended BIP (my bad, sorry).",
      "created_at": "2023-09-12T09:36:37Z",
      "updated_at": "2023-09-12T09:40:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1322758217",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322758217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322774345",
      "pull_request_review_id": 1621816086,
      "id": 1322774345,
      "node_id": "PRRC_kwDOAN28mc5O1-9J",
      "diff_hunk": "@@ -298,6 +301,21 @@ Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3\n \n TBD: add examples with taproot scripts and miniscript.\n \n+=== Invalid policies ===\n+\n+The following descriptor templates are invalid:\n+\n+* <tt>pkh(@0)</tt>: Key placeholder with no path following it\n+* <tt>pkh(@0/0/*)</tt>: Key placeholder with an explicit path present",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 65,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "4b1f826217ab8f99c9484fbd6f1b1f88fa0c3bc0",
      "in_reply_to_id": 1322758217,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right! Fixed in 6f98026a2fd27069446fdfcabdfbaad6450b3e23.",
      "created_at": "2023-09-12T09:49:49Z",
      "updated_at": "2023-09-12T09:49:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1322774345",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322774345"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1323565174",
      "pull_request_review_id": 1623131558,
      "id": 1323565174,
      "node_id": "PRRC_kwDOAN28mc5O5AB2",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@bigspider Thanks!\r\n\r\nThe wally implementation (https://github.com/ElementsProject/libwally-core/pull/369) is now complete and is being tested for addition to Jade. Once merged it would be good to add to the implementations section. At this stage it looks like this BIP has support in 3 HWW so getting a BIP number assigned should not be an issue.\r\n\r\nIt would be good IMO to squash all commits at this stage. I'll do a final review following wally code review and Jade testing. Many thanks for your responsiveness in addressing review comments.",
      "created_at": "2023-09-12T21:01:37Z",
      "updated_at": "2023-09-12T21:01:37Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1323565174",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1323565174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1336347383",
      "pull_request_review_id": 1642922706,
      "id": 1336347383,
      "node_id": "PRRC_kwDOAN28mc5Ppwr3",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "FYI policy support has been merged into wally now and support in Jade is now being tested.",
      "created_at": "2023-09-25T20:17:11Z",
      "updated_at": "2023-09-25T20:17:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1336347383",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1336347383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1436574890",
      "pull_request_review_id": 1796535592,
      "id": 1436574890,
      "node_id": "PRRC_kwDOAN28mc5VoGSq",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 9,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "07f0fcf5f4f2f857b03ab77fbc99a33ba1a34325",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this is supposed to be Standards Track.",
      "created_at": "2023-12-26T18:50:22Z",
      "updated_at": "2023-12-26T18:55:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1436574890",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1436574890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 9,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1449133515",
      "pull_request_review_id": 1816033751,
      "id": 1449133515,
      "node_id": "PRRC_kwDOAN28mc5WYAXL",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 9,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "07f0fcf5f4f2f857b03ab77fbc99a33ba1a34325",
      "in_reply_to_id": 1436574890,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Changed in d4c650bad3ac190c9106d059b1ed5b110f2660bb.",
      "created_at": "2024-01-11T16:46:50Z",
      "updated_at": "2024-01-11T16:46:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1449133515",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1449133515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 9,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575200342",
      "pull_request_review_id": 2015533272,
      "id": 1575200342,
      "node_id": "PRRC_kwDOAN28mc5d46ZW",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 67,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nDesigning a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\r\n```",
      "created_at": "2024-04-22T18:29:01Z",
      "updated_at": "2024-04-22T19:33:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1575200342",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575200342"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575253779",
      "pull_request_review_id": 2015533272,
      "id": 1575253779,
      "node_id": "PRRC_kwDOAN28mc5d5HcT",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 140,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This example is hard to access since the format it uses is only introduced later in the Specification section.",
      "created_at": "2024-04-22T19:19:07Z",
      "updated_at": "2024-04-22T19:33:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1575253779",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575253779"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": 103,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575254891",
      "pull_request_review_id": 2015533272,
      "id": 1575254891,
      "node_id": "PRRC_kwDOAN28mc5d5Htr",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\n+\n+If two key placeholders are <tt>@i/<M;N>/*</tt> and <tt>@i/<P;Q>/*</tt> for the same index <tt>i</tt>, then the sets <tt>{M, N}</tt> and <tt>{P, Q}</tt> must be disjoint.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+=== Optional derivation paths ===\n+\n+In order to allow supporting legacy derivation schemes (for example, using simply <tt>/*</tt> instead of the more common <tt>/<M;N>/*</tt> scheme most software wallets use today), or other schemes that are not covered in this document, implementations might choose to permit additional derivation patterns for the key placeholder (<tt>KP</tt>) expressions.\n+\n+However, care needs to be taken in view of the following considerations:\n+\n+* Allowing derivation schemes with a different length or cardinality in the same wallet policy would make it difficult to guarantee that there are no repeated pubkeys for every possible address generated by the policy. For example, `@0/<0;1>/*` and `@1/*` would generate the same pubkeys if the second public key in the keys information vector is one of the first two unhardened children of the first public key. This could cause malleability with potential security implications (for example, in policies containing miniscript).\n+* Allowing naked pubkeys with no <tt>/*</tt> suffix (for example a descriptor template like <tt>wsh(multi(2,@0,@1/<0;1>/*))</tt>) would cause a pubkey to be repeated in every output generated from the policy, which would result in a total loss of privacy.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0/**,@1/**))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0/**,@1/**,@2/**))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0/**),or_d(pk(@1/**),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+=== Valid policies ===\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0/**)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0/**))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0/**)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0/**)\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL)\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0/**,@1/**))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+\n+TBD: add examples with taproot scripts and miniscript.\n+\n+=== Invalid policies ===\n+\n+The following descriptor templates are invalid:\n+\n+* <tt>pkh(@0)</tt>: Key placeholder with no path following it\n+* <tt>pkh(@0/0/**)</tt>: Key placeholder with an explicit path present\n+* <tt>sh(multi(1,@1/**,@0/**))</tt>: Key placeholders out of order\n+* <tt>sh(multi(1,@0/**,@2/**))</tt>: Skipped key placeholder <tt>@1</tt>\n+* <tt>sh(multi(1,@0/**,@0/**))</tt>: Repeated keys with the same path expression\n+* <tt>sh(multi(1,@0/<0;1>/*,@0/<1;2>/*))</tt>: Non-disjoint multipath expressions (<tt>@0/1/*</tt> appears twice)\n+* <tt>sh(multi(1,@0/**,xpub6AHA9hZDN11k2ijHMeS5QqHx2KP9aMBRhTDqANMnwVtdyw2TDYRmF8PjpvwUFcL1Et8Hj59S3gTSMcUQ5gAqTz3Wd8EsMTmF3DChhqPQBnU/<0;1>/*))</tt>: Expression with a non KP key present\n+* <tt>pkh(@0/<0;1;2>/*)</tt>: Solved cardinality > 2\n+\n+Remark: some of the descriptor templates above might be valid if optional extensions allowing them are added in the implementation.\n+\n+== Backwards Compatibility ==\n+\n+The <tt>@</tt> character used for key placeholders is not part of the syntax of output script descriptors, therefore any valid output descriptor with at least one `KEY` expression is not a valid descriptor template. Vice versa, any descriptor template with at least one key placeholder is not a valid output script descriptor.\n+\n+Adoption of wallet policies in software and harder wallets is opt-in. Conversion from wallet policies to the corresponding descriptors is programmatically extremely easy, and conversion from descriptors to wallet policies (when respecting the required patterns) can be automated. See the reference implementation below for some examples of conversion.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 323,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nAdoption of wallet policies in software and hardware wallets is opt-in. Conversion from wallet policies to the corresponding descriptors is programmatically extremely easy, and conversion from descriptors to wallet policies (when respecting the required patterns) can be automated. See the reference implementation below for some examples of conversion.\r\n```",
      "created_at": "2024-04-22T19:20:19Z",
      "updated_at": "2024-04-22T19:33:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1575254891",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575254891"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 323,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575260361",
      "pull_request_review_id": 2015533272,
      "id": 1575260361,
      "node_id": "PRRC_kwDOAN28mc5d5JDJ",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\n+\n+If two key placeholders are <tt>@i/<M;N>/*</tt> and <tt>@i/<P;Q>/*</tt> for the same index <tt>i</tt>, then the sets <tt>{M, N}</tt> and <tt>{P, Q}</tt> must be disjoint.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+=== Optional derivation paths ===\n+\n+In order to allow supporting legacy derivation schemes (for example, using simply <tt>/*</tt> instead of the more common <tt>/<M;N>/*</tt> scheme most software wallets use today), or other schemes that are not covered in this document, implementations might choose to permit additional derivation patterns for the key placeholder (<tt>KP</tt>) expressions.\n+\n+However, care needs to be taken in view of the following considerations:\n+\n+* Allowing derivation schemes with a different length or cardinality in the same wallet policy would make it difficult to guarantee that there are no repeated pubkeys for every possible address generated by the policy. For example, `@0/<0;1>/*` and `@1/*` would generate the same pubkeys if the second public key in the keys information vector is one of the first two unhardened children of the first public key. This could cause malleability with potential security implications (for example, in policies containing miniscript).\n+* Allowing naked pubkeys with no <tt>/*</tt> suffix (for example a descriptor template like <tt>wsh(multi(2,@0,@1/<0;1>/*))</tt>) would cause a pubkey to be repeated in every output generated from the policy, which would result in a total loss of privacy.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0/**,@1/**))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0/**,@1/**,@2/**))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0/**),or_d(pk(@1/**),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+=== Valid policies ===\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0/**)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0/**))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0/**)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0/**)\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL)\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0/**,@1/**))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+\n+TBD: add examples with taproot scripts and miniscript.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 302,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This looks like an open todo.",
      "created_at": "2024-04-22T19:26:06Z",
      "updated_at": "2024-04-22T19:33:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1575260361",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575260361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575264672",
      "pull_request_review_id": 2015533272,
      "id": 1575264672,
      "node_id": "PRRC_kwDOAN28mc5d5KGg",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause",
      "path": "bip-0388.mediawiki",
      "position": 11,
      "original_position": 11,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Please include the post history (please add other references if there were more threads):\r\n\r\n```suggestion\r\n  License: BSD-2-Clause\r\n  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\r\n```",
      "created_at": "2024-04-22T19:30:53Z",
      "updated_at": "2024-04-22T21:31:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1575264672",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1575264672"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 11,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592079195",
      "pull_request_review_id": 2042525963,
      "id": 1592079195,
      "node_id": "PRRC_kwDOAN28mc5e5TNb",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\n+\n+If two key placeholders are <tt>@i/<M;N>/*</tt> and <tt>@i/<P;Q>/*</tt> for the same index <tt>i</tt>, then the sets <tt>{M, N}</tt> and <tt>{P, Q}</tt> must be disjoint.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+=== Optional derivation paths ===\n+\n+In order to allow supporting legacy derivation schemes (for example, using simply <tt>/*</tt> instead of the more common <tt>/<M;N>/*</tt> scheme most software wallets use today), or other schemes that are not covered in this document, implementations might choose to permit additional derivation patterns for the key placeholder (<tt>KP</tt>) expressions.\n+\n+However, care needs to be taken in view of the following considerations:\n+\n+* Allowing derivation schemes with a different length or cardinality in the same wallet policy would make it difficult to guarantee that there are no repeated pubkeys for every possible address generated by the policy. For example, `@0/<0;1>/*` and `@1/*` would generate the same pubkeys if the second public key in the keys information vector is one of the first two unhardened children of the first public key. This could cause malleability with potential security implications (for example, in policies containing miniscript).\n+* Allowing naked pubkeys with no <tt>/*</tt> suffix (for example a descriptor template like <tt>wsh(multi(2,@0,@1/<0;1>/*))</tt>) would cause a pubkey to be repeated in every output generated from the policy, which would result in a total loss of privacy.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0/**,@1/**))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0/**,@1/**,@2/**))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0/**),or_d(pk(@1/**),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+=== Valid policies ===\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0/**)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0/**))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0/**)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0/**)\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL)\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0/**,@1/**))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+\n+TBD: add examples with taproot scripts and miniscript.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 302,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "in_reply_to_id": 1575260361,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed; added a taproot example in 95cf53916113a44487e0381029d3602e5bb1db6a.",
      "created_at": "2024-05-07T09:02:35Z",
      "updated_at": "2024-05-07T09:02:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592079195",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592079195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592081227",
      "pull_request_review_id": 2042529394,
      "id": 1592081227,
      "node_id": "PRRC_kwDOAN28mc5e5TtL",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 140,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "in_reply_to_id": 1575253779,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agreed; moreover, plus this is using `musig` which is not even part of the standard. A text description is probably sufficient: 95cf53916113a44487e0381029d3602e5bb1db6a.",
      "created_at": "2024-05-07T09:04:07Z",
      "updated_at": "2024-05-07T09:04:07Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592081227",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592081227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": 103,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592525812",
      "pull_request_review_id": 2043264446,
      "id": 1592525812,
      "node_id": "PRRC_kwDOAN28mc5e7AP0",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 164,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nThe public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the context of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\r\n```",
      "created_at": "2024-05-07T13:52:44Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592525812",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592525812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592535075",
      "pull_request_review_id": 2043264446,
      "id": 1592535075,
      "node_id": "PRRC_kwDOAN28mc5e7Cgj",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 17,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I found the first sentence a bit long and hard to parse. Perhaps the following is better, or it would be easier to read if it were split into two sentences.\r\n\r\n```suggestion\r\nWallet policies build on top of output descriptors to represent the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device, in a compact, reviewable way. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\r\n```",
      "created_at": "2024-05-07T13:58:30Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592535075",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592535075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592538002",
      "pull_request_review_id": 2043264446,
      "id": 1592538002,
      "node_id": "PRRC_kwDOAN28mc5e7DOS",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 19,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How about using the active voice and switching around the two subsentences?\r\n\r\n```suggestion\r\nWe simplify the language to suit devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle, by reducing the generality of descriptors to just the essential features and by separating the extended pubkeys and other key information from the descriptor.\r\n```",
      "created_at": "2024-05-07T14:00:21Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592538002",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592538002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 19,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592540121",
      "pull_request_review_id": 2043264446,
      "id": 1592540121,
      "node_id": "PRRC_kwDOAN28mc5e7DvZ",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 21,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How about:\r\n\r\n```suggestion\r\nThis results in a more compact representation and simplifies the inspection of the policy by the user.\r\n```",
      "created_at": "2024-05-07T14:01:45Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592540121",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592540121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 21,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592542724",
      "pull_request_review_id": 2043264446,
      "id": 1592542724,
      "node_id": "PRRC_kwDOAN28mc5e7EYE",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 23,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems easier to read to me:\r\n\r\n```suggestion\r\nThe compilation of wallet policies to the corresponding descriptor is trivial, and the reverse process is easy for supported descriptors, because the language is kept similar to that of output script descriptors.\r\n```",
      "created_at": "2024-05-07T14:03:26Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592542724",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592542724"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592545076",
      "pull_request_review_id": 2043264446,
      "id": 1592545076,
      "node_id": "PRRC_kwDOAN28mc5e7E80",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 17,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also, you use sometimes \"output script descriptor\", \"output descriptor\", and just \"descriptor\" to mean the same thing. Perhaps you should introduce it once as \"output script descriptor (abbreviated with 'descriptor' in the following)\".\r\n",
      "created_at": "2024-05-07T14:04:57Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592545076",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592545076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592546776",
      "pull_request_review_id": 2043264446,
      "id": 1592546776,
      "node_id": "PRRC_kwDOAN28mc5e7FXY",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 31,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in Bitcoin Core as a way to represent collections of output scripts. It is a general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\r\n```",
      "created_at": "2024-05-07T14:06:01Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592546776",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592546776"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592547246",
      "pull_request_review_id": 2043264446,
      "id": 1592547246,
      "node_id": "PRRC_kwDOAN28mc5e7Feu",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 33,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nUnfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running Bitcoin Core:\r\n```",
      "created_at": "2024-05-07T14:06:19Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592547246",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592547246"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592549251",
      "pull_request_review_id": 2043264446,
      "id": 1592549251,
      "node_id": "PRRC_kwDOAN28mc5e7F-D",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 39,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nMoreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the amount of information shown on-screen is important for a good user experience. The ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is crucial for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\r\n```",
      "created_at": "2024-05-07T14:07:40Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592549251",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592549251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592554612",
      "pull_request_review_id": 2043264446,
      "id": 1592554612,
      "node_id": "PRRC_kwDOAN28mc5e7HR0",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 41,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Missing word, and \"the UX of software wallets using descriptors to represent software wallets using descriptors\" feels like you accidentally repeated something here.\r\n\r\n```suggestion\r\nA more native, compact representation of the wallet receive and change addresses might also benefit the UX of software wallets when they use descriptors (possibly with miniscript) for representing complex locking conditions.\r\n```",
      "created_at": "2024-05-07T14:11:10Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592554612",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592554612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592556986",
      "pull_request_review_id": 2043264446,
      "id": 1592556986,
      "node_id": "PRRC_kwDOAN28mc5e7H26",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 47,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nThe usage of complex scripts presents challenges in terms of both security and user experience for a hardware signing device.\r\n```",
      "created_at": "2024-05-07T14:12:44Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592556986",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592556986"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592558992",
      "pull_request_review_id": 2043264446,
      "id": 1592558992,
      "node_id": "PRRC_kwDOAN28mc5e7IWQ",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 51,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This sentence could be simplified as follows:\r\n\r\n```suggestion\r\nHardware signing devices strive to guarantee that no action can be performed without the user’s consent as long as the user correctly verifies the information that is shown on the device’s screen before approving.\r\n```",
      "created_at": "2024-05-07T14:14:04Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592558992",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592558992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592566508",
      "pull_request_review_id": 2043264446,
      "id": 1592566508,
      "node_id": "PRRC_kwDOAN28mc5e7KLs",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 62,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nMiniscript (and taproot trees) allow substantially more complex spending policies. It is a challenge to ensure that the user can practically verify such spending policies per the screen.\r\n```",
      "created_at": "2024-05-07T14:18:58Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592566508",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592566508"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592578752",
      "pull_request_review_id": 2043264446,
      "id": 1592578752,
      "node_id": "PRRC_kwDOAN28mc5e7NLA",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 64,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nWe set two fundamental design goals:\r\n```",
      "created_at": "2024-05-07T14:25:49Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592578752",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592578752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592585137",
      "pull_request_review_id": 2043264446,
      "id": 1592585137,
      "node_id": "PRRC_kwDOAN28mc5e7Oux",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 104,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"Moving\" feels odd here, how about:\r\n\r\n```suggestion\r\nReplacing the common part of the key with a short key placeholder and presenting the key expression helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\r\n```",
      "created_at": "2024-05-07T14:28:59Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592585137",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592585137"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592586981",
      "pull_request_review_id": 2043264446,
      "id": 1592586981,
      "node_id": "PRRC_kwDOAN28mc5e7PLl",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 147,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nNote: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization), it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\r\n```",
      "created_at": "2024-05-07T14:29:56Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592586981",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592586981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592588492",
      "pull_request_review_id": 2043264446,
      "id": 1592588492,
      "node_id": "PRRC_kwDOAN28mc5e7PjM",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 164,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nThe public keys obtained by deserializing elements of the key information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\r\n```",
      "created_at": "2024-05-07T14:30:43Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592588492",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592588492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592591548",
      "pull_request_review_id": 2043264446,
      "id": 1592591548,
      "node_id": "PRRC_kwDOAN28mc5e7QS8",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\n+\n+If two key placeholders are <tt>@i/<M;N>/*</tt> and <tt>@i/<P;Q>/*</tt> for the same index <tt>i</tt>, then the sets <tt>{M, N}</tt> and <tt>{P, Q}</tt> must be disjoint.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 168,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Grammar, and I think there is a missing `<tt>` here:\r\n\r\n```suggestion\r\nThe key information vector should be ordered so that placeholder <tt>@i</tt> never appears for the first time before an occurrence of <tt>@j</tt>  for some <tt>j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\r\n```",
      "created_at": "2024-05-07T14:32:13Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592591548",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592591548"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592602270",
      "pull_request_review_id": 2043264446,
      "id": 1592602270,
      "node_id": "PRRC_kwDOAN28mc5e7S6e",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\n+\n+If two key placeholders are <tt>@i/<M;N>/*</tt> and <tt>@i/<P;Q>/*</tt> for the same index <tt>i</tt>, then the sets <tt>{M, N}</tt> and <tt>{P, Q}</tt> must be disjoint.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 186,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I find this sentence confusing because in specifications following RFC 2119 \"MUST NOT\" is used to express a prohibition. It seems to me that you mean \"do not need to\" here. How about:\r\n\r\n```suggestion\r\nIt is acceptable to implement only a subset of the possible wallet policies defined by this standard. It is recommended that any limitations are clearly documented.\r\n```",
      "created_at": "2024-05-07T14:37:48Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592602270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592602270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592619387",
      "pull_request_review_id": 2043264446,
      "id": 1592619387,
      "node_id": "PRRC_kwDOAN28mc5e7XF7",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\n+\n+If two key placeholders are <tt>@i/<M;N>/*</tt> and <tt>@i/<P;Q>/*</tt> for the same index <tt>i</tt>, then the sets <tt>{M, N}</tt> and <tt>{P, Q}</tt> must be disjoint.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+=== Optional derivation paths ===\n+\n+In order to allow supporting legacy derivation schemes (for example, using simply <tt>/*</tt> instead of the more common <tt>/<M;N>/*</tt> scheme most software wallets use today), or other schemes that are not covered in this document, implementations might choose to permit additional derivation patterns for the key placeholder (<tt>KP</tt>) expressions.\n+\n+However, care needs to be taken in view of the following considerations:\n+\n+* Allowing derivation schemes with a different length or cardinality in the same wallet policy would make it difficult to guarantee that there are no repeated pubkeys for every possible address generated by the policy. For example, `@0/<0;1>/*` and `@1/*` would generate the same pubkeys if the second public key in the keys information vector is one of the first two unhardened children of the first public key. This could cause malleability with potential security implications (for example, in policies containing miniscript).\n+* Allowing naked pubkeys with no <tt>/*</tt> suffix (for example a descriptor template like <tt>wsh(multi(2,@0,@1/<0;1>/*))</tt>) would cause a pubkey to be repeated in every output generated from the policy, which would result in a total loss of privacy.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0/**,@1/**))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0/**,@1/**,@2/**))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0/**),or_d(pk(@1/**),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+=== Valid policies ===\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0/**)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0/**))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0/**)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0/**)\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL)\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0/**,@1/**))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+Taproot wallet policy with sortedmulti_a and a miniscript leaf\n+ Descriptor template: tr(@0/**,{sortedmulti_a(1,@0/<2;3>/*,@1/**),or_b(pk(@2/**),s:pk(@3/**))})\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"xpub6Fc2TRaCWNgfT49nRGG2G78d1dPnjhW66gEXi7oYZML7qEFN8e21b2DLDipTZZnfV6V7ivrMkvh4VbnHY2ChHTS9qM3XVLJiAgcfagYQk6K\", \"xpub6GxHB9kRdFfTqYka8tgtX9Gh3Td3A9XS8uakUGVcJ9NGZ1uLrGZrRVr67DjpMNCHprZmVmceFTY4X4wWfksy8nVwPiNvzJ5pjLxzPtpnfEM\", \"xpub6GjFUVVYewLj5no5uoNKCWuyWhQ1rKGvV8DgXBG9Uc6DvAKxt2dhrj1EZFrTNB5qxAoBkVW3wF8uCS3q1ri9fueAa6y7heFTcf27Q4gyeh6\"]\n+ Descriptor:tr([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0;1>/*,{sortedmulti_a(1,xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<2;3>/*,xpub6Fc2TRaCWNgfT49nRGG2G78d1dPnjhW66gEXi7oYZML7qEFN8e21b2DLDipTZZnfV6V7ivrMkvh4VbnHY2ChHTS9qM3XVLJiAgcfagYQk6K/<0;1>/*),or_b(pk(xpub6GxHB9kRdFfTqYka8tgtX9Gh3Td3A9XS8uakUGVcJ9NGZ1uLrGZrRVr67DjpMNCHprZmVmceFTY4X4wWfksy8nVwPiNvzJ5pjLxzPtpnfEM/<0;1>/*),s:pk(xpub6GjFUVVYewLj5no5uoNKCWuyWhQ1rKGvV8DgXBG9Uc6DvAKxt2dhrj1EZFrTNB5qxAoBkVW3wF8uCS3q1ri9fueAa6y7heFTcf27Q4gyeh6/<0;1>/*))})\n+<br>\n+\n+=== Invalid policies ===\n+\n+The following descriptor templates are invalid:\n+\n+* <tt>pkh(@0)</tt>: Key placeholder with no path following it\n+* <tt>pkh(@0/0/**)</tt>: Key placeholder with an explicit path present\n+* <tt>sh(multi(1,@1/**,@0/**))</tt>: Key placeholders out of order\n+* <tt>sh(multi(1,@0/**,@2/**))</tt>: Skipped key placeholder <tt>@1</tt>\n+* <tt>sh(multi(1,@0/**,@0/**))</tt>: Repeated keys with the same path expression\n+* <tt>sh(multi(1,@0/<0;1>/*,@0/<1;2>/*))</tt>: Non-disjoint multipath expressions (<tt>@0/1/*</tt> appears twice)\n+* <tt>sh(multi(1,@0/**,xpub6AHA9hZDN11k2ijHMeS5QqHx2KP9aMBRhTDqANMnwVtdyw2TDYRmF8PjpvwUFcL1Et8Hj59S3gTSMcUQ5gAqTz3Wd8EsMTmF3DChhqPQBnU/<0;1>/*))</tt>: Expression with a non KP key present",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 277,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* <tt>sh(multi(1,@0/**,xpub6AHA9hZDN11k2ijHMeS5QqHx2KP9aMBRhTDqANMnwVtdyw2TDYRmF8PjpvwUFcL1Et8Hj59S3gTSMcUQ5gAqTz3Wd8EsMTmF3DChhqPQBnU/<0;1>/*))</tt>: Expression with a non-KP key present\r\n```",
      "created_at": "2024-05-07T14:46:36Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592619387",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592619387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592623927",
      "pull_request_review_id": 2043264446,
      "id": 1592623927,
      "node_id": "PRRC_kwDOAN28mc5e7YM3",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\n+\n+If two key placeholders are <tt>@i/<M;N>/*</tt> and <tt>@i/<P;Q>/*</tt> for the same index <tt>i</tt>, then the sets <tt>{M, N}</tt> and <tt>{P, Q}</tt> must be disjoint.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+=== Optional derivation paths ===\n+\n+In order to allow supporting legacy derivation schemes (for example, using simply <tt>/*</tt> instead of the more common <tt>/<M;N>/*</tt> scheme most software wallets use today), or other schemes that are not covered in this document, implementations might choose to permit additional derivation patterns for the key placeholder (<tt>KP</tt>) expressions.\n+\n+However, care needs to be taken in view of the following considerations:\n+\n+* Allowing derivation schemes with a different length or cardinality in the same wallet policy would make it difficult to guarantee that there are no repeated pubkeys for every possible address generated by the policy. For example, `@0/<0;1>/*` and `@1/*` would generate the same pubkeys if the second public key in the keys information vector is one of the first two unhardened children of the first public key. This could cause malleability with potential security implications (for example, in policies containing miniscript).\n+* Allowing naked pubkeys with no <tt>/*</tt> suffix (for example a descriptor template like <tt>wsh(multi(2,@0,@1/<0;1>/*))</tt>) would cause a pubkey to be repeated in every output generated from the policy, which would result in a total loss of privacy.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0/**,@1/**))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0/**,@1/**,@2/**))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0/**),or_d(pk(@1/**),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+=== Valid policies ===\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0/**)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0/**))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0/**)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0/**)\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL)\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0/**,@1/**))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+Taproot wallet policy with sortedmulti_a and a miniscript leaf\n+ Descriptor template: tr(@0/**,{sortedmulti_a(1,@0/<2;3>/*,@1/**),or_b(pk(@2/**),s:pk(@3/**))})\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"xpub6Fc2TRaCWNgfT49nRGG2G78d1dPnjhW66gEXi7oYZML7qEFN8e21b2DLDipTZZnfV6V7ivrMkvh4VbnHY2ChHTS9qM3XVLJiAgcfagYQk6K\", \"xpub6GxHB9kRdFfTqYka8tgtX9Gh3Td3A9XS8uakUGVcJ9NGZ1uLrGZrRVr67DjpMNCHprZmVmceFTY4X4wWfksy8nVwPiNvzJ5pjLxzPtpnfEM\", \"xpub6GjFUVVYewLj5no5uoNKCWuyWhQ1rKGvV8DgXBG9Uc6DvAKxt2dhrj1EZFrTNB5qxAoBkVW3wF8uCS3q1ri9fueAa6y7heFTcf27Q4gyeh6\"]\n+ Descriptor:tr([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0;1>/*,{sortedmulti_a(1,xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<2;3>/*,xpub6Fc2TRaCWNgfT49nRGG2G78d1dPnjhW66gEXi7oYZML7qEFN8e21b2DLDipTZZnfV6V7ivrMkvh4VbnHY2ChHTS9qM3XVLJiAgcfagYQk6K/<0;1>/*),or_b(pk(xpub6GxHB9kRdFfTqYka8tgtX9Gh3Td3A9XS8uakUGVcJ9NGZ1uLrGZrRVr67DjpMNCHprZmVmceFTY4X4wWfksy8nVwPiNvzJ5pjLxzPtpnfEM/<0;1>/*),s:pk(xpub6GjFUVVYewLj5no5uoNKCWuyWhQ1rKGvV8DgXBG9Uc6DvAKxt2dhrj1EZFrTNB5qxAoBkVW3wF8uCS3q1ri9fueAa6y7heFTcf27Q4gyeh6/<0;1>/*))})\n+<br>\n+\n+=== Invalid policies ===\n+\n+The following descriptor templates are invalid:\n+\n+* <tt>pkh(@0)</tt>: Key placeholder with no path following it\n+* <tt>pkh(@0/0/**)</tt>: Key placeholder with an explicit path present\n+* <tt>sh(multi(1,@1/**,@0/**))</tt>: Key placeholders out of order\n+* <tt>sh(multi(1,@0/**,@2/**))</tt>: Skipped key placeholder <tt>@1</tt>\n+* <tt>sh(multi(1,@0/**,@0/**))</tt>: Repeated keys with the same path expression\n+* <tt>sh(multi(1,@0/<0;1>/*,@0/<1;2>/*))</tt>: Non-disjoint multipath expressions (<tt>@0/1/*</tt> appears twice)\n+* <tt>sh(multi(1,@0/**,xpub6AHA9hZDN11k2ijHMeS5QqHx2KP9aMBRhTDqANMnwVtdyw2TDYRmF8PjpvwUFcL1Et8Hj59S3gTSMcUQ5gAqTz3Wd8EsMTmF3DChhqPQBnU/<0;1>/*))</tt>: Expression with a non KP key present\n+* <tt>pkh(@0/<0;1;2>/*)</tt>: Solved cardinality > 2\n+\n+Remark: some of the descriptor templates above might be valid if optional extensions allowing them are added in the implementation.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 280,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This sentence feels a redundant, it seems obvious that extensions are added and those extensions would need to allow something to become valid if it’s invalid without the extensions. How about:\r\n\r\n```suggestion\r\nRemark: some of the examples of invalid descriptor templates may be valid via optional extensions.\r\n```",
      "created_at": "2024-05-07T14:49:08Z",
      "updated_at": "2024-05-07T14:54:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1592623927",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1592623927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1593039154",
      "pull_request_review_id": 2044130087,
      "id": 1593039154,
      "node_id": "PRRC_kwDOAN28mc5e89ky",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n+** any of the additional, implementation-specific valid derivation path patterns (see [[#Optional_derivation_paths|Optional derivation paths]] below).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+Note that while [[bip-0389.mediawiki|BIP-389]] allows multipath `/<NUM;NUM;...;NUM>` expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The public keys obtained by deserializing elements of the keys information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the conext of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 164,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": 1592588492,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in 7d0c08e38acac3ef14095d0e8664c7332b7be381, together with few other occurrences of the same in other parts of the document.",
      "created_at": "2024-05-07T20:25:24Z",
      "updated_at": "2024-05-07T20:25:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1593039154",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1593039154"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1593041597",
      "pull_request_review_id": 2044131662,
      "id": 1593041597,
      "node_id": "PRRC_kwDOAN28mc5e8-K9",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+In fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>multi_a</tt> (in case interactive signing is not available).\n+\n+With each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 104,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": 1592585137,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 7d0c08e38acac3ef14095d0e8664c7332b7be381, I further replaced the sentence to:\r\n`Replacing the common part of the key with a short key placeholder and organizing all the key expressions in a separate list helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.`",
      "created_at": "2024-05-07T20:26:24Z",
      "updated_at": "2024-05-07T20:26:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1593041597",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1593041597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1593045922",
      "pull_request_review_id": 2044134454,
      "id": 1593045922,
      "node_id": "PRRC_kwDOAN28mc5e8_Oi",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+<pre>\n+  BIP: 388\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.",
      "path": "bip-0388.mediawiki",
      "position": null,
      "original_position": 17,
      "commit_id": "7d0c08e38acac3ef14095d0e8664c7332b7be381",
      "original_commit_id": "a0c8501f960ac29878e137c03dcd6d8a3b9096b5",
      "in_reply_to_id": 1592545076,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 7d0c08e38acac3ef14095d0e8664c7332b7be381, I made sure that only the forms \"output script descriptor\" and \"descriptor\" appear. I think it's generally clear from context that both expression refers to the same.",
      "created_at": "2024-05-07T20:28:13Z",
      "updated_at": "2024-05-07T20:28:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1593045922",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1593045922"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    }
  ]
}