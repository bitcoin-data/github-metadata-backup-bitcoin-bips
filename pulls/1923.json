{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1923",
    "id": 2733304062,
    "node_id": "PR_kwDOAN28mc6i6uj-",
    "html_url": "https://github.com/bitcoin/bips/pull/1923",
    "diff_url": "https://github.com/bitcoin/bips/pull/1923.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1923.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1923/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/bd1e2425872450b4b9d80cdcb47874d9659a3bda",
    "number": 1923,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": " BIP 181, 182, 183: BIPs for Utreexo",
    "user": {
      "login": "kcalvinalvin",
      "id": 37185887,
      "node_id": "MDQ6VXNlcjM3MTg1ODg3",
      "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kcalvinalvin",
      "html_url": "https://github.com/kcalvinalvin",
      "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
      "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
      "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
      "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
      "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "These are the 3 BIPs that describe Utreexo, a consensus-compatible (non-soft fork) way to send and verify transactions without storing the full UTXO set.\r\n\r\nThe 3 BIPs are for:\r\n1. The specification of the Utreexo accumulator.\r\n2. The specification of Bitcoin block and tx validation using the Utreexo accumulator.\r\n3. The peer to peer networking changes required to enable Utreexo nodes.\r\n\r\nMailing list post: https://groups.google.com/g/bitcoindev/c/W1lxBraKG_E",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2025-08-10T06:56:50Z",
    "updated_at": "2025-09-20T00:01:22Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merged": false,
    "merge_commit_sha": "5a60b4bc3b2326c9bffa99cc5d0d205567a151ab",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "kcalvinalvin:2025-08-10-utreexo-bips",
      "ref": "2025-08-10-utreexo-bips",
      "sha": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 986054383,
        "node_id": "R_kgDOOsX-7w",
        "name": "bips",
        "full_name": "kcalvinalvin/bips",
        "owner": {
          "login": "kcalvinalvin",
          "id": 37185887,
          "node_id": "MDQ6VXNlcjM3MTg1ODg3",
          "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/kcalvinalvin",
          "html_url": "https://github.com/kcalvinalvin",
          "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
          "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
          "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
          "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
          "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/kcalvinalvin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/kcalvinalvin/bips",
        "archive_url": "https://api.github.com/repos/kcalvinalvin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/kcalvinalvin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/kcalvinalvin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/kcalvinalvin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/kcalvinalvin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/kcalvinalvin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/kcalvinalvin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/kcalvinalvin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/kcalvinalvin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/kcalvinalvin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/kcalvinalvin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/kcalvinalvin/bips/downloads",
        "events_url": "https://api.github.com/repos/kcalvinalvin/bips/events",
        "forks_url": "https://api.github.com/repos/kcalvinalvin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/kcalvinalvin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/kcalvinalvin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/kcalvinalvin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/kcalvinalvin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/kcalvinalvin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/kcalvinalvin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/kcalvinalvin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/kcalvinalvin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/kcalvinalvin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/kcalvinalvin/bips/languages",
        "merges_url": "https://api.github.com/repos/kcalvinalvin/bips/merges",
        "milestones_url": "https://api.github.com/repos/kcalvinalvin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/kcalvinalvin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/kcalvinalvin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/kcalvinalvin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:kcalvinalvin/bips.git",
        "stargazers_url": "https://api.github.com/repos/kcalvinalvin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/kcalvinalvin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/kcalvinalvin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/kcalvinalvin/bips/subscription",
        "tags_url": "https://api.github.com/repos/kcalvinalvin/bips/tags",
        "teams_url": "https://api.github.com/repos/kcalvinalvin/bips/teams",
        "trees_url": "https://api.github.com/repos/kcalvinalvin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/kcalvinalvin/bips.git",
        "hooks_url": "https://api.github.com/repos/kcalvinalvin/bips/hooks",
        "svn_url": "https://github.com/kcalvinalvin/bips",
        "homepage": "",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 18207,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-09-07T12:52:48Z",
        "created_at": "2025-05-19T03:26:28Z",
        "updated_at": "2025-05-19T03:26:28Z",
        "allow_forking": true
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "eabb63cb53ed487309249a59f76051d404fd4632",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5737,
        "stargazers_count": 10200,
        "watchers_count": 10200,
        "size": 16632,
        "default_branch": "master",
        "open_issues_count": 49,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-09-19T23:31:04Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2025-09-19T23:31:18Z",
        "allow_forking": true
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 1607,
    "deletions": 0,
    "changed_files": 14,
    "commits": 4,
    "review_comments": 201,
    "comments": 19
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 19074534274,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAARw7kuC",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19074534274",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9b3eafb52bfdf69280c5326e90dda3347fc71ab0",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/9b3eafb52bfdf69280c5326e90dda3347fc71ab0",
      "created_at": "2025-08-10T07:06:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19074544819,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAARw7nSz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19074544819",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/a94f6434c8f4be7469a3d913046a3c66db48f805",
      "created_at": "2025-08-10T07:09:03Z"
    },
    {
      "event": "labeled",
      "id": 19077017639,
      "node_id": "LE_lADOAN28mc7FIK1EzwAAAARxFDAn",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19077017639",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-10T17:29:05Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "reviewed",
      "id": 3106077404,
      "node_id": "PRR_kwDOAN28mc65Ivrc",
      "url": null,
      "actor": null,
      "commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-11T14:34:10Z",
      "author_association": "NONE",
      "body": "some typos",
      "user": {
        "login": "jmoik",
        "id": 63734881,
        "node_id": "MDQ6VXNlcjYzNzM0ODgx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63734881?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jmoik",
        "html_url": "https://github.com/jmoik",
        "followers_url": "https://api.github.com/users/jmoik/followers",
        "following_url": "https://api.github.com/users/jmoik/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jmoik/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jmoik/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jmoik/subscriptions",
        "organizations_url": "https://api.github.com/users/jmoik/orgs",
        "repos_url": "https://api.github.com/users/jmoik/repos",
        "events_url": "https://api.github.com/users/jmoik/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jmoik/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3106077404",
      "submitted_at": "2025-08-11T14:34:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "reviewed",
      "id": 3107530297,
      "node_id": "PRR_kwDOAN28mc65OSY5",
      "url": null,
      "actor": null,
      "commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-11T21:52:02Z",
      "author_association": "MEMBER",
      "body": "Thank you for proposing these drafts. They already look quite complete with respect to the editorial requirements (BIPs 2 and 3). I've done a cursory first pass. No immediate conceptual feedback. A few editorial comments follow; feel free to ignore them during conceptual review until they are applicable.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3107530297",
      "submitted_at": "2025-08-11T21:52:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "reviewed",
      "id": 3107913820,
      "node_id": "PRR_kwDOAN28mc65PwBc",
      "url": null,
      "actor": null,
      "commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-11T22:06:47Z",
      "author_association": "NONE",
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3107913820",
      "submitted_at": "2025-08-11T22:06:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19103917616,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAARyrqYw",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19103917616",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "cb2993cf7d4b33de452ed38b6ddaba3262603fc6",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/cb2993cf7d4b33de452ed38b6ddaba3262603fc6",
      "created_at": "2025-08-12T06:15:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19104050469,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAARysK0l",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19104050469",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/d1d03420ac5ee234494d84358a4abd06df269f65",
      "created_at": "2025-08-12T06:23:34Z"
    },
    {
      "event": "subscribed",
      "id": 19111100143,
      "node_id": "SE_lADOAN28mc7FIK1EzwAAAARzHD7v",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19111100143",
      "actor": {
        "login": "judemont",
        "id": 96385330,
        "node_id": "U_kgDOBb65Mg",
        "avatar_url": "https://avatars.githubusercontent.com/u/96385330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/judemont",
        "html_url": "https://github.com/judemont",
        "followers_url": "https://api.github.com/users/judemont/followers",
        "following_url": "https://api.github.com/users/judemont/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/judemont/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/judemont/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/judemont/subscriptions",
        "organizations_url": "https://api.github.com/users/judemont/orgs",
        "repos_url": "https://api.github.com/users/judemont/repos",
        "events_url": "https://api.github.com/users/judemont/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/judemont/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T12:16:41Z"
    },
    {
      "event": "commented",
      "id": 3179972052,
      "node_id": "IC_kwDOAN28mc69ioXU",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3179972052",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T15:52:53Z",
      "updated_at": "2025-08-12T15:52:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "You need to justify why you're using SHA-512/256 rather than SHA-256, like the rest of the Bitcoin protocol. Right now you just link to a paper from 2011. But that paper is out of date now that hardware support for SHA-256 has become common.",
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3179972052",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3180517949,
      "node_id": "IC_kwDOAN28mc69kto9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3180517949",
      "actor": {
        "login": "1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "id": 219042429,
        "node_id": "U_kgDODQ5SfQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/219042429?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "html_url": "https://github.com/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "followers_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/followers",
        "following_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/subscriptions",
        "organizations_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/orgs",
        "repos_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/repos",
        "events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T18:29:31Z",
      "updated_at": "2025-08-12T18:49:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "I strongly recommend replacing SHA-256 with **SHAKE256** (from the SHA-3 standard) for the following reasons:\r\n\r\n## 1. Security Advantages\r\n- ðŸ”’ Provides built-in protection against length-extension attacks\r\n- ðŸ“ Offers flexible output lengths (supports 128-bit and 256-bit security levels)\r\n- âš™ï¸ Based on Keccak sponge construction (NIST FIPS 202 standard)\r\n- ðŸŒ Aligns with post-quantum cryptography standards\r\n\r\n## 2. Comparative Analysis: SHA-256 vs SHAKE256\r\n\r\n| Characteristic       | SHA-256          | SHAKE256         |\r\n|----------------------|------------------|------------------|\r\n| **Algorithm Family** | SHA-2            | SHA-3 (Keccak)   |\r\n| **Output Flexibility** | Fixed 256-bit    | Arbitrary length |\r\n| **Security Properties** | Vulnerable to length-extension | Resistant to length-extension |\r\n| **Internal Structure** | Merkle-DamgÃ¥rd   | Sponge function  |\r\n| **Standardization** | NIST FIPS 180-4  | NIST FIPS 202    |\r\n\r\n## 3. Functional Example\r\n**Input:** `Bitcoin` \r\n\r\n**SHAKE256 (512-bit output):**  \r\n`6beb0661ba1fa7289bf359fbb81550bd9641cf5abc62a14d466c421c8a86e528e027632ec0e7ceb994650566f3c8258af2240333b6d0e9186766fd2c1ebb763a`\r\n\r\n**SHAKE256 (256-bit output):**  \r\n`6beb0661ba1fa7289bf359fbb81550bd9641cf5abc62a14d466c421c8a86e528`\r\n\r\n## 4. Implementation Benefits\r\n- âœ… Maintains 256-bit output compatibility where needed\r\n- âœ… Future-proofs against emerging cryptographic vulnerabilities\r\n- âœ… Reduces potential attack vectors through improved design\r\n- âœ… Supports Bitcoin's security evolution while maintaining performance\r\n\r\n## 5. Technical Reference\r\nFor detailed cryptographic differences:  \r\n[Cryptographic Comparison: SHA-2 vs SHA-3](https://crypto.stackexchange.com/a/68314)",
      "user": {
        "login": "1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "id": 219042429,
        "node_id": "U_kgDODQ5SfQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/219042429?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "html_url": "https://github.com/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "followers_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/followers",
        "following_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/subscriptions",
        "organizations_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/orgs",
        "repos_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/repos",
        "events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3180517949",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3196199910,
      "node_id": "IC_kwDOAN28mc6-giPm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3196199910",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T11:06:29Z",
      "updated_at": "2025-08-18T11:06:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "> You need to justify why you're using SHA-512/256 rather than SHA-256, like the rest of the Bitcoin protocol. Right now you just link to a paper from 2011. But that paper is out of date now that hardware support for SHA-256 has become common.\r\n\r\nSure we can update the accumulator BIP with benchmarks for SHA512/256 vs SHA256.\r\n\r\nBut could you link to the aforementioned justifications for the other parts of the Bitcoin protocol that use SHA512?",
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3196199910",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3196210709,
      "node_id": "IC_kwDOAN28mc6-gk4V",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3196210709",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T11:10:24Z",
      "updated_at": "2025-08-18T14:27:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I strongly recommend replacing SHA-256 with **SHAKE256** (from the SHA-3 standard) for the following reasons:\r\n\r\nSHAKE256 is not used in Bitcoin and introduces a new hash which increases the trust-assumption. We do not want to do this.",
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3196210709",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "comment_deleted",
      "id": 19205324154,
      "node_id": "CDE_lADOAN28mc7FIK1EzwAAAAR4uf16",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19205324154",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T14:31:43Z"
    },
    {
      "event": "comment_deleted",
      "id": 19205326711,
      "node_id": "CDE_lADOAN28mc7FIK1EzwAAAAR4ugd3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19205326711",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T14:31:51Z"
    },
    {
      "event": "commented",
      "id": 3197189723,
      "node_id": "IC_kwDOAN28mc6-kT5b",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3197189723",
      "actor": {
        "login": "1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "id": 219042429,
        "node_id": "U_kgDODQ5SfQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/219042429?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "html_url": "https://github.com/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "followers_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/followers",
        "following_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/subscriptions",
        "organizations_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/orgs",
        "repos_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/repos",
        "events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T14:32:51Z",
      "updated_at": "2025-08-18T14:55:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "The reliance of Bitcoin on SHA-2â€”a legacy hash function designed by the National Security Agency (NSA)â€”introduces non-trivial security risks, particularly when considering the often-dismissed threat posed by quantum adversaries.\n\nMigrating to SHAKE256 (a variant of SHA-3) would represent a meaningful improvement, though such a change merely delays the inevitable: Bitcoin must eventually transition to a quantum-resistant cryptographic framework. When this occursâ€”and it will, regardless of oppositionâ€”SHA-2, along with ECDSA private keys, public keys, and signatures, will become obsolete.\n\nSee: Lenght extension attack (Bitcoin is vulnerable because it's using SHA-256)\n\n",
      "user": {
        "login": "1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "id": 219042429,
        "node_id": "U_kgDODQ5SfQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/219042429?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "html_url": "https://github.com/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "followers_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/followers",
        "following_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/subscriptions",
        "organizations_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/orgs",
        "repos_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/repos",
        "events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3197189723",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "comment_deleted",
      "id": 19205349784,
      "node_id": "CDE_lADOAN28mc7FIK1EzwAAAAR4umGY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19205349784",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T14:33:03Z"
    },
    {
      "event": "comment_deleted",
      "id": 19205361336,
      "node_id": "CDE_lADOAN28mc7FIK1EzwAAAAR4uo64",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19205361336",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T14:33:35Z"
    },
    {
      "event": "commented",
      "id": 3197200979,
      "node_id": "IC_kwDOAN28mc6-kWpT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3197200979",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T14:35:55Z",
      "updated_at": "2025-08-18T14:35:55Z",
      "author_association": "MEMBER",
      "body": "Some friendly moderation to keep the discussion focused on technical review -- thanks.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3197200979",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3197240847,
      "node_id": "IC_kwDOAN28mc6-kgYP",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3197240847",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T14:46:13Z",
      "updated_at": "2025-08-18T20:01:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "> The reliance of Bitcoin on SHA-2â€”a legacy hash function designed by the National Security Agency (NSA)â€”introduces non-trivial security risks, particularly when considering the often-dismissed threat posed by quantum adversaries.\r\n\r\nSHA256 and SHA512 are quantum resistent.\r\n\r\n> Migrating to SHAKE256 (a variant of SHA-3) would represent a meaningful improvement, though such a change merely delays the inevitable: Bitcoin must eventually transition to a quantum-resistant cryptographic framework. When this occursâ€”and it will, regardless of oppositionâ€”SHA-2, along with ECDSA private keys, public keys, and signatures, will become obsolete.\r\n> See: Lenght extension attack (Bitcoin is vulnerable because it's using SHA-256)\r\n\r\nOk but this has nothing to do with this BIP.",
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3197240847",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "unsubscribed",
      "id": 19206204134,
      "node_id": "UE_lADOAN28mc7FIK1EzwAAAAR4x2rm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19206204134",
      "actor": {
        "login": "judemont",
        "id": 96385330,
        "node_id": "U_kgDOBb65Mg",
        "avatar_url": "https://avatars.githubusercontent.com/u/96385330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/judemont",
        "html_url": "https://github.com/judemont",
        "followers_url": "https://api.github.com/users/judemont/followers",
        "following_url": "https://api.github.com/users/judemont/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/judemont/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/judemont/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/judemont/subscriptions",
        "organizations_url": "https://api.github.com/users/judemont/orgs",
        "repos_url": "https://api.github.com/users/judemont/repos",
        "events_url": "https://api.github.com/users/judemont/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/judemont/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T15:16:18Z"
    },
    {
      "event": "commented",
      "id": 3198584473,
      "node_id": "IC_kwDOAN28mc6-poaZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3198584473",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T22:15:07Z",
      "updated_at": "2025-08-18T22:15:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "@1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw, please cut out the LLM generated comments. If any of us were interested in seeing an LLMâ€™s prediction of what might be said about a topic, we could prompt one ourselves.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3198584473",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3198590980,
      "node_id": "IC_kwDOAN28mc6-pqAE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3198590980",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T22:18:29Z",
      "updated_at": "2025-08-18T22:18:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "On Mon, Aug 18, 2025 at 04:06:51AM -0700, Calvin Kim wrote:\n> kcalvinalvin left a comment (bitcoin/bips#1923)\n> \n> > You need to justify why you're using SHA-512/256 rather than SHA-256, like the rest of the Bitcoin protocol. Right now you just link to a paper from 2011. But that paper is out of date now that hardware support for SHA-256 has become common.\n> \n> Sure we can update the accumulator BIP with benchmarks for SHA512/256 vs SHA256.\n> \n> But could you link to the aforementioned justifications for the other parts of the Bitcoin protocol that use SHA512?\n\nNo part of the Bitcoin consensus protocol uses SHA512.\n",
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3198590980",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3199355396,
      "node_id": "IC_kwDOAN28mc6-skoE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3199355396",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-19T06:17:17Z",
      "updated_at": "2025-08-19T06:17:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "> On Mon, Aug 18, 2025 at 04:06:51AM -0700, Calvin Kim wrote: kcalvinalvin left a comment ([bitcoin/bips#1923](https://github.com/bitcoin/bips/pull/1923)) > You need to justify why you're using SHA-512/256 rather than SHA-256, like the rest of the Bitcoin protocol. Right now you just link to a paper from 2011. But that paper is out of date now that hardware support for SHA-256 has become common. Sure we can update the accumulator BIP with benchmarks for SHA512/256 vs SHA256. But could you link to the aforementioned justifications for the other parts of the Bitcoin protocol that use SHA512?\r\n> No part of the Bitcoin consensus protocol uses SHA512.\r\n\r\nOk but you've stated in your previous comment \"You need to justify why you're using SHA-512/256 rather than SHA-256, like the rest of the Bitcoin protocol\". Would be very helpful to see what type of justifications the other protocols have made.\r\n\r\nSecond, I don't think it matters if SHA512 wasn't used in the Bitcoin consensus protocol. SHA512 is used in BIP32 and the argument that SHA512 is safe for generating private keys but not safe for Bitcoin consensus isn't sound.\r\n\r\nI think our original justification (better performance with SHA512/256) mentioned in the BIP is sound. Happy to provide the benchmarks, they're being worked on at the moment.",
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3199355396",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3204352724,
      "node_id": "IC_kwDOAN28mc6-_orU",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3204352724",
      "actor": {
        "login": "1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "id": 219042429,
        "node_id": "U_kgDODQ5SfQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/219042429?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "html_url": "https://github.com/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "followers_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/followers",
        "following_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/subscriptions",
        "organizations_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/orgs",
        "repos_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/repos",
        "events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T06:22:28Z",
      "updated_at": "2025-08-20T07:31:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "> SHA512 is safe for generating private keys\n\nLol, what did you say?",
      "user": {
        "login": "1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "id": 219042429,
        "node_id": "U_kgDODQ5SfQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/219042429?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "html_url": "https://github.com/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw",
        "followers_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/followers",
        "following_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/subscriptions",
        "organizations_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/orgs",
        "repos_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/repos",
        "events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/1BitcoinBoWP1FZ4xwTNkq6XksKidmgYYw/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3204352724",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3204387233,
      "node_id": "IC_kwDOAN28mc6-_xGh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3204387233",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T06:35:19Z",
      "updated_at": "2025-08-20T07:31:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "> > SHA512 is safe for generating private keys\r\n> \r\n> Lol, what did you say?\r\n\r\nDude, go look up on chatgpt how SHA512/256 works. Length extension attacks that you mentioned DOES NOT work on it because the outputs are truncated. BIP32 uses HMAC-SHA512 which is just a keyed SHA512.\r\n\r\nWhy do I even have to deal with this guy. It's clear he doesn't know anything. His comments are worthless and this is wasting my time and energy.",
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3204387233",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3204518476,
      "node_id": "IC_kwDOAN28mc6_ARJM",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3204518476",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T07:16:26Z",
      "updated_at": "2025-08-20T07:30:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "![IMG_0371](https://github.com/user-attachments/assets/5ea010a6-b8e0-44e7-9d56-86e7fd3ad21b)\r\n\r\nThis is the type of email he sends me after I block him. I'm sorry for posting unrelated comments here but imho he should be blocked from this repo.",
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3204518476",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "reviewed",
      "id": 3141977529,
      "node_id": "PRR_kwDOAN28mc67RsW5",
      "url": null,
      "actor": null,
      "commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-21T19:13:47Z",
      "author_association": "NONE",
      "user": {
        "login": "lucad70",
        "id": 102705148,
        "node_id": "U_kgDOBh8n_A",
        "avatar_url": "https://avatars.githubusercontent.com/u/102705148?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/lucad70",
        "html_url": "https://github.com/lucad70",
        "followers_url": "https://api.github.com/users/lucad70/followers",
        "following_url": "https://api.github.com/users/lucad70/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/lucad70/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/lucad70/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/lucad70/subscriptions",
        "organizations_url": "https://api.github.com/users/lucad70/orgs",
        "repos_url": "https://api.github.com/users/lucad70/repos",
        "events_url": "https://api.github.com/users/lucad70/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/lucad70/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3141977529",
      "submitted_at": "2025-08-21T19:13:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "commented",
      "id": 3218116360,
      "node_id": "IC_kwDOAN28mc6_0I8I",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3218116360",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-24T13:48:55Z",
      "updated_at": "2025-08-24T13:48:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "> > On Mon, Aug 18, 2025 at 04:06:51AM -0700, Calvin Kim wrote: kcalvinalvin left a comment ([bitcoin/bips#1923](https://github.com/bitcoin/bips/pull/1923)) > You need to justify why you're using SHA-512/256 rather than SHA-256, like the rest of the Bitcoin protocol. Right now you just link to a paper from 2011. But that paper is out of date now that hardware support for SHA-256 has become common. Sure we can update the accumulator BIP with benchmarks for SHA512/256 vs SHA256. But could you link to the aforementioned justifications for the other parts of the Bitcoin protocol that use SHA512?\r\n> > No part of the Bitcoin consensus protocol uses SHA512.\r\n> \r\n> Ok but you've stated in your previous comment \"You need to justify why you're using SHA-512/256 rather than SHA-256, like the rest of the Bitcoin protocol\". Would be very helpful to see what type of justifications the other protocols have made.\r\n> \r\n> Second, I don't think it matters if SHA512 wasn't used in the Bitcoin consensus protocol. SHA512 is used in BIP32 and the argument that SHA512 is safe for generating private keys but not safe for Bitcoin consensus isn't sound.\r\n> \r\n> I think our original justification (better performance with SHA512/256) mentioned in the BIP is sound. Happy to provide the benchmarks, they're being worked on at the moment.\r\n\r\nThe question is 1) why are we added one new dependency to consensus implementations, and 2) is this actually a performance increase, given that dedicated SHA256 hardware is becoming common?\r\n\r\nLength-extension attacks are not relevant for this use-case as we are only committing to public data.",
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3218116360",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "reviewed",
      "id": 3152676858,
      "node_id": "PRR_kwDOAN28mc676gf6",
      "url": null,
      "actor": null,
      "commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-25T21:22:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "I had a look at most of the Accumulator Specification for the first helping. Looks very good already. I only reviewed the function definitions up to `root_position`, then skimmed the rest, before reading on from Rationale.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3152676858",
      "submitted_at": "2025-08-25T21:22:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "reviewed",
      "id": 3160624315,
      "node_id": "PRR_kwDOAN28mc68Y0y7",
      "url": null,
      "actor": null,
      "commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-27T18:56:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "This time I took a look at the \"Validation Layer\" BIP. Also looks very good already. I noticed that there is no Rationale section, and the title seemed a little less informative than it could be.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3160624315",
      "submitted_at": "2025-08-27T18:56:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "reviewed",
      "id": 3166548243,
      "node_id": "PRR_kwDOAN28mc68vbET",
      "url": null,
      "actor": null,
      "commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-28T22:50:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "I read the whole P2P BIP, although I went over the new messages section a bit more quickly. There are some sections that felt a bit confusing to me, perhaps you could try to take a look at whether you can clarify those for the less initiated. Overall, this seems close to complete, although I noticed that it is missing a Rationale section.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3166548243",
      "submitted_at": "2025-08-28T22:50:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "labeled",
      "id": 19400881171,
      "node_id": "LE_lADOAN28mc7FIK1EzwAAAASEYfQT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19400881171",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-28T22:52:36Z",
      "label": {
        "name": "Needs number assignment",
        "color": "eb6420"
      }
    },
    {
      "event": "commented",
      "id": 3238112394,
      "node_id": "IC_kwDOAN28mc7BAayK",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3238112394",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-29T20:00:32Z",
      "updated_at": "2025-08-29T20:14:05Z",
      "author_association": "MEMBER",
      "body": "After discussion amongst the editors, we've assigned 181-183 for these 3 BIP drafts.\r\n\r\n@murchandamus suggested 181 Accumulator / 182 Validation / 183 P2P (I agree) while leaving it up to you.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3238112394",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "mentioned",
      "id": 19418094101,
      "node_id": "MEE_lADOAN28mc7FIK1EzwAAAASFaJoV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19418094101",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-29T20:00:34Z"
    },
    {
      "event": "subscribed",
      "id": 19418094289,
      "node_id": "SE_lADOAN28mc7FIK1EzwAAAASFaJrR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19418094289",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-29T20:00:34Z"
    },
    {
      "event": "unlabeled",
      "id": 19418098101,
      "node_id": "UNLE_lADOAN28mc7FIK1EzwAAAASFaKm1",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19418098101",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-29T20:00:47Z",
      "label": {
        "name": "Needs number assignment",
        "color": "eb6420"
      }
    },
    {
      "event": "commented",
      "id": 3238711176,
      "node_id": "IC_kwDOAN28mc7BCs-I",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3238711176",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-29T23:33:21Z",
      "updated_at": "2025-08-29T23:33:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "Whenever you get around to it, please add the numbers to the Preambles, set the \"Created\" header to 2025-08-29 (it holds the date a BIP got numbered), and add the table entries to the README.mediawiki.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3238711176",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "commented",
      "id": 3238916869,
      "node_id": "IC_kwDOAN28mc7BDfMF",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3238916869",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-30T03:53:12Z",
      "updated_at": "2025-08-30T03:53:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "> After discussion amongst the editors, we've assigned 181-183 for these 3 BIP drafts.\r\n> \r\n> @murchandamus suggested 181 Accumulator / 182 Validation / 183 P2P (I agree) while leaving it up to you.\r\n\r\n\r\n\r\n> Whenever you get around to it, please add the numbers to the Preambles, set the \"Created\" header to 2025-08-29 (it holds the date a BIP got numbered), and add the table entries to the README.mediawiki.\r\n\r\nCurrently going through all the reviews and writing up the rationale for validation and p2p. Will address these as well.",
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3238916869",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "mentioned",
      "id": 19422214478,
      "node_id": "MEE_lADOAN28mc7FIK1EzwAAAASFp3lO",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19422214478",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-30T03:53:14Z"
    },
    {
      "event": "subscribed",
      "id": 19422214481,
      "node_id": "SE_lADOAN28mc7FIK1EzwAAAASFp3lR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19422214481",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-30T03:53:14Z"
    },
    {
      "event": "reviewed",
      "id": 3177267763,
      "node_id": "PRR_kwDOAN28mc69YUIz",
      "url": null,
      "actor": null,
      "commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-02T16:11:41Z",
      "author_association": "NONE",
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3177267763",
      "submitted_at": "2025-09-02T16:11:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "reviewed",
      "id": 3177281231,
      "node_id": "PRR_kwDOAN28mc69YXbP",
      "url": null,
      "actor": null,
      "commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-02T16:14:45Z",
      "author_association": "NONE",
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3177281231",
      "submitted_at": "2025-09-02T16:14:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19550573864,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAASNThUo",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19550573864",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "24c7efce3bcb780029b62d5b5b37ee4738f063b8",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/24c7efce3bcb780029b62d5b5b37ee4738f063b8",
      "created_at": "2025-09-07T12:13:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19550589524,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAASNTlJU",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19550589524",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d67f429497010ba539366f99c8ccc7543e5b1562",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/d67f429497010ba539366f99c8ccc7543e5b1562",
      "created_at": "2025-09-07T12:17:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19550599821,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAASNTnqN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19550599821",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "253c73943ae5dbdb298ede05e1db9b5933c7ab89",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/253c73943ae5dbdb298ede05e1db9b5933c7ab89",
      "created_at": "2025-09-07T12:20:48Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGQ4OTk1MmQwOWYwMTY4ZWE3NjUyNzM3OThmM2NmOTNkMWFiNGM5NTA",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/d89952d09f0168ea765273798f3cf93d1ab4c950",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/d89952d09f0168ea765273798f3cf93d1ab4c950",
      "tree": {
        "sha": "4d65adec1cb55b2158f2cb640dfe4c9a7c06c7be",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/4d65adec1cb55b2158f2cb640dfe4c9a7c06c7be"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/e97c908096a275b7a71b304ba7ed82ca3602a72c",
          "sha": "e97c908096a275b7a71b304ba7ed82ca3602a72c",
          "html_url": "https://github.com/bitcoin/bips/commit/e97c908096a275b7a71b304ba7ed82ca3602a72c"
        }
      ],
      "message": "BIP181: Add the Utreexo accumulator BIP",
      "committer": {
        "name": "Calvin Kim",
        "email": "calvin@kcalvinalvin.info",
        "date": "2025-09-07T12:27:43Z"
      },
      "author": {
        "name": "Calvin Kim",
        "email": "calvin@kcalvinalvin.info",
        "date": "2025-09-07T12:08:48Z"
      },
      "sha": "d89952d09f0168ea765273798f3cf93d1ab4c950"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19550627106,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAASNTuUi",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19550627106",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "091afe15547ce330258546b0ab5ed62891d0ec70",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/091afe15547ce330258546b0ab5ed62891d0ec70",
      "created_at": "2025-09-07T12:29:01Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDRhYTI2ZjNjYTczM2UxMTJmZDVjZTk1NTc0OTEzYTY2ODMxNjg1NTk",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4aa26f3ca733e112fd5ce95574913a6683168559",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/4aa26f3ca733e112fd5ce95574913a6683168559",
      "tree": {
        "sha": "dcd4af44c1cae55966f514e9dc5a0863228b6951",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/dcd4af44c1cae55966f514e9dc5a0863228b6951"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/d89952d09f0168ea765273798f3cf93d1ab4c950",
          "sha": "d89952d09f0168ea765273798f3cf93d1ab4c950",
          "html_url": "https://github.com/bitcoin/bips/commit/d89952d09f0168ea765273798f3cf93d1ab4c950"
        }
      ],
      "message": "BIP182: Add the Utreexo validation BIP",
      "committer": {
        "name": "Calvin Kim",
        "email": "calvin@kcalvinalvin.info",
        "date": "2025-09-07T12:40:32Z"
      },
      "author": {
        "name": "Calvin Kim",
        "email": "calvin@kcalvinalvin.info",
        "date": "2025-09-07T12:09:15Z"
      },
      "sha": "4aa26f3ca733e112fd5ce95574913a6683168559"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19550679021,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAASNT6_t",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19550679021",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "260f2c95358828175aa346939172449b6fc62bc6",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/260f2c95358828175aa346939172449b6fc62bc6",
      "created_at": "2025-09-07T12:43:35Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDY4ZGEzNjZhOThkYjM1ZWNmYzhkMThhYjVmMzRmODY4NGFjNTBmOTg",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/68da366a98db35ecfc8d18ab5f34f8684ac50f98",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/68da366a98db35ecfc8d18ab5f34f8684ac50f98",
      "tree": {
        "sha": "a0554ab6b0403e412f1fa6687832189ef2768049",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/a0554ab6b0403e412f1fa6687832189ef2768049"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4aa26f3ca733e112fd5ce95574913a6683168559",
          "sha": "4aa26f3ca733e112fd5ce95574913a6683168559",
          "html_url": "https://github.com/bitcoin/bips/commit/4aa26f3ca733e112fd5ce95574913a6683168559"
        }
      ],
      "message": "BIP183: Add the Utreexo P2P BIP",
      "committer": {
        "name": "Calvin Kim",
        "email": "calvin@kcalvinalvin.info",
        "date": "2025-09-07T12:52:34Z"
      },
      "author": {
        "name": "Calvin Kim",
        "email": "calvin@kcalvinalvin.info",
        "date": "2025-09-07T12:09:44Z"
      },
      "sha": "68da366a98db35ecfc8d18ab5f34f8684ac50f98"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGJkMWUyNDI1ODcyNDUwYjRiOWQ4MGNkY2I0Nzg3NGQ5NjU5YTNiZGE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "tree": {
        "sha": "a24f5606ed7cd64880a0e4b347f254dc408ff407",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/a24f5606ed7cd64880a0e4b347f254dc408ff407"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/68da366a98db35ecfc8d18ab5f34f8684ac50f98",
          "sha": "68da366a98db35ecfc8d18ab5f34f8684ac50f98",
          "html_url": "https://github.com/bitcoin/bips/commit/68da366a98db35ecfc8d18ab5f34f8684ac50f98"
        }
      ],
      "message": "Update README table to include BIPs: 181, 182, 183",
      "committer": {
        "name": "Calvin Kim",
        "email": "calvin@kcalvinalvin.info",
        "date": "2025-09-07T12:52:34Z"
      },
      "author": {
        "name": "Calvin Kim",
        "email": "calvin@kcalvinalvin.info",
        "date": "2025-09-07T12:41:16Z"
      },
      "sha": "bd1e2425872450b4b9d80cdcb47874d9659a3bda"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19550709537,
      "node_id": "HRFPE_lADOAN28mc7FIK1EzwAAAASNUCch",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19550709537",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "commit_url": "https://api.github.com/repos/kcalvinalvin/bips/commits/bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "created_at": "2025-09-07T12:52:50Z"
    },
    {
      "event": "renamed",
      "id": 19550710602,
      "node_id": "RTE_lADOAN28mc7FIK1EzwAAAASNUCtK",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/19550710602",
      "actor": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-07T12:53:09Z",
      "rename": {
        "from": " BIP draft: BIPs for Utreexo",
        "to": " BIP 181, 182, 183: BIPs for Utreexo"
      }
    },
    {
      "event": "reviewed",
      "id": 3108832141,
      "node_id": "PRR_kwDOAN28mc65TQON",
      "url": null,
      "actor": null,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-07T12:58:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "All of the review comments are addressed and the rationale for BIPs 182 and 183 were added.\r\n\r\nBIP-0183 was also edited in the following ways:\r\n\r\n1: Images updated with caption\r\n2: Images now updated with transparent backgrounds and changed the colors so they can be read in dark mod\r\n3: Changed the layout of the images and the paragraphs to be more legible.",
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3108832141",
      "submitted_at": "2025-09-07T12:58:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "reviewed",
      "id": 3231566058,
      "node_id": "PRR_kwDOAN28mc7Ancjq",
      "url": null,
      "actor": null,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-16T20:38:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the update.\r\n\r\nI gave the diff a quick skim:",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3231566058",
      "submitted_at": "2025-09-16T20:32:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "commented",
      "id": 3300315785,
      "node_id": "IC_kwDOAN28mc7EttKJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3300315785",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-16T20:51:52Z",
      "updated_at": "2025-09-16T20:51:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "It would perhaps be good if one or two other people gave it also a read, but either way, it seems pretty complete to me. Whatâ€™s the status on your end? Do you still have planned work, or are waiting for people to finish reviews?",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3300315785",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "reviewed",
      "id": 3232053448,
      "node_id": "PRR_kwDOAN28mc7ApTjI",
      "url": null,
      "actor": null,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-17T00:11:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "> It would perhaps be good if one or two other people gave it also a read\r\n\r\nHere's my read. I've suggested mainly formatting and capitalization changes, but at least two suggestions are quite important: the distinction between \"varint\" and \"compact size\", and the broken cross-BIP links.",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3232053448",
      "submitted_at": "2025-09-17T00:11:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "commented",
      "id": 3314103279,
      "node_id": "IC_kwDOAN28mc7FiTPv",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3314103279",
      "actor": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-19T22:58:02Z",
      "updated_at": "2025-09-19T22:58:02Z",
      "author_association": "NONE",
      "body": "Some test vectors are in order as well.",
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#issuecomment-3314103279",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1923"
    },
    {
      "event": "reviewed",
      "id": 3247453919,
      "node_id": "PRR_kwDOAN28mc7BkDbf",
      "url": null,
      "actor": null,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-19T23:21:39Z",
      "author_association": "NONE",
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3247453919",
      "submitted_at": "2025-09-19T23:21:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    },
    {
      "event": "reviewed",
      "id": 3247632882,
      "node_id": "PRR_kwDOAN28mc7BkvHy",
      "url": null,
      "actor": null,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-20T00:01:22Z",
      "author_association": "NONE",
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1923#pullrequestreview-3247632882",
      "submitted_at": "2025-09-20T00:01:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266894044",
      "pull_request_review_id": 3106077404,
      "id": 2266894044,
      "node_id": "PRRC_kwDOAN28mc6HHg7c",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 26,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jmoik",
        "id": 63734881,
        "node_id": "MDQ6VXNlcjYzNzM0ODgx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63734881?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jmoik",
        "html_url": "https://github.com/jmoik",
        "followers_url": "https://api.github.com/users/jmoik/followers",
        "following_url": "https://api.github.com/users/jmoik/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jmoik/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jmoik/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jmoik/subscriptions",
        "organizations_url": "https://api.github.com/users/jmoik/orgs",
        "repos_url": "https://api.github.com/users/jmoik/repos",
        "events_url": "https://api.github.com/users/jmoik/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jmoik/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "an -> a",
      "created_at": "2025-08-11T14:08:16Z",
      "updated_at": "2025-08-11T14:34:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2266894044",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266894044"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266895876",
      "pull_request_review_id": 3106077404,
      "id": 2266895876,
      "node_id": "PRRC_kwDOAN28mc6HHhYE",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 27,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jmoik",
        "id": 63734881,
        "node_id": "MDQ6VXNlcjYzNzM0ODgx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63734881?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jmoik",
        "html_url": "https://github.com/jmoik",
        "followers_url": "https://api.github.com/users/jmoik/followers",
        "following_url": "https://api.github.com/users/jmoik/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jmoik/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jmoik/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jmoik/subscriptions",
        "organizations_url": "https://api.github.com/users/jmoik/orgs",
        "repos_url": "https://api.github.com/users/jmoik/repos",
        "events_url": "https://api.github.com/users/jmoik/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jmoik/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "an -> a",
      "created_at": "2025-08-11T14:08:56Z",
      "updated_at": "2025-08-11T14:34:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2266895876",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266895876"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266899583",
      "pull_request_review_id": 3106077404,
      "id": 2266899583,
      "node_id": "PRRC_kwDOAN28mc6HHiR_",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 50,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jmoik",
        "id": 63734881,
        "node_id": "MDQ6VXNlcjYzNzM0ODgx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63734881?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jmoik",
        "html_url": "https://github.com/jmoik",
        "followers_url": "https://api.github.com/users/jmoik/followers",
        "following_url": "https://api.github.com/users/jmoik/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jmoik/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jmoik/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jmoik/subscriptions",
        "organizations_url": "https://api.github.com/users/jmoik/orgs",
        "repos_url": "https://api.github.com/users/jmoik/repos",
        "events_url": "https://api.github.com/users/jmoik/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jmoik/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "are in fact should -> should in fact",
      "created_at": "2025-08-11T14:10:17Z",
      "updated_at": "2025-08-11T14:34:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2266899583",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266899583"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266915855",
      "pull_request_review_id": 3106077404,
      "id": 2266915855,
      "node_id": "PRRC_kwDOAN28mc6HHmQP",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 98,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jmoik",
        "id": 63734881,
        "node_id": "MDQ6VXNlcjYzNzM0ODgx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63734881?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jmoik",
        "html_url": "https://github.com/jmoik",
        "followers_url": "https://api.github.com/users/jmoik/followers",
        "following_url": "https://api.github.com/users/jmoik/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jmoik/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jmoik/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jmoik/subscriptions",
        "organizations_url": "https://api.github.com/users/jmoik/orgs",
        "repos_url": "https://api.github.com/users/jmoik/repos",
        "events_url": "https://api.github.com/users/jmoik/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jmoik/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "- is",
      "created_at": "2025-08-11T14:15:52Z",
      "updated_at": "2025-08-11T14:34:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2266915855",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266915855"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266920621",
      "pull_request_review_id": 3106077404,
      "id": 2266920621,
      "node_id": "PRRC_kwDOAN28mc6HHnat",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash` which make up the extra information that a Utreexo node will receive.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 105,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jmoik",
        "id": 63734881,
        "node_id": "MDQ6VXNlcjYzNzM0ODgx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63734881?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jmoik",
        "html_url": "https://github.com/jmoik",
        "followers_url": "https://api.github.com/users/jmoik/followers",
        "following_url": "https://api.github.com/users/jmoik/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jmoik/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jmoik/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jmoik/subscriptions",
        "organizations_url": "https://api.github.com/users/jmoik/orgs",
        "repos_url": "https://api.github.com/users/jmoik/repos",
        "events_url": "https://api.github.com/users/jmoik/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jmoik/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "make -> includes",
      "created_at": "2025-08-11T14:17:23Z",
      "updated_at": "2025-08-11T14:34:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2266920621",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266920621"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266927458",
      "pull_request_review_id": 3106077404,
      "id": 2266927458,
      "node_id": "PRRC_kwDOAN28mc6HHpFi",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash` which make up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.\n+The committed data is defined in BIP-VALIDATION#LEAF_DATA, but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely just omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                          |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| length       | varint              | The length of the TTLs                                                                                                                                               |\n+| TTLs         | vector of TTL infos | position in the Utreexo merkle forest when the leaf was removed                                                                                                      |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](./utreexo-accumulator-bip.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](./utreexo-validation-bip.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](./utreexo-accumulator-bip.md#Utility Functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested Utreexo summaries |",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 302,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jmoik",
        "id": 63734881,
        "node_id": "MDQ6VXNlcjYzNzM0ODgx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63734881?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jmoik",
        "html_url": "https://github.com/jmoik",
        "followers_url": "https://api.github.com/users/jmoik/followers",
        "following_url": "https://api.github.com/users/jmoik/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jmoik/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jmoik/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jmoik/subscriptions",
        "organizations_url": "https://api.github.com/users/jmoik/orgs",
        "repos_url": "https://api.github.com/users/jmoik/repos",
        "events_url": "https://api.github.com/users/jmoik/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jmoik/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "requested proof hashes*?",
      "created_at": "2025-08-11T14:19:44Z",
      "updated_at": "2025-08-11T14:34:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2266927458",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266927458"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266933047",
      "pull_request_review_id": 3106077404,
      "id": 2266933047,
      "node_id": "PRRC_kwDOAN28mc6HHqc3",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash` which make up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.\n+The committed data is defined in BIP-VALIDATION#LEAF_DATA, but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely just omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                          |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| length       | varint              | The length of the TTLs                                                                                                                                               |\n+| TTLs         | vector of TTL infos | position in the Utreexo merkle forest when the leaf was removed                                                                                                      |",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 242,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jmoik",
        "id": 63734881,
        "node_id": "MDQ6VXNlcjYzNzM0ODgx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63734881?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jmoik",
        "html_url": "https://github.com/jmoik",
        "followers_url": "https://api.github.com/users/jmoik/followers",
        "following_url": "https://api.github.com/users/jmoik/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jmoik/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jmoik/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jmoik/subscriptions",
        "organizations_url": "https://api.github.com/users/jmoik/orgs",
        "repos_url": "https://api.github.com/users/jmoik/repos",
        "events_url": "https://api.github.com/users/jmoik/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jmoik/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "description?",
      "created_at": "2025-08-11T14:21:45Z",
      "updated_at": "2025-08-11T14:34:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2266933047",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266933047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266937404",
      "pull_request_review_id": 3106077404,
      "id": 2266937404,
      "node_id": "PRRC_kwDOAN28mc6HHrg8",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash` which make up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.\n+The committed data is defined in BIP-VALIDATION#LEAF_DATA, but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 194,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jmoik",
        "id": 63734881,
        "node_id": "MDQ6VXNlcjYzNzM0ODgx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63734881?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jmoik",
        "html_url": "https://github.com/jmoik",
        "followers_url": "https://api.github.com/users/jmoik/followers",
        "following_url": "https://api.github.com/users/jmoik/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jmoik/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jmoik/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jmoik/subscriptions",
        "organizations_url": "https://api.github.com/users/jmoik/orgs",
        "repos_url": "https://api.github.com/users/jmoik/repos",
        "events_url": "https://api.github.com/users/jmoik/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jmoik/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should probably be unsigned",
      "created_at": "2025-08-11T14:23:14Z",
      "updated_at": "2025-08-11T14:34:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2266937404",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2266937404"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267164435",
      "pull_request_review_id": 3106465271,
      "id": 2267164435,
      "node_id": "PRRC_kwDOAN28mc6HIi8T",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 26,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266894044,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "there are two, would be this one\r\n```suggestion\r\nEach block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\r\n```",
      "created_at": "2025-08-11T15:39:19Z",
      "updated_at": "2025-08-11T15:39:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2267164435",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267164435"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267173538",
      "pull_request_review_id": 3106478939,
      "id": 2267173538,
      "node_id": "PRRC_kwDOAN28mc6HIlKi",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash` which make up the extra information that a Utreexo node will receive.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 105,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266920621,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "s/ which make/, which makes/",
      "created_at": "2025-08-11T15:42:09Z",
      "updated_at": "2025-08-11T21:32:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2267173538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267173538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267845722",
      "pull_request_review_id": 3107530297,
      "id": 2267845722,
      "node_id": "PRRC_kwDOAN28mc6HLJRa",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 13,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Per BIPs 2 and 3, this would be \"Requires\" (and currently refers to the same BIP)\r\n\r\n```suggestion\r\nRequires: BIP-???? (Utreexo - Peer Services)\r\n```",
      "created_at": "2025-08-11T19:41:08Z",
      "updated_at": "2025-08-12T16:24:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2267845722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267845722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267846287",
      "pull_request_review_id": 3107530297,
      "id": 2267846287,
      "node_id": "PRRC_kwDOAN28mc6HLJaP",
      "diff_hunk": "@@ -0,0 +1,342 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 13,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Per BIPs 2 and 3, this would be \"Requires\"\r\n\r\n```suggestion\r\nRequires: BIP-???? (Utreexo Accumulator Specification)\r\n```",
      "created_at": "2025-08-11T19:41:22Z",
      "updated_at": "2025-08-11T21:52:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2267846287",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267846287"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267849415",
      "pull_request_review_id": 3107530297,
      "id": 2267849415,
      "node_id": "PRRC_kwDOAN28mc6HLKLH",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 13,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Refers to the same document. If correct, this line should be dropped.",
      "created_at": "2025-08-11T19:42:33Z",
      "updated_at": "2025-08-11T21:52:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2267849415",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267849415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267860444",
      "pull_request_review_id": 3107530297,
      "id": 2267860444,
      "node_id": "PRRC_kwDOAN28mc6HLM3c",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo increases the storage requirement for the accumulator state to O(logâ‚‚(N)),",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 56,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"increases the requirement\" -- perhaps mention here \"compared to the UTXO set\"",
      "created_at": "2025-08-11T19:47:53Z",
      "updated_at": "2025-08-11T21:52:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2267860444",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2267860444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268081567",
      "pull_request_review_id": 3107530297,
      "id": 2268081567,
      "node_id": "PRRC_kwDOAN28mc6HMC2f",
      "diff_hunk": "@@ -0,0 +1,342 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 39,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The preceding 3 paragraphs seem to be duplicates of the accumulator BIP that this BIP requires. Can perhaps remove them or refer to the accumulator BIP motivation.",
      "created_at": "2025-08-11T21:38:20Z",
      "updated_at": "2025-08-11T21:52:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268081567",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268081567"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268096096",
      "pull_request_review_id": 3107530297,
      "id": 2268096096,
      "node_id": "PRRC_kwDOAN28mc6HMGZg",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo increases the storage requirement for the accumulator state to O(logâ‚‚(N)),\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{logâ‚‚(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for the P2P layer:\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:\n+\n+- From row 0 to and **including** `treerows(acc.numleaves)`\n+  - Break if there's no root at this row.\n+  - remove the last root from `acc.roots`.\n+    - Calculate the parent hash of the removed root and the `hash` to be added using *parent_hash*.\n+  - Make the result from `parent_hash` the new `hash`.\n+- Increment `acc.numleaves` by 1.\n+- Append `hash` to `acc.roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def add(self, hash: bytes):\n+    for row in range(tree_rows(self.numleaves)+1):\n+        if not root_present(self.numleaves, row): break\n+        root = self.roots.pop()\n+        hash = parent_hash(root, hash)\n+\n+    self.roots.append(hash)\n+    self.numleaves += 1\n+```\n+\n+## Verification\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The Verification algorithm `Verify(acc, []hash, proof) -> bool` is defined as:\n+\n+- Raise error if length of `[]hash` differ from `proof.targets`.\n+- Get modified_roots from `CalculateRoots(acc.numleaves, []hash, Proof)`.\n+- Get `root_idxs` from `getrootidxs`.\n+- Raise error if the length of `modified_roots` and `root_idxs` do not match.\n+- Attempt to match roots in modified_roots with roots in `acc`. Raise error if we don't find all the roots in the modified_roots in `acc`.\n+- Return `true`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def verify(self, dels: [bytes], proof: Proof) -> bool:\n+    if len(dels) != len(proof.targets):\n+        raise(\"len of dels and proof.targets differ\")\n+\n+    root_candidates = calculate_roots(self.numleaves, dels, proof)\n+    root_idxs = getrootidxs(self.numleaves, proof.targets)\n+\n+    if len(root_candidates) != len(root_idxs):\n+        raise(\"length of calculated roots from the proof and expected root count differ\")\n+\n+    for i, idx in enumerate(root_idxs):\n+        if self.roots[idx] != root_candidates[i]:\n+            raise(\"calculated roots from the proof and matched roots differ\")\n+\n+    return true\n+```\n+\n+## Deletion\n+\n+Deletion removes leaves from the accumulator. The deletion algorithm takes in a `proof` but it does not\n+verify that the proof is valid. It assumes that the passed in proof has already passed verification.\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `proof`.\n+\n+The Deletion algorithm `Delete(acc, Proof) -> acc` is defined as:\n+\n+- Get the modified indexes of the roots `root_idxes` from `getrootidxs`.\n+- Get modified_roots from `Calculate_Roots(acc.numleaves, []positions, Proof)`.\n+- Replace the matching indexes from the `root_idxes` in `acc.roots` with `modified_roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def delete(self, proof: Proof):\n+    modified_roots = calculate_roots(self.numleaves, None, proof)\n+    root_idxs = getrootidxs(self.numleaves, proof.targets)\n+    for i, idx in enumerate(root_idxs):\n+        self.roots[idx] = modified_roots[i]\n+```\n+\n+## Rationale\n+\n+**Why use a hash-based accumulator instead of something more powerful (e.g., RSA accumulators[^3], class groups[^4], etc.)?**\n+\n+While RSA accumulators and similar constructions offer significant advantages in proof sizeâ€”often allowing a\n+single proof to cover an entire block's worth of UTXOsâ€”the trade-offs in proof generation cost and latency are\n+substantial. In RSA-based designs, creating a proof for any given UTXO at arbitrary times can be computationally\n+intensive, especially as the number of UTXOs grows.\n+\n+Utreexo's design is driven by the need for Bridge Nodes: nodes that maintain backward compatibility with existing",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 555,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This BIP appears to be missing a required backwards compatibility section.",
      "created_at": "2025-08-11T21:48:22Z",
      "updated_at": "2025-08-11T21:52:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268096096",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268096096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 554,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268118463",
      "pull_request_review_id": 3107913820,
      "id": 2268118463,
      "node_id": "PRRC_kwDOAN28mc6HML2_",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo increases the storage requirement for the accumulator state to O(logâ‚‚(N)),",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 56,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nTo accommodate this, Utreexo increases the storage requirement for the accumulator state to $O(log_2(N))$,\r\n```\r\n\r\nLaTeX renderers don't play nice with this unicode symbol.",
      "created_at": "2025-08-11T22:05:03Z",
      "updated_at": "2025-08-11T22:06:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268118463",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268118463"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268118700",
      "pull_request_review_id": 3107913820,
      "id": 2268118700,
      "node_id": "PRRC_kwDOAN28mc6HML6s",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo increases the storage requirement for the accumulator state to O(logâ‚‚(N)),\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{logâ‚‚(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 66,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\napproximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\r\n```\r\n\r\nLaTeX renderers don't play nice with this unicode symbol.",
      "created_at": "2025-08-11T22:05:14Z",
      "updated_at": "2025-08-11T22:06:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268118700",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268118700"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268508383",
      "pull_request_review_id": 3108452258,
      "id": 2268508383,
      "node_id": "PRRC_kwDOAN28mc6HNrDf",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash` which make up the extra information that a Utreexo node will receive.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 105,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266920621,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'll go with `, which makes` since `includes` sounds like the `utreexoproofhash` invvect has other information as well\n\nEDIT: Replaced with `, which makes` in the latest push",
      "created_at": "2025-08-12T03:49:15Z",
      "updated_at": "2025-08-12T06:57:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268508383",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268508383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268556363",
      "pull_request_review_id": 3108509674,
      "id": 2268556363,
      "node_id": "PRRC_kwDOAN28mc6HN2xL",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash` which make up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.\n+The committed data is defined in BIP-VALIDATION#LEAF_DATA, but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 194,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266937404,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It makes sense to have it as int64 as `CAmount` is represented as `int64` in code https://github.com/bitcoin/bitcoin/blob/273e600e65c2e31a6e9a0bd72b40672aaa503b08/src/consensus/amount.h#L12\n\nOther implementations follow this as well:https://github.com/btcsuite/btcd/blob/baebb836c2d4692da3de3b0d437f4da6ce915546/wire/msgtx.go#L337",
      "created_at": "2025-08-12T04:38:57Z",
      "updated_at": "2025-08-12T04:38:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268556363",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268556363"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268584595",
      "pull_request_review_id": 3108546515,
      "id": 2268584595,
      "node_id": "PRRC_kwDOAN28mc6HN9qT",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo increases the storage requirement for the accumulator state to O(logâ‚‚(N)),",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 56,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2267860444,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah the paragraph could be worded better.\n\nIt's referring to how the merkle forest is expanded to support more leaves. Like sparse merkle trees, you pre-allocate the Utreexo accumulator to hold 2^n leaves. If you want to hold (2^n)+1 leaves, you need to resize the accumulator to hold 2^n+1 leaves.",
      "created_at": "2025-08-12T05:03:58Z",
      "updated_at": "2025-08-12T05:03:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268584595",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268584595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268685762",
      "pull_request_review_id": 3108680478,
      "id": 2268685762,
      "node_id": "PRRC_kwDOAN28mc6HOWXC",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo increases the storage requirement for the accumulator state to O(logâ‚‚(N)),",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 56,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2267860444,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "~~Oh I read it wrong too. It increases the requirements vs the paper referenced in [^1].~~\n\n~~Fixing this...~~\n\nChanged the sentence to improve legibility",
      "created_at": "2025-08-12T06:05:46Z",
      "updated_at": "2025-08-12T06:55:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268685762",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268685762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268781592",
      "pull_request_review_id": 3108812390,
      "id": 2268781592,
      "node_id": "PRRC_kwDOAN28mc6HOtwY",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo increases the storage requirement for the accumulator state to O(logâ‚‚(N)),",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 56,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2268118463,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Addressed in the latest push",
      "created_at": "2025-08-12T06:52:39Z",
      "updated_at": "2025-08-12T06:52:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268781592",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268781592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268782264",
      "pull_request_review_id": 3108813541,
      "id": 2268782264,
      "node_id": "PRRC_kwDOAN28mc6HOt64",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo increases the storage requirement for the accumulator state to O(logâ‚‚(N)),\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{logâ‚‚(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 66,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2268118700,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Addressed in the latest push",
      "created_at": "2025-08-12T06:52:57Z",
      "updated_at": "2025-08-12T06:52:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268782264",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268782264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268783509",
      "pull_request_review_id": 3108815244,
      "id": 2268783509,
      "node_id": "PRRC_kwDOAN28mc6HOuOV",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 13,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2267845722,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Addressed in the latest push",
      "created_at": "2025-08-12T06:53:28Z",
      "updated_at": "2025-08-12T06:53:28Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268783509",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268783509"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268784111",
      "pull_request_review_id": 3108815976,
      "id": 2268784111,
      "node_id": "PRRC_kwDOAN28mc6HOuXv",
      "diff_hunk": "@@ -0,0 +1,342 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 13,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2267846287,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Addressed in the latest push",
      "created_at": "2025-08-12T06:53:45Z",
      "updated_at": "2025-08-12T06:53:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268784111",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268784111"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268784944",
      "pull_request_review_id": 3108817475,
      "id": 2268784944,
      "node_id": "PRRC_kwDOAN28mc6HOukw",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 13,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2267849415,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Dropped in the latest push",
      "created_at": "2025-08-12T06:54:05Z",
      "updated_at": "2025-08-12T06:54:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268784944",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268784944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268789478",
      "pull_request_review_id": 3108824269,
      "id": 2268789478,
      "node_id": "PRRC_kwDOAN28mc6HOvrm",
      "diff_hunk": "@@ -0,0 +1,342 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 39,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2268081567,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed the preceding 3 paragraphs in the latest push",
      "created_at": "2025-08-12T06:56:04Z",
      "updated_at": "2025-08-12T06:56:04Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268789478",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268789478"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268790205",
      "pull_request_review_id": 3108825607,
      "id": 2268790205,
      "node_id": "PRRC_kwDOAN28mc6HOv29",
      "diff_hunk": "@@ -0,0 +1,627 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spentâ€”a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitelyâ€”bounded only by block sizeâ€”it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo increases the storage requirement for the accumulator state to O(logâ‚‚(N)),\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{logâ‚‚(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for the P2P layer:\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:\n+\n+- From row 0 to and **including** `treerows(acc.numleaves)`\n+  - Break if there's no root at this row.\n+  - remove the last root from `acc.roots`.\n+    - Calculate the parent hash of the removed root and the `hash` to be added using *parent_hash*.\n+  - Make the result from `parent_hash` the new `hash`.\n+- Increment `acc.numleaves` by 1.\n+- Append `hash` to `acc.roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def add(self, hash: bytes):\n+    for row in range(tree_rows(self.numleaves)+1):\n+        if not root_present(self.numleaves, row): break\n+        root = self.roots.pop()\n+        hash = parent_hash(root, hash)\n+\n+    self.roots.append(hash)\n+    self.numleaves += 1\n+```\n+\n+## Verification\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The Verification algorithm `Verify(acc, []hash, proof) -> bool` is defined as:\n+\n+- Raise error if length of `[]hash` differ from `proof.targets`.\n+- Get modified_roots from `CalculateRoots(acc.numleaves, []hash, Proof)`.\n+- Get `root_idxs` from `getrootidxs`.\n+- Raise error if the length of `modified_roots` and `root_idxs` do not match.\n+- Attempt to match roots in modified_roots with roots in `acc`. Raise error if we don't find all the roots in the modified_roots in `acc`.\n+- Return `true`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def verify(self, dels: [bytes], proof: Proof) -> bool:\n+    if len(dels) != len(proof.targets):\n+        raise(\"len of dels and proof.targets differ\")\n+\n+    root_candidates = calculate_roots(self.numleaves, dels, proof)\n+    root_idxs = getrootidxs(self.numleaves, proof.targets)\n+\n+    if len(root_candidates) != len(root_idxs):\n+        raise(\"length of calculated roots from the proof and expected root count differ\")\n+\n+    for i, idx in enumerate(root_idxs):\n+        if self.roots[idx] != root_candidates[i]:\n+            raise(\"calculated roots from the proof and matched roots differ\")\n+\n+    return true\n+```\n+\n+## Deletion\n+\n+Deletion removes leaves from the accumulator. The deletion algorithm takes in a `proof` but it does not\n+verify that the proof is valid. It assumes that the passed in proof has already passed verification.\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `proof`.\n+\n+The Deletion algorithm `Delete(acc, Proof) -> acc` is defined as:\n+\n+- Get the modified indexes of the roots `root_idxes` from `getrootidxs`.\n+- Get modified_roots from `Calculate_Roots(acc.numleaves, []positions, Proof)`.\n+- Replace the matching indexes from the `root_idxes` in `acc.roots` with `modified_roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def delete(self, proof: Proof):\n+    modified_roots = calculate_roots(self.numleaves, None, proof)\n+    root_idxs = getrootidxs(self.numleaves, proof.targets)\n+    for i, idx in enumerate(root_idxs):\n+        self.roots[idx] = modified_roots[i]\n+```\n+\n+## Rationale\n+\n+**Why use a hash-based accumulator instead of something more powerful (e.g., RSA accumulators[^3], class groups[^4], etc.)?**\n+\n+While RSA accumulators and similar constructions offer significant advantages in proof sizeâ€”often allowing a\n+single proof to cover an entire block's worth of UTXOsâ€”the trade-offs in proof generation cost and latency are\n+substantial. In RSA-based designs, creating a proof for any given UTXO at arbitrary times can be computationally\n+intensive, especially as the number of UTXOs grows.\n+\n+Utreexo's design is driven by the need for Bridge Nodes: nodes that maintain backward compatibility with existing",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 555,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2268096096,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a backwards compatibility section",
      "created_at": "2025-08-12T06:56:25Z",
      "updated_at": "2025-08-12T06:56:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268790205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268790205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 554,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268790682",
      "pull_request_review_id": 3108826305,
      "id": 2268790682,
      "node_id": "PRRC_kwDOAN28mc6HOv-a",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 26,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266894044,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Addressed in the latest push",
      "created_at": "2025-08-12T06:56:38Z",
      "updated_at": "2025-08-12T06:56:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268790682",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268790682"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268791138",
      "pull_request_review_id": 3108826843,
      "id": 2268791138,
      "node_id": "PRRC_kwDOAN28mc6HOwFi",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 27,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266895876,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Addressed in the latest push",
      "created_at": "2025-08-12T06:56:50Z",
      "updated_at": "2025-08-12T06:56:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268791138",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268791138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268791526",
      "pull_request_review_id": 3108827321,
      "id": 2268791526,
      "node_id": "PRRC_kwDOAN28mc6HOwLm",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 50,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266899583,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Addressed in the latest push",
      "created_at": "2025-08-12T06:57:00Z",
      "updated_at": "2025-08-12T06:57:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268791526",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268791526"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268792149",
      "pull_request_review_id": 3108828384,
      "id": 2268792149,
      "node_id": "PRRC_kwDOAN28mc6HOwVV",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 98,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266915855,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed in the latest push",
      "created_at": "2025-08-12T06:57:15Z",
      "updated_at": "2025-08-12T06:57:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268792149",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268792149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268818125",
      "pull_request_review_id": 3108832141,
      "id": 2268818125,
      "node_id": "PRRC_kwDOAN28mc6HO2rN",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash` which make up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.\n+The committed data is defined in BIP-VALIDATION#LEAF_DATA, but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely just omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                          |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| length       | varint              | The length of the TTLs                                                                                                                                               |\n+| TTLs         | vector of TTL infos | position in the Utreexo merkle forest when the leaf was removed                                                                                                      |",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 242,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266933047,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added the correct description in the latest push",
      "created_at": "2025-08-12T07:09:46Z",
      "updated_at": "2025-09-07T12:58:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268818125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268818125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268818570",
      "pull_request_review_id": 3108832141,
      "id": 2268818570,
      "node_id": "PRRC_kwDOAN28mc6HO2yK",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Depends: BIP-???? (Utreexo - Peer Services)\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has an corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has an corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and are in fact should be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv is does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash` which make up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.\n+The committed data is defined in BIP-VALIDATION#LEAF_DATA, but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely just omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                          |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| length       | varint              | The length of the TTLs                                                                                                                                               |\n+| TTLs         | vector of TTL infos | position in the Utreexo merkle forest when the leaf was removed                                                                                                      |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](./utreexo-accumulator-bip.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](./utreexo-validation-bip.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](./utreexo-accumulator-bip.md#Utility Functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested Utreexo summaries |",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 302,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "a94f6434c8f4be7469a3d913046a3c66db48f805",
      "in_reply_to_id": 2266927458,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Addressed in the latest push",
      "created_at": "2025-08-12T07:09:59Z",
      "updated_at": "2025-09-07T12:58:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2268818570",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2268818570"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2291920873",
      "pull_request_review_id": 3141977529,
      "id": 2291920873,
      "node_id": "PRRC_kwDOAN28mc6Im-_p",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 66,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "lucad70",
        "id": 102705148,
        "node_id": "U_kgDOBh8n_A",
        "avatar_url": "https://avatars.githubusercontent.com/u/102705148?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/lucad70",
        "html_url": "https://github.com/lucad70",
        "followers_url": "https://api.github.com/users/lucad70/followers",
        "following_url": "https://api.github.com/users/lucad70/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/lucad70/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/lucad70/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/lucad70/subscriptions",
        "organizations_url": "https://api.github.com/users/lucad70/orgs",
        "repos_url": "https://api.github.com/users/lucad70/repos",
        "events_url": "https://api.github.com/users/lucad70/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/lucad70/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For clarification, is the `Utreexo_Tag_V1` really used twice in preimage to the hash?",
      "created_at": "2025-08-21T19:13:46Z",
      "updated_at": "2025-08-21T19:13:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2291920873",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2291920873"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 63,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2298879164",
      "pull_request_review_id": 3152676858,
      "id": 2298879164,
      "node_id": "PRRC_kwDOAN28mc6JBhy8",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 10,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "8444a28331aabaf375deb981693ae4c379cbc841",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: BIPâ€¯2 is still active, so this should be \"Standard Track\" for the time being.",
      "created_at": "2025-08-25T19:02:51Z",
      "updated_at": "2025-08-25T21:22:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2298879164",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2298879164"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2298882141",
      "pull_request_review_id": 3152676858,
      "id": 2298882141,
      "node_id": "PRRC_kwDOAN28mc6JBihd",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 17,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nThis BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n```",
      "created_at": "2025-08-25T19:04:27Z",
      "updated_at": "2025-08-25T21:22:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2298882141",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2298882141"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299081095",
      "pull_request_review_id": 3152676858,
      "id": 2299081095,
      "node_id": "PRRC_kwDOAN28mc6JCTGH",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 56,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In case this doesnâ€™t get discussed later, it might be interesting to compare how O(log<sub>2</sub>(N)) for all transaction outputs ever created compare to the current UTXO set size.",
      "created_at": "2025-08-25T20:36:36Z",
      "updated_at": "2025-08-25T21:22:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2299081095",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299081095"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 55,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299099519",
      "pull_request_review_id": 3152676858,
      "id": 2299099519,
      "node_id": "PRRC_kwDOAN28mc6JCXl_",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 176,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Does this ambiguity regarding the depth of the leaf in the tree not introduce similar weaknesses as the original Merkle tree construction? Why would we float up leaf-hashes rather than create a tagged hash at each level?\n\nIs this fully mitigated due to the number of leaves being known?",
      "created_at": "2025-08-25T20:44:51Z",
      "updated_at": "2025-08-25T21:22:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2299099519",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299099519"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299106678",
      "pull_request_review_id": 3152676858,
      "id": 2299106678,
      "node_id": "PRRC_kwDOAN28mc6JCZV2",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 191,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The `numleaves - 1` throws me off here. Itâ€™s not obvious to me, why the function would be defined that way rather than the \"minimum number of bits required to represent `numleaves`\"? Perhaps a bit more context would help?",
      "created_at": "2025-08-25T20:49:04Z",
      "updated_at": "2025-08-25T21:22:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2299106678",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299106678"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299136899",
      "pull_request_review_id": 3152676858,
      "id": 2299136899,
      "node_id": "PRRC_kwDOAN28mc6JCguD",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 241,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I could have used a little more explanation why this returns the parent, but staring at it for a bit, it seems to me that a fully filled tree with 2<super>n</super> leaves would have 2<super>n</super>-1 inner nodes, meaning that all leaves start with a zero in the first position and all inner nodes starting with a one. \n\nE.g. for four leaves, the leaves are 000, 001, 010, and 011, and the inner nodes would be 100, 101, 110.\n\nFor 000 and 001, shifting to the right gives 00 and setting the top bit makes the parent 100. For 010 and 011, it works out to be 101. For 100 and 101, it works out to 110.\n\nGotcha, cool.",
      "created_at": "2025-08-25T21:05:57Z",
      "updated_at": "2025-08-25T21:22:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2299136899",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299136899"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 234,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299160022",
      "pull_request_review_id": 3152676858,
      "id": 2299160022,
      "node_id": "PRRC_kwDOAN28mc6JCmXW",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for the P2P layer:\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:\n+\n+- From row 0 to and **including** `treerows(acc.numleaves)`\n+  - Break if there's no root at this row.\n+  - remove the last root from `acc.roots`.\n+    - Calculate the parent hash of the removed root and the `hash` to be added using *parent_hash*.\n+  - Make the result from `parent_hash` the new `hash`.\n+- Increment `acc.numleaves` by 1.\n+- Append `hash` to `acc.roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def add(self, hash: bytes):\n+    for row in range(tree_rows(self.numleaves)+1):\n+        if not root_present(self.numleaves, row): break\n+        root = self.roots.pop()\n+        hash = parent_hash(root, hash)\n+\n+    self.roots.append(hash)\n+    self.numleaves += 1\n+```\n+\n+## Verification\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The Verification algorithm `Verify(acc, []hash, proof) -> bool` is defined as:\n+\n+- Raise error if length of `[]hash` differ from `proof.targets`.\n+- Get modified_roots from `CalculateRoots(acc.numleaves, []hash, Proof)`.\n+- Get `root_idxs` from `getrootidxs`.\n+- Raise error if the length of `modified_roots` and `root_idxs` do not match.\n+- Attempt to match roots in modified_roots with roots in `acc`. Raise error if we don't find all the roots in the modified_roots in `acc`.\n+- Return `true`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def verify(self, dels: [bytes], proof: Proof) -> bool:\n+    if len(dels) != len(proof.targets):\n+        raise(\"len of dels and proof.targets differ\")\n+\n+    root_candidates = calculate_roots(self.numleaves, dels, proof)\n+    root_idxs = getrootidxs(self.numleaves, proof.targets)\n+\n+    if len(root_candidates) != len(root_idxs):\n+        raise(\"length of calculated roots from the proof and expected root count differ\")\n+\n+    for i, idx in enumerate(root_idxs):\n+        if self.roots[idx] != root_candidates[i]:\n+            raise(\"calculated roots from the proof and matched roots differ\")\n+\n+    return true\n+```\n+\n+## Deletion\n+\n+Deletion removes leaves from the accumulator. The deletion algorithm takes in a `proof` but it does not\n+verify that the proof is valid. It assumes that the passed in proof has already passed verification.\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `proof`.\n+\n+The Deletion algorithm `Delete(acc, Proof) -> acc` is defined as:\n+\n+- Get the modified indexes of the roots `root_idxes` from `getrootidxs`.\n+- Get modified_roots from `Calculate_Roots(acc.numleaves, []positions, Proof)`.\n+- Replace the matching indexes from the `root_idxes` in `acc.roots` with `modified_roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def delete(self, proof: Proof):\n+    modified_roots = calculate_roots(self.numleaves, None, proof)\n+    root_idxs = getrootidxs(self.numleaves, proof.targets)\n+    for i, idx in enumerate(root_idxs):\n+        self.roots[idx] = modified_roots[i]\n+```\n+\n+## Rationale\n+\n+**Why use a hash-based accumulator instead of something more powerful (e.g., RSA accumulators[^3], class groups[^4], etc.)?**\n+\n+While RSA accumulators and similar constructions offer significant advantages in proof sizeâ€”often allowing a\n+single proof to cover an entire block's worth of UTXOsâ€”the trade-offs in proof generation cost and latency are\n+substantial. In RSA-based designs, creating a proof for any given UTXO at arbitrary times can be computationally\n+intensive, especially as the number of UTXOs grows.\n+\n+Utreexo's design is driven by the need for Bridge Nodes: nodes that maintain backward compatibility with existing",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 554,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "New jargon is usually italicized on introduction, perhaps consider:\n\n```suggestion\nUtreexo's design is driven by the need for *bridge nodes*: nodes that maintain backward compatibility with existing\n```",
      "created_at": "2025-08-25T21:16:41Z",
      "updated_at": "2025-08-25T21:22:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2299160022",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2299160022"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 554,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304532833",
      "pull_request_review_id": 3160624315,
      "id": 2304532833,
      "node_id": "PRRC_kwDOAN28mc6JXGFh",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 4,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "ca511ff1de40239f60bb1f85f8724f092f240607",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The title feels a bit odd to me. It could be a bit more descriptive, I was thinking \"Utreexo - Transaction and block validation\" or smth?",
      "created_at": "2025-08-27T16:14:21Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304532833",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304532833"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304540964",
      "pull_request_review_id": 3160624315,
      "id": 2304540964,
      "node_id": "PRRC_kwDOAN28mc6JXIEk",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 10,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "ca511ff1de40239f60bb1f85f8724f092f240607",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: Until BIPâ€¯3 activates, this should be Standards Track.",
      "created_at": "2025-08-27T16:16:50Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304540964",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304540964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304597186",
      "pull_request_review_id": 3160624315,
      "id": 2304597186,
      "node_id": "PRRC_kwDOAN28mc6JXVzC",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 20,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe for the time being:\n\n```suggestion\nUtreexo accumulator itself, for that see [â€ŽBIP Utreexo Accumulator](â€Žutreexo-accumulator-bip.md). This document is only concerned with\n```",
      "created_at": "2025-08-27T16:32:26Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304597186",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304597186"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304610628",
      "pull_request_review_id": 3160624315,
      "id": 2304610628,
      "node_id": "PRRC_kwDOAN28mc6JXZFE",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 52,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nbeing added or removed from the accumulator. The leaf hash is a 32-byte hash that\n```",
      "created_at": "2025-08-27T16:35:58Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304610628",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304610628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304612430",
      "pull_request_review_id": 3160624315,
      "id": 2304612430,
      "node_id": "PRRC_kwDOAN28mc6JXZhO",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 60,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nIndividual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n```",
      "created_at": "2025-08-27T16:36:25Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304612430",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304612430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304621352",
      "pull_request_review_id": 3160624315,
      "id": 2304621352,
      "node_id": "PRRC_kwDOAN28mc6JXbso",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 66,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2291920873,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "My guess would be that this duplication is unintended.\n\n```suggestion\n| Name              | Type                     | Description                               |\n| ----------------- | ------------------------ | ----------------------------------------- |\n| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n```",
      "created_at": "2025-08-27T16:38:59Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304621352",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304621352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 63,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304643537",
      "pull_request_review_id": 3160624315,
      "id": 2304643537,
      "node_id": "PRRC_kwDOAN28mc6JXhHR",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 79,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe link to the section introducing tagged hashes in BIPâ€¯340: https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design",
      "created_at": "2025-08-27T16:45:42Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304643537",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304643537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304645472",
      "pull_request_review_id": 3160624315,
      "id": 2304645472,
      "node_id": "PRRC_kwDOAN28mc6JXhlg",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 84,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n```",
      "created_at": "2025-08-27T16:46:18Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304645472",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304645472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304656197",
      "pull_request_review_id": 3160624315,
      "id": 2304656197,
      "node_id": "PRRC_kwDOAN28mc6JXkNF",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 67,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "On all lines in this table, when the byte count is used as an adjective:\n\n```diff\n-32 byte array\n+32-byte array\n```\nand\n\n```diff\n-4 bytes unsigned integer\n+4-byte unsigned integer\n```",
      "created_at": "2025-08-27T16:49:10Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304656197",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304656197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304686355",
      "pull_request_review_id": 3160624315,
      "id": 2304686355,
      "node_id": "PRRC_kwDOAN28mc6JXrkT",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 70,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n```",
      "created_at": "2025-08-27T16:57:36Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304686355",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304686355"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304703828",
      "pull_request_review_id": 3160624315,
      "id": 2304703828,
      "node_id": "PRRC_kwDOAN28mc6JXv1U",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 110,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nThis field stores the block height and a boolean for marking that the UTXO was\ncreated by a coinbase transaction. Mostly serves to save space as the coinbase\n```",
      "created_at": "2025-08-27T17:02:40Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304703828",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304703828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 109,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304705019",
      "pull_request_review_id": 3160624315,
      "id": 2304705019,
      "node_id": "PRRC_kwDOAN28mc6JXwH7",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 114,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nconfirmed this transaction by one bit, and then setting the least significant bit to 1 only\n```",
      "created_at": "2025-08-27T17:03:02Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304705019",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304705019"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304707067",
      "pull_request_review_id": 3160624315,
      "id": 2304707067,
      "node_id": "PRRC_kwDOAN28mc6JXwn7",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 130,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nThe boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n```",
      "created_at": "2025-08-27T17:03:39Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304707067",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304707067"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304722258",
      "pull_request_review_id": 3160624315,
      "id": 2304722258,
      "node_id": "PRRC_kwDOAN28mc6JX0VS",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 150,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Perhaps consider \"output script\" as \"scriptPubKey\" is just Bitcoin Coreâ€™s variable name for that field.\n\n```suggestion\n##### Output script size\n\nAs the output script (\"scriptPubKey\" in Bitcoin Core) is a variable length byte array, we prepend it with the\nlength.\n\n##### Output Script\n\nThis field is added to commit to the output script of the UTXO. With current\nnodes, this is stored in the UTXO set but since we receive this in the proof\nfrom our peers, we need to commit to this value to avoid malicious peers that\nmay send over the wrong output script.\n```",
      "created_at": "2025-08-27T17:08:12Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304722258",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304722258"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 140,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304739014",
      "pull_request_review_id": 3160624315,
      "id": 2304739014,
      "node_id": "PRRC_kwDOAN28mc6JX4bG",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 173,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n- Outputs whose output script starts with an OP_RETURN (0x6a)\n```",
      "created_at": "2025-08-27T17:13:00Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304739014",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304739014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 173,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304915942",
      "pull_request_review_id": 3160624315,
      "id": 2304915942,
      "node_id": "PRRC_kwDOAN28mc6JYjnm",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 174,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n- Outputs with an output script larger than 10,000 bytes\n```",
      "created_at": "2025-08-27T18:04:28Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304915942",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304915942"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 174,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304918712",
      "pull_request_review_id": 3160624315,
      "id": 2304918712,
      "node_id": "PRRC_kwDOAN28mc6JYkS4",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 186,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\npossible but doesn't serve any purpose - once outputs are spent, their past existence\n```",
      "created_at": "2025-08-27T18:05:59Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304918712",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304918712"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304924164",
      "pull_request_review_id": 3160624315,
      "id": 2304924164,
      "node_id": "PRRC_kwDOAN28mc6JYloE",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 199,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For the time being, maybe just use `[â€ŽBIP Utreexo Accumulator](â€Žutreexo-accumulator-bip.md)` to clarify whether you are referring to one or the other.",
      "created_at": "2025-08-27T18:08:27Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304924164",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304924164"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 198,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304928126",
      "pull_request_review_id": 3160624315,
      "id": 2304928126,
      "node_id": "PRRC_kwDOAN28mc6JYml-",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 204,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ditto",
      "created_at": "2025-08-27T18:10:20Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304928126",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304928126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304928350",
      "pull_request_review_id": 3160624315,
      "id": 2304928350,
      "node_id": "PRRC_kwDOAN28mc6JYmpe",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 213,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ditto",
      "created_at": "2025-08-27T18:10:26Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304928350",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304928350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 213,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304930364",
      "pull_request_review_id": 3160624315,
      "id": 2304930364,
      "node_id": "PRRC_kwDOAN28mc6JYnI8",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 218,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nFor (1), positions are in the order of the leaves that are being proven in\n```",
      "created_at": "2025-08-27T18:11:24Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304930364",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304930364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304944981",
      "pull_request_review_id": 3160624315,
      "id": 2304944981,
      "node_id": "PRRC_kwDOAN28mc6JYqtV",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 224,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For some reason I had thought that the accumulator proof was a Merkle branch, but now reading this, it makes me think that the proofs are built-up from the leaf preimages. Which of the two is correct, and could you perhaps check whether some more clarification should be added here to make it unambiguous? \nThis might also just be me mixing up something as Iâ€™m trying to puzzle together everything that is going on.",
      "created_at": "2025-08-27T18:16:25Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304944981",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304944981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 223,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304952139",
      "pull_request_review_id": 3160624315,
      "id": 2304952139,
      "node_id": "PRRC_kwDOAN28mc6JYsdL",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 237,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nThe end result of the UTXO proof validation results in the vector of UTXO\n```",
      "created_at": "2025-08-27T18:18:45Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304952139",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304952139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 237,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304955391",
      "pull_request_review_id": 3160624315,
      "id": 2304955391,
      "node_id": "PRRC_kwDOAN28mc6JYtP_",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-????.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the preceding",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 258,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\ntransactions shared a same TXID, the transaction outputs of the succeeding\n```",
      "created_at": "2025-08-27T18:20:01Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304955391",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304955391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304981350",
      "pull_request_review_id": 3160624315,
      "id": 2304981350,
      "node_id": "PRRC_kwDOAN28mc6JYzlm",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-????.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the preceding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it's trivially easy to create a transaction that share\n+the same `TXID` for coinbase transactions by re-using the same bitcoin address.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 261,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: Itâ€™s not just that the TXID is the same, the entire transaction is the same.",
      "created_at": "2025-08-27T18:30:28Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304981350",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304981350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 260,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304982351",
      "pull_request_review_id": 3160624315,
      "id": 2304982351,
      "node_id": "PRRC_kwDOAN28mc6JYz1P",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-????.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the preceding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it's trivially easy to create a transaction that share\n+the same `TXID` for coinbase transactions by re-using the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrites an existing UTXO.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 264,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\ndo not have outputs that overwrite an existing UTXO.\n```",
      "created_at": "2025-08-27T18:30:52Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304982351",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304982351"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304994489",
      "pull_request_review_id": 3160624315,
      "id": 2304994489,
      "node_id": "PRRC_kwDOAN28mc6JY2y5",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-????.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the preceding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it's trivially easy to create a transaction that share\n+the same `TXID` for coinbase transactions by re-using the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrites an existing UTXO.\n+\n+`BIP-0034` was a rule where the block height was included in the script signature",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 266,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What was called originally \"generator transaction\" is now more familiarly referred to as a \"coinbase transaction\" after the \"scriptSig\" equivalent being called \"coinbase field\" in that context.\n\n```suggestion\n`BIP-0034` introduces a rule that requires the block height to be included in the coinbase field\n```",
      "created_at": "2025-08-27T18:35:43Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2304994489",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2304994489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305002690",
      "pull_request_review_id": 3160624315,
      "id": 2305002690,
      "node_id": "PRRC_kwDOAN28mc6JY4zC",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-????.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the preceding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it's trivially easy to create a transaction that share\n+the same `TXID` for coinbase transactions by re-using the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrites an existing UTXO.\n+\n+`BIP-0034` was a rule where the block height was included in the script signature\n+of the coinbase transaction. One of the reason for the change was to make",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 267,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As far as I can tell, the rest of BIPâ€¯34 explains the activation mechanism of BIPâ€¯34, so I would claim that this is the main reason.\n\n```suggestion\nof the coinbase transaction. The main reason for the change was to make\n```",
      "created_at": "2025-08-27T18:39:17Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2305002690",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305002690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305007849",
      "pull_request_review_id": 3160624315,
      "id": 2305007849,
      "node_id": "PRRC_kwDOAN28mc6JY6Dp",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-????.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the preceding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it's trivially easy to create a transaction that share\n+the same `TXID` for coinbase transactions by re-using the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrites an existing UTXO.\n+\n+`BIP-0034` was a rule where the block height was included in the script signature\n+of the coinbase transaction. One of the reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest block\n+heights are: 209,921, 490,897, and 1,983,702.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 271,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nrandom bytes that could be interpreted as block heights. The lowest implicated block\nheights are: 209,921, 490,897, and 1,983,702.\n```",
      "created_at": "2025-08-27T18:41:25Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2305007849",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305007849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 270,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 271,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305022050",
      "pull_request_review_id": 3160624315,
      "id": 2305022050,
      "node_id": "PRRC_kwDOAN28mc6JY9hi",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-????.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the preceding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it's trivially easy to create a transaction that share\n+the same `TXID` for coinbase transactions by re-using the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrites an existing UTXO.\n+\n+`BIP-0034` was a rule where the block height was included in the script signature\n+of the coinbase transaction. One of the reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest block\n+heights are: 209,921, 490,897, and 1,983,702.\n+\n+Up until block 209,921 the BIP-0030 checks are performed for non-Utreexo nodes.\n+Since Utreexo nodes only keep the UTXO set commitment, it's not possible to\n+perform the `BIP-0030` check. In theory, those blocks can't be reorged, because\n+of checkpoints, that goes back to block height 295,000 with the block hash\n+`00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983`. Any chain that\n+doesn't include this block at height 295,000 isn't valid as removing this check\n+would be a hard-fork. We note, however, that after version `0.30`, Bitcoin Core\n+will remove the checkpoints[^1], as they are not needed anymore to prevent attacks\n+against nodes during Initial Block Download. This is effectively a hard-fork,\n+that will probably never actually happen, however.\n+\n+Block 1,983,702 is the first block that Utreexo nodes would be in danger of a\n+consensus failure due to the inability to perform the BIP-0030 checks. However,",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 285,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nconsensus failure due to the inability to perform the BIP-0030 checks, if someone were to reuse coinbase transaction from block 164,384 . However,\n```",
      "created_at": "2025-08-27T18:47:35Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2305022050",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305022050"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 285,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305024910",
      "pull_request_review_id": 3160624315,
      "id": 2305024910,
      "node_id": "PRRC_kwDOAN28mc6JY-OO",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-????.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the preceding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it's trivially easy to create a transaction that share\n+the same `TXID` for coinbase transactions by re-using the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrites an existing UTXO.\n+\n+`BIP-0034` was a rule where the block height was included in the script signature\n+of the coinbase transaction. One of the reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest block\n+heights are: 209,921, 490,897, and 1,983,702.\n+\n+Up until block 209,921 the BIP-0030 checks are performed for non-Utreexo nodes.\n+Since Utreexo nodes only keep the UTXO set commitment, it's not possible to\n+perform the `BIP-0030` check. In theory, those blocks can't be reorged, because\n+of checkpoints, that goes back to block height 295,000 with the block hash\n+`00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983`. Any chain that\n+doesn't include this block at height 295,000 isn't valid as removing this check\n+would be a hard-fork. We note, however, that after version `0.30`, Bitcoin Core\n+will remove the checkpoints[^1], as they are not needed anymore to prevent attacks\n+against nodes during Initial Block Download. This is effectively a hard-fork,\n+that will probably never actually happen, however.\n+\n+Block 1,983,702 is the first block that Utreexo nodes would be in danger of a\n+consensus failure due to the inability to perform the BIP-0030 checks. However,\n+this block will happen in roughly 21 years from now, and some mitigations have been\n+proposed [^2].\n+\n+### Historical BIP-0030 violations\n+\n+There were two UTXOs that were overwritten due to this consensus rule are:",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 291,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Not due to this rule, but rather before it was introduced:\n\n```suggestion\nThere were two UTXOs that were overwritten by repeated transactions:\n```",
      "created_at": "2025-08-27T18:48:53Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2305024910",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305024910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 291,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305031178",
      "pull_request_review_id": 3160624315,
      "id": 2305031178,
      "node_id": "PRRC_kwDOAN28mc6JY_wK",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                             |\n+| ------------------- | ------------------- | --------- | --------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-????|\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results us in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-????.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the preceding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it's trivially easy to create a transaction that share\n+the same `TXID` for coinbase transactions by re-using the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrites an existing UTXO.\n+\n+`BIP-0034` was a rule where the block height was included in the script signature\n+of the coinbase transaction. One of the reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest block\n+heights are: 209,921, 490,897, and 1,983,702.\n+\n+Up until block 209,921 the BIP-0030 checks are performed for non-Utreexo nodes.\n+Since Utreexo nodes only keep the UTXO set commitment, it's not possible to\n+perform the `BIP-0030` check. In theory, those blocks can't be reorged, because\n+of checkpoints, that goes back to block height 295,000 with the block hash\n+`00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983`. Any chain that\n+doesn't include this block at height 295,000 isn't valid as removing this check\n+would be a hard-fork. We note, however, that after version `0.30`, Bitcoin Core\n+will remove the checkpoints[^1], as they are not needed anymore to prevent attacks\n+against nodes during Initial Block Download. This is effectively a hard-fork,\n+that will probably never actually happen, however.\n+\n+Block 1,983,702 is the first block that Utreexo nodes would be in danger of a\n+consensus failure due to the inability to perform the BIP-0030 checks. However,\n+this block will happen in roughly 21 years from now, and some mitigations have been\n+proposed [^2].\n+\n+### Historical BIP-0030 violations\n+\n+There were two UTXOs that were overwritten due to this consensus rule are:\n+`e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468:0` at block height 91,722\n+`d5d27987d2a3dfc724e359870c6644b40e497bdc0589a033220fe15429d88599:0` at block height 91,812\n+\n+Since the leaf hashes that are committed to the Utreexo accumulator commit to\n+the block hash as well, all the leaf hashes are unique and the two historical\n+violations do not happen with how the UTXO set is represented with the Utreexo\n+accumulator. To be consensus compatible with clients that do have the historical\n+violations, the leaves representing these two UTXOs in the Utreexo accumulator\n+are hardcoded as unspendable.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 300,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If Iâ€™m understanding this right:\n\n```suggestion\naccumulator. To be consensus compatible with clients that retain only the second\noccurrences of these outputs, the leaves representing the corresponding first UTXOs in the Utreexo accumulator\nare hardcoded as unspendable.\n```",
      "created_at": "2025-08-27T18:51:27Z",
      "updated_at": "2025-08-27T18:56:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2305031178",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2305031178"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 298,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 300,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308560981",
      "pull_request_review_id": 3166548243,
      "id": 2308560981,
      "node_id": "PRRC_kwDOAN28mc6JmdhV",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 28,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "little caching â†¦ almost no caching\na little caching â†¦ some caching\n\nI think you mean the latter:\n\n```suggestion\nIt's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n```",
      "created_at": "2025-08-28T21:10:57Z",
      "updated_at": "2025-08-28T22:50:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308560981",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308560981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308572658",
      "pull_request_review_id": 3166548243,
      "id": 2308572658,
      "node_id": "PRRC_kwDOAN28mc6JmgXy",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 50,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Itâ€™s not  clear to me how \"bridge nodes should in fact be indistinguishable from CSNs on the network\". By whom are they indistinguishable. In what regard are they indistinguishable? Shouldnâ€™t they, e.g., be frequently the first peer to notify about new transactions appearing in the mempool and blocks having been found as they act as the translation layer and therefore the initial source of data for the Utreexo-portion of the node network?",
      "created_at": "2025-08-28T21:16:07Z",
      "updated_at": "2025-08-28T22:50:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308572658",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308572658"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308578672",
      "pull_request_review_id": 3166548243,
      "id": 2308578672,
      "node_id": "PRRC_kwDOAN28mc6Jmh1w",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 51,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Does \"Bridge node\" refer to the aspect of whether the node has the UTXO set, and does \"archive node\" refer to having the full set of data? I.e., are these different dimensions? Would you run an \"archive bridge node\" if you want to offer all services?\n\nEdit: Oh, never mind, you answer that right below.",
      "created_at": "2025-08-28T21:19:21Z",
      "updated_at": "2025-08-28T22:50:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308578672",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308578672"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308585780",
      "pull_request_review_id": 3166548243,
      "id": 2308585780,
      "node_id": "PRRC_kwDOAN28mc6Jmjk0",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 60,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nWhen introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n```",
      "created_at": "2025-08-28T21:23:00Z",
      "updated_at": "2025-08-28T22:50:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308585780",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308585780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308586273",
      "pull_request_review_id": 3166548243,
      "id": 2308586273,
      "node_id": "PRRC_kwDOAN28mc6Jmjsh",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 61,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nFirst, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n```",
      "created_at": "2025-08-28T21:23:18Z",
      "updated_at": "2025-08-28T22:50:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308586273",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308586273"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308589825",
      "pull_request_review_id": 3166548243,
      "id": 2308589825,
      "node_id": "PRRC_kwDOAN28mc6JmkkB",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 71,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"Verifies that they connect\" feels a bit overly reductive.\n\n```suggestion\nConventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n```",
      "created_at": "2025-08-28T21:25:20Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308589825",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308589825"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308598686",
      "pull_request_review_id": 3166548243,
      "id": 2308598686,
      "node_id": "PRRC_kwDOAN28mc6Jmmue",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 78,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nThis flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n```",
      "created_at": "2025-08-28T21:31:09Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308598686",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308598686"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308604736",
      "pull_request_review_id": 3166548243,
      "id": 2308604736,
      "node_id": "PRRC_kwDOAN28mc6JmoNA",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 89,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I donâ€™t understand what you mean with \"hard-coded in the binary\".",
      "created_at": "2025-08-28T21:35:28Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308604736",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308604736"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308606772",
      "pull_request_review_id": 3166548243,
      "id": 2308606772,
      "node_id": "PRRC_kwDOAN28mc6Jmos0",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 91,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nThe TTL commitment scheme is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n```",
      "created_at": "2025-08-28T21:36:55Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308606772",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308606772"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308612608",
      "pull_request_review_id": 3166548243,
      "id": 2308612608,
      "node_id": "PRRC_kwDOAN28mc6JmqIA",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 97,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Throughout this BIP: I donâ€™t think \"current\" is a future-proof term to distinguish the established behavior of nodes from Utreexo nodes. Perhaps \"conventional\" or \"non-Utreexo nodes\" would be a better fit?",
      "created_at": "2025-08-28T21:41:18Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308612608",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308612608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308632290",
      "pull_request_review_id": 3166548243,
      "id": 2308632290,
      "node_id": "PRRC_kwDOAN28mc6Jmu7i",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 98,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nIf the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n```",
      "created_at": "2025-08-28T21:54:03Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308632290",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308632290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308635965",
      "pull_request_review_id": 3166548243,
      "id": 2308635965,
      "node_id": "PRRC_kwDOAN28mc6Jmv09",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 107,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n\nA hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n```",
      "created_at": "2025-08-28T21:56:34Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308635965",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308635965"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 106,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308638564",
      "pull_request_review_id": 3166548243,
      "id": 2308638564,
      "node_id": "PRRC_kwDOAN28mc6Jmwdk",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 108,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Please donâ€™t use abbreviations like \"tx\" in the running text.\n\n```suggestion\nWhen sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n```",
      "created_at": "2025-08-28T21:58:05Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308638564",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308638564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308638965",
      "pull_request_review_id": 3166548243,
      "id": 2308638965,
      "node_id": "PRRC_kwDOAN28mc6Jmwj1",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 109,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nThe Utreexo merkle tree positions are explained in detail in \"BIP Utreexo Accumulator Specification\".\n```",
      "created_at": "2025-08-28T21:58:22Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308638965",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308638965"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308658821",
      "pull_request_review_id": 3166548243,
      "id": 2308658821,
      "node_id": "PRRC_kwDOAN28mc6Jm1aF",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 105,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This section feels ambiguous to me.\n\nWith the graphic labeling the first box that contains \"type:transaction, hash: tx hash (a)\" as `invvect`, I am now wondering whether Utreexo nodes use the `inv` message to announce messages to each other extended by `invvect` data, or whether they send `invvect` messages instead of `inv messages`.",
      "created_at": "2025-08-28T22:12:30Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308658821",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308658821"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308661288",
      "pull_request_review_id": 3166548243,
      "id": 2308661288,
      "node_id": "PRRC_kwDOAN28mc6Jm2Ao",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 108,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2308638564,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "When you write \"send an inv message\" do you actually mean \"announce a new transaction\" rather than literally a `inv` message being sent?",
      "created_at": "2025-08-28T22:14:42Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308661288",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308661288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308665179",
      "pull_request_review_id": 3166548243,
      "id": 2308665179,
      "node_id": "PRRC_kwDOAN28mc6Jm29b",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 108,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2308638564,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The use of `inv` message here seems confusing. Itâ€™s not clear to me whether it is meant literal or as a stand in for \"transaction announcement\". First I even thought you were describing the message that transfers the entire transaction because you already were sending the `utreexoproofhash` along. If this is actually describing how Utreexo nodes announce transactions to each other, instead of saying \"to send an inv message\", it could better be introduces e.g., as \n\n> \"Where conventional nodes us a `inv` message to announce a new transaction, Utreexo nodes use the `invvect` message to announce new transactions to Utreexo peers.\"\n\nIt would perhaps also help if you explain why the `utreexoproofhash` would need to be sent with announcement of the transactionâ€”I would have expected them to only be necessary when the transaction data is sent.\n\nEither way, this section is confusing to me.",
      "created_at": "2025-08-28T22:17:57Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308665179",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308665179"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308670568",
      "pull_request_review_id": 3166548243,
      "id": 2308670568,
      "node_id": "PRRC_kwDOAN28mc6Jm4Ro",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 115,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Scrolling up and down through this document, itâ€™s sometimes difficult to tell whether a paragraph belongs to the image before or after the paragraph. Since Markdown does not allow captions on images, it could for example help if either the images included the caption, or if the text were structured in some way that makes it clearer.",
      "created_at": "2025-08-28T22:22:26Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308670568",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308670568"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308683581",
      "pull_request_review_id": 3166548243,
      "id": 2308683581,
      "node_id": "PRRC_kwDOAN28mc6Jm7c9",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 131,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Consistency: Previously you were referring to non-Utreexo nodes as \"current nodes\", now itâ€™s \"legacy\". Please use one term to refer to the same concept across the entire document.",
      "created_at": "2025-08-28T22:27:06Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308683581",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308683581"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 129,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308695281",
      "pull_request_review_id": 3166548243,
      "id": 2308695281,
      "node_id": "PRRC_kwDOAN28mc6Jm-Tx",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.\n+The committed data is defined in BIP-VALIDATION#LEAF_DATA, but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely just omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 202,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nTherefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n```",
      "created_at": "2025-08-28T22:37:23Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308695281",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308695281"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308698998",
      "pull_request_review_id": 3166548243,
      "id": 2308698998,
      "node_id": "PRRC_kwDOAN28mc6Jm_N2",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.\n+The committed data is defined in BIP-VALIDATION#LEAF_DATA, but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely just omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [Utreexo - Validation Layer](./utreexo-validation-bip.md#Excluded UTXOs from the accumulator) for the UTXOs that are not added to the Utreexo merkle forest |",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 242,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [Utreexo - Validation Layer](./utreexo-validation-bip.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n```",
      "created_at": "2025-08-28T22:40:45Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308698998",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308698998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308701498",
      "pull_request_review_id": 3166548243,
      "id": 2308701498,
      "node_id": "PRRC_kwDOAN28mc6Jm_06",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.\n+The committed data is defined in BIP-VALIDATION#LEAF_DATA, but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely just omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [Utreexo - Validation Layer](./utreexo-validation-bip.md#Excluded UTXOs from the accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](./utreexo-accumulator-bip.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](./utreexo-validation-bip.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](./utreexo-accumulator-bip.md#Utility Functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 287,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nUsing the [proof_positions](./utreexo-accumulator-bip.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n```",
      "created_at": "2025-08-28T22:42:57Z",
      "updated_at": "2025-08-28T22:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2308701498",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2308701498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 287,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309589276",
      "pull_request_review_id": 3108832141,
      "id": 2309589276,
      "node_id": "PRRC_kwDOAN28mc6JqYkc",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 56,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2299081095,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Technically the current Utreexo design is O(log2(N)) of all txos since the forest doesn't shrink on a deletion. We just move the leaf up so it has the same affect as shrinking the forest.",
      "created_at": "2025-08-29T08:53:36Z",
      "updated_at": "2025-09-07T12:58:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2309589276",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309589276"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 55,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309601615",
      "pull_request_review_id": 3108832141,
      "id": 2309601615,
      "node_id": "PRRC_kwDOAN28mc6JqblP",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 66,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2291920873,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oh no the duplication is intended.\r\n\r\nSince we use `SHA512/256` as the hash function, each chunk is 128 bytes. Since the version tag is only 64 bytes, we need two of them.",
      "created_at": "2025-08-29T08:58:51Z",
      "updated_at": "2025-09-07T12:58:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2309601615",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309601615"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 63,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309620449",
      "pull_request_review_id": 3108832141,
      "id": 2309620449,
      "node_id": "PRRC_kwDOAN28mc6JqgLh",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 176,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2299099519,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Does this ambiguity regarding the depth of the leaf in the tree not introduce similar weaknesses as the original Merkle tree construction?\r\n\r\nNot quite sure which weakness you're referring to here. Is it CVE-2012-2459 (one from calculating the Bitcoin block header commitment)? Since we don't duplicate hashes, it's not vulnerable to that particular attack.\r\n\r\n> Why would we float up leaf-hashes rather than create a tagged hash at each level?\r\n\r\nSince we float up the leaf hashes, we can save on the proofs being sent over for the sibling later on.\r\n\r\nOn a tree like so, proof for `01` is `00`, `09`, `13`.\r\n\r\n```\r\n14\r\n|---------------\\\r\n12              13\r\n|-------\\       |-------\\\r\n08      09      10      11\r\n|---\\   |---\\   |---\\   |---\\\r\n00  01  02  03  04  05  06  07\r\n```\r\n\r\nIf we delete `00`, then `01` moves up to `08`. The proof for `01` is now `09` and `13`. The proof got shorter.\r\n\r\n```\r\n14\r\n|---------------\\\r\n12              13\r\n|-------\\       |-------\\\r\n01      09      10      11\r\n|---\\   |---\\   |---\\   |---\\\r\n        02  03  04  05  06  07\r\n```",
      "created_at": "2025-08-29T09:07:08Z",
      "updated_at": "2025-09-07T12:58:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2309620449",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309620449"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309666638",
      "pull_request_review_id": 3108832141,
      "id": 2309666638,
      "node_id": "PRRC_kwDOAN28mc6JqrdO",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 191,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2299106678,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah it's because we wanted `treerows` to return the index of the largest tree not the length.\r\nFor the below tree, `numleaves = 4` but we want `treerows` to return `2` not `3`.\r\n\r\n```\r\nrow 2: 06\r\n       |-------\\\r\nrow 1: 04      05\r\n       |---\\   |---\\\r\nrow 0: 00  01  02  03\r\n```\r\n\r\nIf we just took the minimum number of bits to represent `numleaves = 4`, we'd get `3`. So to account for this, we take the minimum number of bits needed to represent `numleaves-1`. This off-by-one happens when `numleaves` is a power of two.\r\n\r\n@adiabat did talk about wanting to make `treerows` return the length and not the index a while back so last chance to speak up? :)\r\n\r\nI've added the explanation in the bip as well.",
      "created_at": "2025-08-29T09:26:23Z",
      "updated_at": "2025-09-07T12:58:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2309666638",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309666638"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309759422",
      "pull_request_review_id": 3108832141,
      "id": 2309759422,
      "node_id": "PRRC_kwDOAN28mc6JrCG-",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 224,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2304944981,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> For some reason I had thought that the accumulator proof was a Merkle branch, but now reading this, it makes me think that the proofs are built-up from the leaf preimages. Which of the two is correct, and could you perhaps check whether some more clarification should be added here to make it unambiguous?\r\n\r\nYou are right, there's the merkle branches themselves and the leaf preimages are an entirely separate data apart from that.\r\n\r\nI'll read it over again and make clarifications where needed.",
      "created_at": "2025-08-29T10:08:22Z",
      "updated_at": "2025-09-07T12:58:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2309759422",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309759422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 223,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309926828",
      "pull_request_review_id": 3108832141,
      "id": 2309926828,
      "node_id": "PRRC_kwDOAN28mc6Jrq-s",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 50,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2308572658,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Itâ€™s not clear to me how \"bridge nodes should in fact be indistinguishable from CSNs on the network\". By whom are they indistinguishable. In what regard are they indistinguishable?\r\n\r\nThey're indistinguishable as we don't explicitly specify which nodes are bridges. The sentence was an attempt at clarifying a common misconception that a CSN must connect to bridge nodes.\r\n\r\n>Shouldnâ€™t they, e.g., be frequently the first peer to notify about new transactions appearing in the mempool and blocks having been found as they act as the translation layer and therefore the initial source of data for the Utreexo-portion of the node network?\r\n\r\nYes this is true. They usually should be the first to notify utreexo peers about new txs and blocks",
      "created_at": "2025-08-29T11:31:31Z",
      "updated_at": "2025-09-07T12:58:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2309926828",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309926828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309944250",
      "pull_request_review_id": 3108832141,
      "id": 2309944250,
      "node_id": "PRRC_kwDOAN28mc6JrvO6",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 89,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2308604736,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oh I should clarify this.\r\n\r\nSince nothing is being committed to the TTL messages, a node can just lie about the values in the message. To prevent this, the node should either:\r\n\r\n1: don't download too far into the future since the damage done will be greater.\r\n2: rely on the pre-committed (aka \"hard coded into the binary\") ttl accumulator in the node software. The ttl accumulator has ttls for each of the blocks accumulated. With this accumulator, the node can check if the received ttl is valid or invalid by checking for its existence in the ttl accumulator.",
      "created_at": "2025-08-29T11:40:37Z",
      "updated_at": "2025-09-07T12:58:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2309944250",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2309944250"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2314801802",
      "pull_request_review_id": 3174745474,
      "id": 2314801802,
      "node_id": "PRRC_kwDOAN28mc6J-RKK",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 176,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2299099519,
      "user": {
        "login": "adiabat",
        "id": 22841402,
        "node_id": "MDQ6VXNlcjIyODQxNDAy",
        "avatar_url": "https://avatars.githubusercontent.com/u/22841402?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adiabat",
        "html_url": "https://github.com/adiabat",
        "followers_url": "https://api.github.com/users/adiabat/followers",
        "following_url": "https://api.github.com/users/adiabat/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adiabat/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adiabat/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adiabat/subscriptions",
        "organizations_url": "https://api.github.com/users/adiabat/orgs",
        "repos_url": "https://api.github.com/users/adiabat/repos",
        "events_url": "https://api.github.com/users/adiabat/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adiabat/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That's a good point, and we can add a bit about this potential issue in the BIP.\r\n\r\nLeaves can move up, and it's no longer leaves getting hashed with leaves, but leaf/internal node pairs happen often.  An attack would be to grind through transactions to get two leaf hashes that together could look like a leaf data preimage for a rogue UTXO. \r\n\r\nThe reason this isn't a problem is that in all cases when a node is verifying a UTXO proof, the full UTXO data is known and a keyed hash is used (see \"UTXO Hash Preimages\" section of the validation BIP) to get from the UTXO data to the leaf.  The first 128 bytes input to the hash function are the tags (the hash of \"UtreexoV1\").  Since this tag is only used for UTXO data, and not in internal accumulator hashes, this should prevent any internal hashes from being interpreted as UTXO data.",
      "created_at": "2025-09-02T02:52:06Z",
      "updated_at": "2025-09-02T02:52:06Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2314801802",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2314801802"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2314805353",
      "pull_request_review_id": 3174749361,
      "id": 2314805353,
      "node_id": "PRRC_kwDOAN28mc6J-SBp",
      "diff_hunk": "@@ -0,0 +1,328 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Validation Layer\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2023-10-01\n+License: BSD-3-Clause\n+Requires: BIP-???? (Utreexo Accumulator Specification)\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see BIP-????. This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32 byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32 byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name              | Type                     | Description                               |\n+| ----------------- | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1    | 64 byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash         | 32 byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID              | 32 byte array            | The transaction's TXID                    |\n+| Vout              | 4 bytes unsigned integer | The output index of this UTXO             |\n+| Header code       | 4 bytes unsigned integer | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount            | 8 bytes unsigned integer | The amount in satoshis for this UTXO      |\n+| scriptPubkey size | varint                   | scriptPubKey length in bytes              |\n+| scriptPubkey      | variable byte array      | The locking script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use tagged hashes for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64 byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO is\n+part of a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### script pubkey size\n+\n+As the script pubkey is a variable length byte array, we prepend it with the\n+length.\n+\n+##### script pubkey\n+\n+This field is added to commit to the locking script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong locking script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs that start with an OP_RETURN (0x6a)\n+- Outputs with a scriptPubkey larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in BIP-????. Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+BIP-????.\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. The accumulator proof proves that the\n+given UTXO hash preimages are committed in the accumulator.\n+\n+Accumulator proof is defined in BIP-????, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proved in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.",
      "path": "utreexo-validation-bip.md",
      "position": 1,
      "original_position": 224,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2304944981,
      "user": {
        "login": "adiabat",
        "id": 22841402,
        "node_id": "MDQ6VXNlcjIyODQxNDAy",
        "avatar_url": "https://avatars.githubusercontent.com/u/22841402?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adiabat",
        "html_url": "https://github.com/adiabat",
        "followers_url": "https://api.github.com/users/adiabat/followers",
        "following_url": "https://api.github.com/users/adiabat/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adiabat/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adiabat/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adiabat/subscriptions",
        "organizations_url": "https://api.github.com/users/adiabat/orgs",
        "repos_url": "https://api.github.com/users/adiabat/repos",
        "events_url": "https://api.github.com/users/adiabat/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adiabat/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah it's both.  First the merkle branch is needed to verify that the UTXO exists at all, then the UTXO data / leaf preimage is needed to feed in to the normal script & transaction validation.  We can make it clear that there's really 2 things stuck together here.",
      "created_at": "2025-09-02T02:56:11Z",
      "updated_at": "2025-09-02T02:56:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2314805353",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2314805353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": 223,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2314818355",
      "pull_request_review_id": 3174764203,
      "id": 2314818355,
      "node_id": "PRRC_kwDOAN28mc6J-VMz",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 50,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2308572658,
      "user": {
        "login": "adiabat",
        "id": 22841402,
        "node_id": "MDQ6VXNlcjIyODQxNDAy",
        "avatar_url": "https://avatars.githubusercontent.com/u/22841402?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adiabat",
        "html_url": "https://github.com/adiabat",
        "followers_url": "https://api.github.com/users/adiabat/followers",
        "following_url": "https://api.github.com/users/adiabat/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adiabat/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adiabat/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adiabat/subscriptions",
        "organizations_url": "https://api.github.com/users/adiabat/orgs",
        "repos_url": "https://api.github.com/users/adiabat/repos",
        "events_url": "https://api.github.com/users/adiabat/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adiabat/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe \"indistinguishable\" is too strong -- it would be great if nobody could tell, but if there are a small number of bridge nodes and a large number of CSNs it might be traceable.\r\n\r\nThe main thing is bridge nodes don't announce themselves as such; they just pass proofs and transactions around just like CSNs.  If you're a CSN connected directly to a bridge node, you might see a lot of INVs and proofs originate from that node, and they might be a bridge, but they might just be a well connected CSN.\r\n\r\nIt's similar to trying to prevent people from tracing new transactions to originating nodes, though probably in one sense harder (bridge nodes keep being bridge nodes all the time vs only getting one shot with a wallet broadcasting) but also lower stakes (determining that a node is a bridge doesn't hurt privacy or network strength that much).\r\n",
      "created_at": "2025-09-02T03:12:13Z",
      "updated_at": "2025-09-02T03:12:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2314818355",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2314818355"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2316563820",
      "pull_request_review_id": 3177267763,
      "id": 2316563820,
      "node_id": "PRRC_kwDOAN28mc6KE_Vs",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [Utreexo - Validation Layer](./utreexo-validation-bip.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are 2 thing needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial-block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+![Current IBD](bip-utreexo-p2p/current-ibd.png)\n+\n+Current IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and start downloading the actual block data for validation.\n+\n+![Utreexo node IBD](bip-utreexo-p2p/utreexo-node-ibd.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about 2 times compared to the current nodes as the inclusion proof for a block is roughly the same size as the block itself.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-utreexo-p2p/bandwidth-efficient-utreexo-node-ibd.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+Nodes can mitigate this by not downloading TTL values too far into the future or by checking if the `TTL` message received was included in the accumulator hard-coded into the binary.\n+\n+This TTL commitment scheme is described in detail [here](#Commitment scheme for TTL messages).\n+\n+### Transaction relay\n+\n+![Current TX relay](bip-utreexo-p2p/current-tx-relay.png)\n+\n+Current transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a tx matching that hash, it then requests for it using a getdata message.\n+\n+![Utreexo TX relay](bip-utreexo-p2p/utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents 4 Utreexo merkle tree positions, each of them little endian serialized and taking up 8 bytes in the 32 byte hash.\n+When sending an inv message to a Utreexo node for a tx, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the tx.\n+The Utreexo merkle tree positions are explained in detail in the bip \"Utreexo Accumulator Specification\".\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-utreexo-p2p/utreexo-tx-relay-multiple-proofhash-vectors.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+![Utreexo TX relay with multiple txs](bip-utreexo-p2p/utreexo-tx-relay-with-multiple-txs.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+### Block Propagation\n+\n+![Legacy Block Propagation](bip-utreexo-p2p/legacy-block-propagation.png)\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+![Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/legacy-block-propagation-with-utreexo-nodes.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+![Bandwidth Saving Legacy Block Propagation with Utreexo Nodes](bip-utreexo-p2p/bandwidth-saving-legacy-block-propagation-with-utreexo-nodes.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by peer.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 186,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nTo authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\r\n```",
      "created_at": "2025-09-02T16:11:40Z",
      "updated_at": "2025-09-02T16:11:41Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2316563820",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2316563820"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2316572377",
      "pull_request_review_id": 3177281231,
      "id": 2316572377,
      "node_id": "PRRC_kwDOAN28mc6KFBbZ",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 18,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> At one extreme of this gradient, nodes minimize storage and memory requirements, keeping only the roots of the hash trees, which never exceed a kilobyte.\r\n\r\nThe Utreexo paper mentions that the upper limit of the accumulator size is a single KB. What changed?",
      "created_at": "2025-09-02T16:14:45Z",
      "updated_at": "2025-09-02T18:25:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2316572377",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2316572377"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2328673780",
      "pull_request_review_id": 3108832141,
      "id": 2328673780,
      "node_id": "PRRC_kwDOAN28mc6KzL30",
      "diff_hunk": "@@ -0,0 +1,486 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo - Peer Services\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2024-08-08\n+License: BSD-3-Clause\n+Requires: <BIP-???? (Utreexo Accumulator Specification), BIP-???? (Utreexo - Validation Layer)>\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.",
      "path": "utreexo-p2p-bip.md",
      "position": 1,
      "original_position": 18,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2316572377,
      "user": {
        "login": "kcalvinalvin",
        "id": 37185887,
        "node_id": "MDQ6VXNlcjM3MTg1ODg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/37185887?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kcalvinalvin",
        "html_url": "https://github.com/kcalvinalvin",
        "followers_url": "https://api.github.com/users/kcalvinalvin/followers",
        "following_url": "https://api.github.com/users/kcalvinalvin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kcalvinalvin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kcalvinalvin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kcalvinalvin/subscriptions",
        "organizations_url": "https://api.github.com/users/kcalvinalvin/orgs",
        "repos_url": "https://api.github.com/users/kcalvinalvin/repos",
        "events_url": "https://api.github.com/users/kcalvinalvin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kcalvinalvin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's essentially still a kilobyte but since we can support leaves up to the maximum of uint64, we can have 64 roots which is 64*32 = 2048. So 2KB max.",
      "created_at": "2025-09-07T12:55:34Z",
      "updated_at": "2025-09-07T12:58:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2328673780",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2328673780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353562834",
      "pull_request_review_id": 3231566058,
      "id": 2353562834,
      "node_id": "PRRC_kwDOAN28mc6MSITS",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.",
      "path": "bip-0182.md",
      "position": 211,
      "original_position": 211,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Missing a word.\n\n```suggestion\nbut since utreexo nodes don't <missing word> this data, it must be provided.\n```",
      "created_at": "2025-09-16T20:19:29Z",
      "updated_at": "2025-09-16T20:32:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353562834",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353562834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353573970",
      "pull_request_review_id": 3231566058,
      "id": 2353573970,
      "node_id": "PRRC_kwDOAN28mc6MSLBS",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-0181.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the succeeding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it was trivially easy to create a duplicate transaction that was\n+exactly the same, resulting in a duplicate `TXID` for coinbase transactions by re-using\n+the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrite an existing UTXO.\n+\n+`BIP-0034` introduces a rule that requires the block height to be included in the coinbase field\n+of the coinbase transaction. The main reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest implicated block\n+heights are: 209,921, 490,897, and 1,983,702.\n+\n+Up until block 209,921 the BIP-0030 checks are performed for non-Utreexo nodes.\n+Since Utreexo nodes only keep the UTXO set commitment, it's not possible to\n+perform the `BIP-0030` check. In theory, those blocks can't be reorged, because\n+of checkpoints, that goes back to block height 295,000 with the block hash\n+`00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983`. Any chain that\n+doesn't include this block at height 295,000 isn't valid as removing this check\n+would be a hard-fork. We note, however, that after version `0.30`, Bitcoin Core\n+will remove the checkpoints[^1], as they are not needed anymore to prevent attacks\n+against nodes during Initial Block Download. This is effectively a hard-fork,\n+that will probably never actually happen, however.\n+\n+Block 1,983,702 is the first block that Utreexo nodes would be in danger of a\n+consensus failure due to the inability to perform the BIP-0030 checks if someone were\n+to reuse coinbase transaction from block 164,384. However, this block will happen in roughly\n+21 years from now, and some mitigations have been proposed [^2].\n+\n+### Historical BIP-0030 violations\n+\n+There were two UTXOs that were overwritten by repeated transactions:\n+`e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468:0` at block height 91,722\n+`d5d27987d2a3dfc724e359870c6644b40e497bdc0589a033220fe15429d88599:0` at block height 91,812\n+\n+Since the leaf hashes that are committed to the Utreexo accumulator commit to\n+the block hash as well, all the leaf hashes are unique and the two historical\n+violations do not happen with how the UTXO set is represented with the Utreexo\n+accumulator. To be consensus compatible with clients that retain only the second\n+occurrences of these outputs, the leaves representing the corresponding first UTXOs in the Utreexo accumulator\n+are hardcoded as unspendable.\n+\n+These two leaf hashes encoded in hex string are:\n+\n+ 1. `84b3af0783b410b4564c5d1f361868559f7cf77cfc65ce2be951210357022fe3`\n+ 2. `bc6b4bf7cebbd33a18d6b0fe1f8ecc7aa5403083c39ee343b985d51fd0295ad8`\n+\n+(1) represents the UTXO created at block height 91,722 and (2) represents the\n+UTXO created at block height 91,812.\n+\n+## Rationale\n+\n+**Why use the Utreexo accumulator to keep track of UTXOs instead of a key-value database like leveldb?**\n+\n+There's two main advantages to using the Utreexo accumulator instead of a key-value database like leveldb:",
      "path": "bip-0182.md",
      "position": 321,
      "original_position": 321,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\nThere are two main advantages to using the Utreexo accumulator instead of a key-value database like leveldb:\n```",
      "created_at": "2025-09-16T20:24:35Z",
      "updated_at": "2025-09-16T20:32:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353573970",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353573970"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 321,
      "original_line": 321,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353578176",
      "pull_request_review_id": 3231566058,
      "id": 2353578176,
      "node_id": "PRRC_kwDOAN28mc6MSMDA",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-0181.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the succeeding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it was trivially easy to create a duplicate transaction that was\n+exactly the same, resulting in a duplicate `TXID` for coinbase transactions by re-using\n+the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrite an existing UTXO.\n+\n+`BIP-0034` introduces a rule that requires the block height to be included in the coinbase field\n+of the coinbase transaction. The main reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest implicated block\n+heights are: 209,921, 490,897, and 1,983,702.\n+\n+Up until block 209,921 the BIP-0030 checks are performed for non-Utreexo nodes.\n+Since Utreexo nodes only keep the UTXO set commitment, it's not possible to\n+perform the `BIP-0030` check. In theory, those blocks can't be reorged, because\n+of checkpoints, that goes back to block height 295,000 with the block hash\n+`00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983`. Any chain that\n+doesn't include this block at height 295,000 isn't valid as removing this check\n+would be a hard-fork. We note, however, that after version `0.30`, Bitcoin Core\n+will remove the checkpoints[^1], as they are not needed anymore to prevent attacks\n+against nodes during Initial Block Download. This is effectively a hard-fork,\n+that will probably never actually happen, however.\n+\n+Block 1,983,702 is the first block that Utreexo nodes would be in danger of a\n+consensus failure due to the inability to perform the BIP-0030 checks if someone were\n+to reuse coinbase transaction from block 164,384. However, this block will happen in roughly\n+21 years from now, and some mitigations have been proposed [^2].\n+\n+### Historical BIP-0030 violations\n+\n+There were two UTXOs that were overwritten by repeated transactions:\n+`e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468:0` at block height 91,722\n+`d5d27987d2a3dfc724e359870c6644b40e497bdc0589a033220fe15429d88599:0` at block height 91,812\n+\n+Since the leaf hashes that are committed to the Utreexo accumulator commit to\n+the block hash as well, all the leaf hashes are unique and the two historical\n+violations do not happen with how the UTXO set is represented with the Utreexo\n+accumulator. To be consensus compatible with clients that retain only the second\n+occurrences of these outputs, the leaves representing the corresponding first UTXOs in the Utreexo accumulator\n+are hardcoded as unspendable.\n+\n+These two leaf hashes encoded in hex string are:\n+\n+ 1. `84b3af0783b410b4564c5d1f361868559f7cf77cfc65ce2be951210357022fe3`\n+ 2. `bc6b4bf7cebbd33a18d6b0fe1f8ecc7aa5403083c39ee343b985d51fd0295ad8`\n+\n+(1) represents the UTXO created at block height 91,722 and (2) represents the\n+UTXO created at block height 91,812.\n+\n+## Rationale\n+\n+**Why use the Utreexo accumulator to keep track of UTXOs instead of a key-value database like leveldb?**\n+\n+There's two main advantages to using the Utreexo accumulator instead of a key-value database like leveldb:\n+\n+ 1. Puts a cap on the UTXO set growth.\n+ 3. Performance gains with the elimination of random reads/writes.",
      "path": "bip-0182.md",
      "position": 324,
      "original_position": 324,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Renders right of course, but still:\n\n```suggestion\n 2. Performance gains with the elimination of random reads/writes.\n```",
      "created_at": "2025-09-16T20:26:50Z",
      "updated_at": "2025-09-16T20:32:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353578176",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353578176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 324,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353581581",
      "pull_request_review_id": 3231566058,
      "id": 2353581581,
      "node_id": "PRRC_kwDOAN28mc6MSM4N",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-0181.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the succeeding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it was trivially easy to create a duplicate transaction that was\n+exactly the same, resulting in a duplicate `TXID` for coinbase transactions by re-using\n+the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrite an existing UTXO.\n+\n+`BIP-0034` introduces a rule that requires the block height to be included in the coinbase field\n+of the coinbase transaction. The main reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest implicated block\n+heights are: 209,921, 490,897, and 1,983,702.\n+\n+Up until block 209,921 the BIP-0030 checks are performed for non-Utreexo nodes.\n+Since Utreexo nodes only keep the UTXO set commitment, it's not possible to\n+perform the `BIP-0030` check. In theory, those blocks can't be reorged, because\n+of checkpoints, that goes back to block height 295,000 with the block hash\n+`00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983`. Any chain that\n+doesn't include this block at height 295,000 isn't valid as removing this check\n+would be a hard-fork. We note, however, that after version `0.30`, Bitcoin Core\n+will remove the checkpoints[^1], as they are not needed anymore to prevent attacks\n+against nodes during Initial Block Download. This is effectively a hard-fork,\n+that will probably never actually happen, however.\n+\n+Block 1,983,702 is the first block that Utreexo nodes would be in danger of a\n+consensus failure due to the inability to perform the BIP-0030 checks if someone were\n+to reuse coinbase transaction from block 164,384. However, this block will happen in roughly\n+21 years from now, and some mitigations have been proposed [^2].\n+\n+### Historical BIP-0030 violations\n+\n+There were two UTXOs that were overwritten by repeated transactions:\n+`e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468:0` at block height 91,722\n+`d5d27987d2a3dfc724e359870c6644b40e497bdc0589a033220fe15429d88599:0` at block height 91,812\n+\n+Since the leaf hashes that are committed to the Utreexo accumulator commit to\n+the block hash as well, all the leaf hashes are unique and the two historical\n+violations do not happen with how the UTXO set is represented with the Utreexo\n+accumulator. To be consensus compatible with clients that retain only the second\n+occurrences of these outputs, the leaves representing the corresponding first UTXOs in the Utreexo accumulator\n+are hardcoded as unspendable.\n+\n+These two leaf hashes encoded in hex string are:\n+\n+ 1. `84b3af0783b410b4564c5d1f361868559f7cf77cfc65ce2be951210357022fe3`\n+ 2. `bc6b4bf7cebbd33a18d6b0fe1f8ecc7aa5403083c39ee343b985d51fd0295ad8`\n+\n+(1) represents the UTXO created at block height 91,722 and (2) represents the\n+UTXO created at block height 91,812.\n+\n+## Rationale\n+\n+**Why use the Utreexo accumulator to keep track of UTXOs instead of a key-value database like leveldb?**\n+\n+There's two main advantages to using the Utreexo accumulator instead of a key-value database like leveldb:\n+\n+ 1. Puts a cap on the UTXO set growth.\n+ 3. Performance gains with the elimination of random reads/writes.\n+\n+### Puts a cap on the UTXO set growth\n+\n+The UTXO set is the collection of unspent transaction outputs and is used to verify blocks.\n+As the amount of Bitcoin users grow, the UTXO set grows with it.\n+\n+The UTXO set is currently around 10GB in 2025 and with pruning that's all it takes to maintain a full node.\n+However, as the UTXO set grows, the disk storage requirement will grow along with it and increase the barrier to running a full node.\n+\n+Currently, the UTXO set size is $O(log(N))$ where $N$ is the number of UTXOs.\n+By utilizing the Utreexo accumulator, we're able to cap the UTXO set growth at $O(log_2(N))$.",
      "path": "bip-0182.md",
      "position": 335,
      "original_position": 335,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Given that you donâ€™t store the UTXO set, but an accumulator that commits to the UTXO set, perhaps these two sentences should be amended?",
      "created_at": "2025-09-16T20:28:35Z",
      "updated_at": "2025-09-16T20:32:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353581581",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353581581"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 334,
      "original_start_line": 334,
      "start_side": "RIGHT",
      "line": 335,
      "original_line": 335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353598841",
      "pull_request_review_id": 3231621552,
      "id": 2353598841,
      "node_id": "PRRC_kwDOAN28mc6MSRF5",
      "diff_hunk": "@@ -0,0 +1,632 @@\n+```\n+BIP: TBD\n+Layer: Peer Services\n+Title: Utreexo Accumulator Specification\n+Authors: Tadge Dryja <rx@awsomnet.org>\n+         Calvin Kim <bip@calvinkim.info>\n+         Davidson Souza <bip@dlsouza.dev>\n+Comments-URI: TBD\n+Status: Draft\n+Type: Specification\n+Created: 2025-06-18\n+License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and it's operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.",
      "path": "utreexo-accumulator-bip.md",
      "position": 1,
      "original_position": 191,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "d1d03420ac5ee234494d84358a4abd06df269f65",
      "in_reply_to_id": 2299106678,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think I understand the calculation that you are doing, but whatâ€™s a bit unclear is the reasoning behind it. Whatâ€™s the relationship between the thing you are calculating vs the input?",
      "created_at": "2025-09-16T20:36:19Z",
      "updated_at": "2025-09-16T20:36:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353598841",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353598841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906324",
      "pull_request_review_id": 3232053448,
      "id": 2353906324,
      "node_id": "PRRC_kwDOAN28mc6MTcKU",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,",
      "path": "bip-0181.md",
      "position": 56,
      "original_position": 56,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Specifying the logarithm base is redundant in big O notation, as changing the base is equivalent to multiplying by a constant factor.\r\n```suggestion\r\nTo accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log(N))$,\r\n```",
      "created_at": "2025-09-17T00:08:48Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906324",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906324"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 56,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906366",
      "pull_request_review_id": 3232053448,
      "id": 2353906366,
      "node_id": "PRRC_kwDOAN28mc6MTcK-",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest",
      "path": "bip-0181.md",
      "position": 79,
      "original_position": 79,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nEach of the hashes in the forest can be referred to by an integer label. This labeling is a convention we find easiest\r\n```",
      "created_at": "2025-09-17T00:08:51Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906366",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 79,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906417",
      "pull_request_review_id": 3232053448,
      "id": 2353906417,
      "node_id": "PRRC_kwDOAN28mc6MTcLx",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.",
      "path": "bip-0181.md",
      "position": 194,
      "original_position": 194,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It would be nice to have consistent spacing around the minus sign, there's both `numleaves - 1` and `numleaves-1`. Same goes for the equals sign below.",
      "created_at": "2025-09-17T00:08:54Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906417",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906459",
      "pull_request_review_id": 3232053448,
      "id": 2353906459,
      "node_id": "PRRC_kwDOAN28mc6MTcMb",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.\n+\n+The accumulator with `numleaves=4` is illustrated below. The highest tree is at height `2` thus `treerows(4)` should return `2`.\n+If we take the minimum number of bits required for `numleaves` we'll get `3`, which is not the value we want.\n+If we take the minimum number of bits required for `numleaves-1` we get the correct value of `2`.\n+\n+```\n+row 2: 06\n+       |-------\\\n+row 1: 04      05\n+       |---\\   |---\\\n+row 0: 00  01  02  03\n+```\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for [Utreexo - Peer Services](bip-0183.md):\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.",
      "path": "bip-0181.md",
      "position": 419,
      "original_position": 419,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n- Map `proof.targets` to their hash.\r\n```",
      "created_at": "2025-09-17T00:08:58Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906459",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906459"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 419,
      "original_line": 419,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906495",
      "pull_request_review_id": 3232053448,
      "id": 2353906495,
      "node_id": "PRRC_kwDOAN28mc6MTcM_",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.\n+\n+The accumulator with `numleaves=4` is illustrated below. The highest tree is at height `2` thus `treerows(4)` should return `2`.\n+If we take the minimum number of bits required for `numleaves` we'll get `3`, which is not the value we want.\n+If we take the minimum number of bits required for `numleaves-1` we get the correct value of `2`.\n+\n+```\n+row 2: 06\n+       |-------\\\n+row 1: 04      05\n+       |---\\   |---\\\n+row 0: 00  01  02  03\n+```\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for [Utreexo - Peer Services](bip-0183.md):\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:",
      "path": "bip-0181.md",
      "position": 432,
      "original_position": 432,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe algorithm implemented in Python:\r\n```",
      "created_at": "2025-09-17T00:09:01Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906495",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906495"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 432,
      "original_line": 432,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906523",
      "pull_request_review_id": 3232053448,
      "id": 2353906523,
      "node_id": "PRRC_kwDOAN28mc6MTcNb",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.\n+\n+The accumulator with `numleaves=4` is illustrated below. The highest tree is at height `2` thus `treerows(4)` should return `2`.\n+If we take the minimum number of bits required for `numleaves` we'll get `3`, which is not the value we want.\n+If we take the minimum number of bits required for `numleaves-1` we get the correct value of `2`.\n+\n+```\n+row 2: 06\n+       |-------\\\n+row 1: 04      05\n+       |---\\   |---\\\n+row 0: 00  01  02  03\n+```\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for [Utreexo - Peer Services](bip-0183.md):\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:",
      "path": "bip-0181.md",
      "position": 476,
      "original_position": 476,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe addition algorithm Add(`acc`, `hash`) is defined as:\r\n```",
      "created_at": "2025-09-17T00:09:03Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906523",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 476,
      "original_line": 476,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906554",
      "pull_request_review_id": 3232053448,
      "id": 2353906554,
      "node_id": "PRRC_kwDOAN28mc6MTcN6",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.\n+\n+The accumulator with `numleaves=4` is illustrated below. The highest tree is at height `2` thus `treerows(4)` should return `2`.\n+If we take the minimum number of bits required for `numleaves` we'll get `3`, which is not the value we want.\n+If we take the minimum number of bits required for `numleaves-1` we get the correct value of `2`.\n+\n+```\n+row 2: 06\n+       |-------\\\n+row 1: 04      05\n+       |---\\   |---\\\n+row 0: 00  01  02  03\n+```\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for [Utreexo - Peer Services](bip-0183.md):\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:\n+\n+- From row 0 to and **including** `treerows(acc.numleaves)`\n+  - Break if there's no root at this row.\n+  - remove the last root from `acc.roots`.",
      "path": "bip-0181.md",
      "position": 480,
      "original_position": 480,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n  - Remove the last root from `acc.roots`.\r\n```",
      "created_at": "2025-09-17T00:09:04Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906554",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906554"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 480,
      "original_line": 480,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906567",
      "pull_request_review_id": 3232053448,
      "id": 2353906567,
      "node_id": "PRRC_kwDOAN28mc6MTcOH",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.\n+\n+The accumulator with `numleaves=4` is illustrated below. The highest tree is at height `2` thus `treerows(4)` should return `2`.\n+If we take the minimum number of bits required for `numleaves` we'll get `3`, which is not the value we want.\n+If we take the minimum number of bits required for `numleaves-1` we get the correct value of `2`.\n+\n+```\n+row 2: 06\n+       |-------\\\n+row 1: 04      05\n+       |---\\   |---\\\n+row 0: 00  01  02  03\n+```\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for [Utreexo - Peer Services](bip-0183.md):\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:\n+\n+- From row 0 to and **including** `treerows(acc.numleaves)`\n+  - Break if there's no root at this row.\n+  - remove the last root from `acc.roots`.\n+    - Calculate the parent hash of the removed root and the `hash` to be added using *parent_hash*.\n+  - Make the result from `parent_hash` the new `hash`.\n+- Increment `acc.numleaves` by 1.\n+- Append `hash` to `acc.roots`.\n+\n+The algorithm implemented in python:",
      "path": "bip-0181.md",
      "position": 486,
      "original_position": 486,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe algorithm implemented in Python:\r\n```",
      "created_at": "2025-09-17T00:09:06Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906567",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906567"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 486,
      "original_line": 486,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906593",
      "pull_request_review_id": 3232053448,
      "id": 2353906593,
      "node_id": "PRRC_kwDOAN28mc6MTcOh",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.\n+\n+The accumulator with `numleaves=4` is illustrated below. The highest tree is at height `2` thus `treerows(4)` should return `2`.\n+If we take the minimum number of bits required for `numleaves` we'll get `3`, which is not the value we want.\n+If we take the minimum number of bits required for `numleaves-1` we get the correct value of `2`.\n+\n+```\n+row 2: 06\n+       |-------\\\n+row 1: 04      05\n+       |---\\   |---\\\n+row 0: 00  01  02  03\n+```\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for [Utreexo - Peer Services](bip-0183.md):\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:\n+\n+- From row 0 to and **including** `treerows(acc.numleaves)`\n+  - Break if there's no root at this row.\n+  - remove the last root from `acc.roots`.\n+    - Calculate the parent hash of the removed root and the `hash` to be added using *parent_hash*.\n+  - Make the result from `parent_hash` the new `hash`.\n+- Increment `acc.numleaves` by 1.\n+- Append `hash` to `acc.roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def add(self, hash: bytes):\n+    for row in range(tree_rows(self.numleaves)+1):\n+        if not root_present(self.numleaves, row): break\n+        root = self.roots.pop()\n+        hash = parent_hash(root, hash)\n+\n+    self.roots.append(hash)\n+    self.numleaves += 1\n+```\n+\n+## Verification\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The Verification algorithm `Verify(acc, []hash, proof) -> bool` is defined as:",
      "path": "bip-0181.md",
      "position": 506,
      "original_position": 506,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe verification algorithm `Verify(acc, []hash, proof) -> bool` is defined as:\r\n```",
      "created_at": "2025-09-17T00:09:07Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906593",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906593"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 506,
      "original_line": 506,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906615",
      "pull_request_review_id": 3232053448,
      "id": 2353906615,
      "node_id": "PRRC_kwDOAN28mc6MTcO3",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.\n+\n+The accumulator with `numleaves=4` is illustrated below. The highest tree is at height `2` thus `treerows(4)` should return `2`.\n+If we take the minimum number of bits required for `numleaves` we'll get `3`, which is not the value we want.\n+If we take the minimum number of bits required for `numleaves-1` we get the correct value of `2`.\n+\n+```\n+row 2: 06\n+       |-------\\\n+row 1: 04      05\n+       |---\\   |---\\\n+row 0: 00  01  02  03\n+```\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for [Utreexo - Peer Services](bip-0183.md):\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:\n+\n+- From row 0 to and **including** `treerows(acc.numleaves)`\n+  - Break if there's no root at this row.\n+  - remove the last root from `acc.roots`.\n+    - Calculate the parent hash of the removed root and the `hash` to be added using *parent_hash*.\n+  - Make the result from `parent_hash` the new `hash`.\n+- Increment `acc.numleaves` by 1.\n+- Append `hash` to `acc.roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def add(self, hash: bytes):\n+    for row in range(tree_rows(self.numleaves)+1):\n+        if not root_present(self.numleaves, row): break\n+        root = self.roots.pop()\n+        hash = parent_hash(root, hash)\n+\n+    self.roots.append(hash)\n+    self.numleaves += 1\n+```\n+\n+## Verification\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The Verification algorithm `Verify(acc, []hash, proof) -> bool` is defined as:\n+\n+- Raise error if length of `[]hash` differ from `proof.targets`.\n+- Get modified_roots from `CalculateRoots(acc.numleaves, []hash, Proof)`.\n+- Get `root_idxs` from `getrootidxs`.\n+- Raise error if the length of `modified_roots` and `root_idxs` do not match.\n+- Attempt to match roots in modified_roots with roots in `acc`. Raise error if we don't find all the roots in the modified_roots in `acc`.\n+- Return `true`.\n+\n+The algorithm implemented in python:",
      "path": "bip-0181.md",
      "position": 515,
      "original_position": 515,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe algorithm implemented in Python:\r\n```",
      "created_at": "2025-09-17T00:09:09Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906615",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906615"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 515,
      "original_line": 515,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906645",
      "pull_request_review_id": 3232053448,
      "id": 2353906645,
      "node_id": "PRRC_kwDOAN28mc6MTcPV",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.\n+\n+The accumulator with `numleaves=4` is illustrated below. The highest tree is at height `2` thus `treerows(4)` should return `2`.\n+If we take the minimum number of bits required for `numleaves` we'll get `3`, which is not the value we want.\n+If we take the minimum number of bits required for `numleaves-1` we get the correct value of `2`.\n+\n+```\n+row 2: 06\n+       |-------\\\n+row 1: 04      05\n+       |---\\   |---\\\n+row 0: 00  01  02  03\n+```\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for [Utreexo - Peer Services](bip-0183.md):\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:\n+\n+- From row 0 to and **including** `treerows(acc.numleaves)`\n+  - Break if there's no root at this row.\n+  - remove the last root from `acc.roots`.\n+    - Calculate the parent hash of the removed root and the `hash` to be added using *parent_hash*.\n+  - Make the result from `parent_hash` the new `hash`.\n+- Increment `acc.numleaves` by 1.\n+- Append `hash` to `acc.roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def add(self, hash: bytes):\n+    for row in range(tree_rows(self.numleaves)+1):\n+        if not root_present(self.numleaves, row): break\n+        root = self.roots.pop()\n+        hash = parent_hash(root, hash)\n+\n+    self.roots.append(hash)\n+    self.numleaves += 1\n+```\n+\n+## Verification\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The Verification algorithm `Verify(acc, []hash, proof) -> bool` is defined as:\n+\n+- Raise error if length of `[]hash` differ from `proof.targets`.\n+- Get modified_roots from `CalculateRoots(acc.numleaves, []hash, Proof)`.\n+- Get `root_idxs` from `getrootidxs`.\n+- Raise error if the length of `modified_roots` and `root_idxs` do not match.\n+- Attempt to match roots in modified_roots with roots in `acc`. Raise error if we don't find all the roots in the modified_roots in `acc`.\n+- Return `true`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def verify(self, dels: [bytes], proof: Proof) -> bool:\n+    if len(dels) != len(proof.targets):\n+        raise(\"len of dels and proof.targets differ\")\n+\n+    root_candidates = calculate_roots(self.numleaves, dels, proof)\n+    root_idxs = getrootidxs(self.numleaves, proof.targets)\n+\n+    if len(root_candidates) != len(root_idxs):\n+        raise(\"length of calculated roots from the proof and expected root count differ\")\n+\n+    for i, idx in enumerate(root_idxs):\n+        if self.roots[idx] != root_candidates[i]:\n+            raise(\"calculated roots from the proof and matched roots differ\")\n+\n+    return true\n+```\n+\n+## Deletion\n+\n+Deletion removes leaves from the accumulator. The deletion algorithm takes in a `proof` but it does not\n+verify that the proof is valid. It assumes that the passed in proof has already passed verification.\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `proof`.\n+\n+The Deletion algorithm `Delete(acc, Proof) -> acc` is defined as:",
      "path": "bip-0181.md",
      "position": 544,
      "original_position": 544,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe deletion algorithm `Delete(acc, Proof) -> acc` is defined as:\r\n```",
      "created_at": "2025-09-17T00:09:10Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906645",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 544,
      "original_line": 544,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906671",
      "pull_request_review_id": 3232053448,
      "id": 2353906671,
      "node_id": "PRRC_kwDOAN28mc6MTcPv",
      "diff_hunk": "@@ -0,0 +1,647 @@\n+```\n+  BIP: 181\n+  Layer: Peer Services\n+  Title: Utreexo Accumulator Specification\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0181\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2025-06-18\n+  License: BSD-3-Clause\n+```\n+\n+## Abstract\n+\n+This BIP describes the Utreexo accumulator and its operations. It lays down how to update the\n+accumulator as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+\n+## Motivation\n+\n+The Bitcoin network is composed of a set of nodes that validate blocks and\n+transactions as they are received. These nodes need to keep track of the current state of the network in order to\n+fulfill their role. Most importantly, they must maintain a record of all coins that\n+have been created but not yet spent, a collection known as the UTXO set.\n+\n+This set is typically stored in a database that must be accessed frequently and cannot\n+be pruned. As a result, the cost of running a node is directly tied to the size\n+of the UTXO set. Since it can grow indefinitely, bounded only by block size, it represents a\n+long-term scalability concern.\n+\n+Utreexo is a dynamic accumulator that enables the UTXO set to be represented in just a few kilobytes,\n+by requiring peers to provide additional proof data to verify the inclusion of a UTXO in the\n+accumulator. This allows for the construction of extremely lightweight nodes capable of performing\n+the same validation as a full node, without the need to store the entire UTXO set.\n+\n+This BIP defines how the Utreexo accumulator works, defining the data structure and algorithms used to\n+maintain the accumulator, as well as how to generate and verify inclusion proofs for elements in the accumulator.\n+It does not define how the accumulator is used in the Bitcoin protocol, but rather provides a foundation for future\n+BIPs that will define how to integrate Utreexo into Bitcoin validation and P2P network protocol.\n+\n+## License\n+\n+This document is licensed under the BSD-3-Clause license.\n+\n+## Preliminaries\n+\n+An accumulator is a cryptographic data structure that allows for the compact representation of a set,\n+enabling efficient membership proofs without requiring storage of the entire set. In the context of Utreexo,\n+the accumulator tracks the current set of unspent transaction outputs (UTXOs).\n+\n+The Utreexo accumulator is based on an append-only Merkle tree design introduced in [^1],\n+which provides logarithmic-sized inclusion proofs. Utreexo extends this design to support dynamic updates,\n+specifically enabling deletions from the setâ€”a requirement for tracking UTXO spends in Bitcoin.\n+To accommodate this, Utreexo changes the storage requirement from the accumulator design in [^1] to $O(log_2(N))$,\n+where N is the number of elements ever added to the set, while still keeping proof sizes small and verification efficient.\n+\n+## Merkle Forest\n+\n+The Utreexo accumulator consists of a set of Merkle trees: specifically, perfect binary trees with $2^n$ elements,\n+where each node in the tree contains a 32-byte hash. The elements being stored appear at the leavesâ€”the bottom layer of the tree.\n+The topmost node is referred to as the \"root,\" while nodes located between the leaves and the root are called \"intermediate nodes.\"\n+\n+Any integer number of elements ($N$) can be represented as a forest of such trees. On average, a set of N elements will require\n+approximately $\\frac{log_2(N)}{2}$ trees. The number and sizes of trees are determined by the binary representation of $N$:\n+each 1-bit corresponds to a tree, and its position in the binary encoding determines the size of that tree.\n+\n+For example, a forest with 5 elements (binary `0b101`) would consist of two trees: one with 4 elements (representing the 2nd bit)\n+and one with 1 element (representing the 0th bit). A forest with 8 elements (`0b1000`) would require only a single 8-element tree,\n+as 8 is a power of 2.\n+\n+More generally, for any N, the number of trees equals the number of set bits (1s) in the binary representation of N.\n+The size of each tree corresponds to the power of two represented by the position of each set bit.\n+For example, the decimal number 21 (binary `0b10101`) contains three 1-bits, meaning three trees are needed in the forest:\n+a 16-element tree ($2^4$), a 4-element tree ($2^2$), and a 1-element tree ($2^0$), with gaps at the 8-element ($2^3$)\n+and 2-element ($2^1$) positions.\n+\n+Each of the hashes in the forest can be referred by an integer label. This labeling is a convention we find easiest\n+to use but does not directly affect the design of the accumulator; other labelling systems could also work and be\n+translated to this one.\n+\n+We label positions starting at `0` on the bottom left, incrementing as we traverse the bottom row from left to right,\n+and then continue on to higher rows. There may be gaps in the label numbers when moving up a row; the label\n+numbers are \"padded out\" to the next perfect tree that could encompass the entire forest.\n+\n+For example, a forest with 8 leaves will have a single tree and positions will be labeled like this:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+While a forest with 7 leaves will look like this:\n+\n+```\n+\n+|---------------\\\n+12\n+|-------\\       |-------\\\n+08      09      10\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06\n+```\n+\n+\n+When adding another leaf to the accumulator when it's already allocated $2^N$ leaves will result in\n+the accumulator resizing to hold $2^{N+1}$ leaves. For example, when adding a leaf to the accumulator\n+state here:\n+\n+```\n+14\n+|---------------\\\n+12              13\n+|-------\\       |-------\\\n+08      09      10      11\n+|---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07\n+```\n+\n+The new accumulator will look like so:\n+\n+```\n+\n+|-------------------------------\\\n+28\n+|---------------\\               |---------------\\\n+24              25\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08\n+```\n+\n+The new accumulator with all the positions:\n+\n+```\n+30\n+|-------------------------------\\\n+28                              29\n+|---------------\\               |---------------\\\n+24              25              26              27\n+|-------\\       |-------\\       |-------\\       |-------\\\n+16      17      18      19      20      21      22      23\n+|---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\   |---\\\n+00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15\n+```\n+\n+# Definitions\n+\n+- `hash` refers to a vector of 32 byte arrays.\n+- `[]hash` refers to a vector of `hash`.\n+- `acc` refers to the Utreexo accumulator state. An `acc` is comprised of:\n+  - `roots` refers to the roots of the Merkle Trees. Represented as `[]hash`.\n+  - `numleaves` refers to the number of total leaves added to the accumulator. Represented as uint64.\n+- `root` refers to the top `hash` in a tree in the `acc`.\n+- `proof` is an inclusion proof for elements in the accumulator. It's comprised of two fields:\n+  - `targets` are the positions of the elements being proven. Represented as a vector of uint64.\n+  - `proof` are the hashes needed to hash the roots. Represented as a `[]hash`. `proof` MUST be in ascending order by the node positions.\n+    The proof is considered invalid otherwise.\n+\n+# Specification\n+\n+The hash function SHA512/256[^2] is used for the hash operations in the accumulator.\n+\n+An Utreexo accumulator implementation MUST support these 3 operations: Addition, Verification, and Deletion.\n+\n+## Utility Functions\n+\n+The following utility functions are required for performing accumulator operations:\n+\n+**parent_hash(left, right):** Returns the hash of the concatenation of two child hashes (`left` and `right`).\n+If either child is `nil`, the result is simply the non-`nil` child (treated as if the tree has a single child at that position).\n+if both children are `nil`, the result is `nil`.\n+\n+Implementation:\n+\n+```python\n+def parent_hash(left: bytes, right: bytes) -> bytes:\n+    if right is None and left is None: return None\n+    if left is None: return right\n+    if right is None: return left\n+\n+    return sha512_256(left + right)\n+```\n+\n+**treerows(numleaves):** Returns the minimum number of bits required to represent `numleaves - 1`. This corresponds to the height of the largest tree in the forest. Returns `0` if `numleaves` is `0`.\n+\n+The reason for taking the minimum number of bits required for `numleaves-1` and not `numleaves` is because when `numleaves` is a power of two, we'd get an off-by-one error.\n+\n+The accumulator with `numleaves=4` is illustrated below. The highest tree is at height `2` thus `treerows(4)` should return `2`.\n+If we take the minimum number of bits required for `numleaves` we'll get `3`, which is not the value we want.\n+If we take the minimum number of bits required for `numleaves-1` we get the correct value of `2`.\n+\n+```\n+row 2: 06\n+       |-------\\\n+row 1: 04      05\n+       |---\\   |---\\\n+row 0: 00  01  02  03\n+```\n+\n+Implementation:\n+\n+```python\n+def treerows(numleaves: int) -> int:\n+    if numleaves == 0: return 0\n+    return (numleaves - 1).bit_length()\n+```\n+\n+**is_right_sibling(position):** Returns `true` if the given `position` corresponds to a right sibling.\n+A position is on the right side if its least significant bit (LSB) is set (i.e., `position & 1 == 1`).\n+And it is the right sibling of a **given node** if all bits but the LSB are identical.\n+\n+Implementation:\n+\n+```python\n+def is_right_sibling(position: int) -> bool:\n+    return (position & 1) == 1\n+```\n+\n+**right_sibling(position):** Returns the position of the right sibling of the given `position`.\n+If `position` is already on the right side, it returns `position` unchanged.\n+Otherwise, turning on the least significant bit moves the position to the right side.\n+\n+Implementation:\n+\n+```python\n+def right_sibling(position: int) -> int:\n+    return position | 1\n+```\n+\n+**sibling(position):** Returns the position of the sibling of the given `position`.\n+If `position` is on the right side, it returns the left sibling by turning off the least significant bit.\n+If `position` is on the left side, it returns the right sibling by turning on the least significant bit.\n+\n+Implementation:\n+\n+```python\n+def sibling(position: int) -> int:\n+    return position ^ 1\n+```\n+\n+**parent(position, total_rows):** Returns the parent position of the given `position` in an accumulator with `total_rows` tree rows.\n+\n+Implementation:\n+\n+```python\n+def parent(position: int, total_rows: int) -> int:\n+    return (position >> 1) | (1 << total_rows)\n+```\n+\n+**root_position(numleaves, row, total_rows):** Returns the position of the root at the specified `row`\n+in an accumulator with `numleaves` leaves and `total_rows` rows. Returns an undefined (garbage) value if\n+no root exists at the given row. This can be calculated as:\n+\n+Implementation:\n+\n+```python\n+def root_position(numleaves: int, row: int, total_rows: int) -> int:\n+    if row < 0 or row > total_rows:\n+        raise ValueError(\"Row must be between 0 and total_rows inclusive\")\n+\n+    mask = (2 << total_rows) - 1\n+    before = numleaves & (mask << (row + 1))\n+    shifted = (before >> row) | (mask << (total_rows + 1 - row))\n+    shifted & mask\n+```\n+\n+**root_present(numleaves, row):** Returns `true` if there is a root at the specified `row`\n+in an accumulator with `numleaves` leaves.\n+\n+Implementation:\n+\n+```python\n+def root_present(numleaves: int, row: int) -> bool:\n+    return numleaves & (1 << row) != 0\n+```\n+\n+**detect_row(position, total_rows):** Returns the row at which the given `position` resides\n+in an accumulator with `total_rows` rows.\n+\n+Implementation:\n+\n+```python\n+for row in range(total_rows, -1, -1):\n+    rowbit = 1 << row\n+    if rowbit & position == 0: return total_rows-row\n+```\n+\n+**isroot(position, numleaves, total_rows):** Returns `true` if the given `position` corresponds to a root\n+in an accumulator with `numleaves` leaves and `total_rows` rows.\n+It has the following precondition:\n+\n+Implementation:\n+\n+```python\n+def isroot(position: int, numleaves: int, total_rows: int) -> bool:\n+    row = detect_row(position, total_rows)\n+    return root_present(numleaves, row) && position == root_position(numleaves, row, total_rows)\n+```\n+\n+**getrootidx(numleaves, position):** Returns the index (within the accumulator's root list)\n+of the root that will be affected when deleting the given `position`.\n+\n+Implementation:\n+\n+```python\n+def getrootidx(numleaves: int, position: int) -> int:\n+    idx = 0\n+    for row in range(tree_rows(numleaves), -1, -1):\n+        if not root_present(numleaves, row):\n+            continue\n+        pos = position\n+        for _ in range(detect_row(position, tree_rows(numleaves)), row): pos = parent(pos, tree_rows(numleaves))\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            return idx\n+        idx += 1\n+```\n+\n+**getrootidxs(numleaves, positions):** Returns a list of indexes corresponding to the roots in the accumulator state\n+that will be affected when deleting the given set of `positions`.\n+This is a wrapper around **getrootidx**, applied to each position in the input list.\n+\n+Implementation:\n+\n+```python\n+def getrootidxs(numleaves: int, positions: [int]) -> [int]:\n+    return [getrootidx(numleaves, pos) for pos in positions]\n+```\n+\n+The following utility functions are required for [Utreexo - Peer Services](bip-0183.md):\n+\n+**max_possible_pos_at_row(row, total_rows):** Returns the greatest position the row can have in the given total rows.\n+\n+Implementation:\n+\n+```python\n+def max_possible_pos_at_row(row: int, total_rows: int) -> int:\n+    mask = (2 << total_rows) - 1\n+    return ((mask << (total_rows - row)) & mask) - 1\n+```\n+\n+**is_root_position(position, num_leaves, row):** Returns if the given position is a root with the passed in num_leaves and row.\n+\n+```python\n+def is_root_position(position: int, num_leaves: int, row: int) -> bool:\n+    root_present = (num_leaves & (1 << row)) != 0\n+    root_pos = root_position(num_leaves, row, tree_rows(num_leaves))\n+    return root_present and root_pos == position\n+```\n+\n+**proof_positions(targets, num_leaves):** Returns all the positions of the proof hashes that are required to validate the given targets.\n+\n+```python\n+def proof_positions(targets: [int], num_leaves: int) -> [int]:\n+    targets.sort()\n+\n+    next_targets = []\n+    proof_positions = []\n+\n+    total_rows = tree_rows(num_leaves)\n+    for row in range(total_rows + 1):\n+        i = 0\n+        while i < len(targets):\n+            target = targets[i]\n+\n+            if target > max_possible_pos_at_row(row, total_rows):\n+                i += 1\n+                continue\n+\n+            if row != detect_row(target, total_rows):\n+                i += 1\n+                continue\n+\n+            if is_root_position(target, num_leaves, row):\n+                i += 1\n+                continue\n+\n+            if i + 1 < len(targets) and right_sib(target) == targets[i + 1]:\n+                parent_pos = parent(target, total_rows)\n+                next_targets.append(parent_pos)\n+                targets[i] = parent_pos\n+                i += 2  # skip the sibling\n+                continue\n+\n+            # Sibling is a needed proof position\n+            proof_positions.append(sibling(target))\n+            parent_pos = parent(target, total_rows)\n+            next_targets.append(parent_pos)\n+            targets[i] = parent_pos\n+            i += 1\n+\n+        targets.sort()\n+\n+    return proof_positions\n+```\n+\n+### CalculateRoots\n+\n+Both the Verification and Deletion operations depend on the Calculate Roots function.\n+\n+- Inputs:\n+  - `acc.numleaves`.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The passed in `[]hash` and `proof.targets` should be in the same order. The element at index `i` in `[]hashes` should\n+be the hash for element at index `i` in `proof.targets`. Otherwise the returned roots will be invalid.\n+\n+The calculate roots algorithm is defined as `CalculateRoots(numleaves, []hash, proof) -> calculated_roots`:\n+\n+- Check if length of `proof.targets` is equal to the length of `[]hash`. Return early if they're not equal.\n+- map `proof.targets` to their hash.\n+- Sort `proof.targets`.\n+- Loop until `proof.targets` are empty:\n+  - Pop off the first target in `proof.targets`. Pop off the associated `hash` as well.\n+  - If the target is a root, we append the current position's `hash` to the calculated_roots vector and continue.\n+  - Check if the next target in `proof.targets` is the right sibling of the current target. If it is, grab its hash as the sibling hash. Otherwise the next hash in `proof.proof` is the sibling hash. Raise error if `proof.proof` is empty.\n+  - Figure out if the sibling hash is on the left or the right.\n+  - Apply *parent_hash* to the current position's `hash` and the sibling `hash` with regards to their positioning.\n+  - Calculate parent position.\n+  - Insert parent position into the sorted `proof.targets`.\n+  - Map parent hash to the parent position.\n+- Return calculated_roots\n+\n+The algorithm implemented in python:\n+\n+```python\n+def calculate_roots(numleaves: int, dels: [bytes], proof: Proof) -> [bytes]:\n+    if not proof.targets: return []\n+    if len(proof.targets) != len(dels): return []\n+\n+    position_hashes = {}\n+    for i, target in enumerate(proof.targets):\n+        position_hashes[target] = None if dels is None else dels[i]\n+\n+    calculated_roots = []\n+    sortedTargets = sorted(proof.targets)\n+    while sortedTargets:\n+        pos = sortedTargets.pop(0)\n+        cur_hash = position_hashes.pop(pos)\n+\n+        if isroot(pos, numleaves, tree_rows(numleaves)):\n+            calculated_roots.append(cur_hash)\n+            continue\n+\n+        parent_pos, p_hash = parent(pos, tree_rows(numleaves)), bytes\n+        if sortedTargets and right_sibling(pos) == sortedTargets[0]:\n+            sib_pos = sortedTargets.pop(0)\n+            p_hash = parent_hash(cur_hash, position_hashes.pop(sib_pos))\n+        else:\n+            proofhash = proof.proof.pop(0)\n+            p_hash = parent_hash(proofhash, cur_hash) if is_right_sibling(pos) else parent_hash(cur_hash, proofhash)\n+\n+        position_hashes[parent_pos] = p_hash\n+        bisect.insort(sortedTargets, parent_pos)\n+\n+    return calculated_roots\n+```\n+\n+## Addition\n+\n+Addition adds a leaf to the accumulator. The added leaves are able to be verified of their\n+existence with an inclusion proof.\n+\n+Inputs:\n+  - `acc`.\n+  - `hash` to be added.\n+\n+The Addition algorithm Add(`acc`, `hash`) is defined as:\n+\n+- From row 0 to and **including** `treerows(acc.numleaves)`\n+  - Break if there's no root at this row.\n+  - remove the last root from `acc.roots`.\n+    - Calculate the parent hash of the removed root and the `hash` to be added using *parent_hash*.\n+  - Make the result from `parent_hash` the new `hash`.\n+- Increment `acc.numleaves` by 1.\n+- Append `hash` to `acc.roots`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def add(self, hash: bytes):\n+    for row in range(tree_rows(self.numleaves)+1):\n+        if not root_present(self.numleaves, row): break\n+        root = self.roots.pop()\n+        hash = parent_hash(root, hash)\n+\n+    self.roots.append(hash)\n+    self.numleaves += 1\n+```\n+\n+## Verification\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `[]hash` that are the hashes for the `proof.targets`.\n+  - `proof`.\n+\n+The Verification algorithm `Verify(acc, []hash, proof) -> bool` is defined as:\n+\n+- Raise error if length of `[]hash` differ from `proof.targets`.\n+- Get modified_roots from `CalculateRoots(acc.numleaves, []hash, Proof)`.\n+- Get `root_idxs` from `getrootidxs`.\n+- Raise error if the length of `modified_roots` and `root_idxs` do not match.\n+- Attempt to match roots in modified_roots with roots in `acc`. Raise error if we don't find all the roots in the modified_roots in `acc`.\n+- Return `true`.\n+\n+The algorithm implemented in python:\n+\n+```python\n+def verify(self, dels: [bytes], proof: Proof) -> bool:\n+    if len(dels) != len(proof.targets):\n+        raise(\"len of dels and proof.targets differ\")\n+\n+    root_candidates = calculate_roots(self.numleaves, dels, proof)\n+    root_idxs = getrootidxs(self.numleaves, proof.targets)\n+\n+    if len(root_candidates) != len(root_idxs):\n+        raise(\"length of calculated roots from the proof and expected root count differ\")\n+\n+    for i, idx in enumerate(root_idxs):\n+        if self.roots[idx] != root_candidates[i]:\n+            raise(\"calculated roots from the proof and matched roots differ\")\n+\n+    return true\n+```\n+\n+## Deletion\n+\n+Deletion removes leaves from the accumulator. The deletion algorithm takes in a `proof` but it does not\n+verify that the proof is valid. It assumes that the passed in proof has already passed verification.\n+\n+- Inputs:\n+  - The accumulator state.\n+  - `proof`.\n+\n+The Deletion algorithm `Delete(acc, Proof) -> acc` is defined as:\n+\n+- Get the modified indexes of the roots `root_idxes` from `getrootidxs`.\n+- Get modified_roots from `Calculate_Roots(acc.numleaves, []positions, Proof)`.\n+- Replace the matching indexes from the `root_idxes` in `acc.roots` with `modified_roots`.\n+\n+The algorithm implemented in python:",
      "path": "bip-0181.md",
      "position": 550,
      "original_position": 550,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe algorithm implemented in Python:\r\n```",
      "created_at": "2025-09-17T00:09:11Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906671",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906671"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 550,
      "original_line": 550,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906699",
      "pull_request_review_id": 3232053448,
      "id": 2353906699,
      "node_id": "PRRC_kwDOAN28mc6MTcQL",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,",
      "path": "bip-0182.md",
      "position": 21,
      "original_position": 21,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nthe general rules for validating blocks and transactions using Utreexo,\r\n```",
      "created_at": "2025-09-17T00:09:14Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906699",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 21,
      "original_line": 21,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906735",
      "pull_request_review_id": 3232053448,
      "id": 2353906735,
      "node_id": "PRRC_kwDOAN28mc6MTcQv",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |",
      "path": "bip-0182.md",
      "position": 63,
      "original_position": 63,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Inconsistent use of terminating periods in the Description column.",
      "created_at": "2025-09-17T00:09:17Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906735",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906735"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906770",
      "pull_request_review_id": 3232053448,
      "id": 2353906770,
      "node_id": "PRRC_kwDOAN28mc6MTcRS",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |",
      "path": "bip-0182.md",
      "position": 66,
      "original_position": 66,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Duplicate table rows.",
      "created_at": "2025-09-17T00:09:20Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906770",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906770"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 65,
      "original_start_line": 65,
      "start_side": "RIGHT",
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906839",
      "pull_request_review_id": 3232053448,
      "id": 2353906839,
      "node_id": "PRRC_kwDOAN28mc6MTcSX",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |",
      "path": "bip-0182.md",
      "position": 70,
      "original_position": 70,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1 if this transaction is a coinbase. |\r\n```",
      "created_at": "2025-09-17T00:09:25Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906839",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 70,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906868",
      "pull_request_review_id": 3232053448,
      "id": 2353906868,
      "node_id": "PRRC_kwDOAN28mc6MTcS0",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |",
      "path": "bip-0182.md",
      "position": 72,
      "original_position": 72,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"varint\" is very often confused with \"compact size\", are you sure you didn't mean the latter? In any case you might want to link to some documentation for this format, as it might not be universally understood.\r\n\r\nSee: https://learnmeabitcoin.com/technical/general/compact-size/#varint",
      "created_at": "2025-09-17T00:09:26Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906868",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 72,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906903",
      "pull_request_review_id": 3232053448,
      "id": 2353906903,
      "node_id": "PRRC_kwDOAN28mc6MTcTX",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).",
      "path": "bip-0182.md",
      "position": 85,
      "original_position": 85,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Inconsistent use of `0x` before a hexadecimal string.",
      "created_at": "2025-09-17T00:09:28Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906903",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906903"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 83,
      "original_start_line": 83,
      "start_side": "RIGHT",
      "line": 85,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906917",
      "pull_request_review_id": 3232053448,
      "id": 2353906917,
      "node_id": "PRRC_kwDOAN28mc6MTcTl",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was",
      "path": "bip-0182.md",
      "position": 109,
      "original_position": 109,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThis field stores the block height and a boolean for marking whether the UTXO was\r\n```",
      "created_at": "2025-09-17T00:09:29Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906917",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906917"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906961",
      "pull_request_review_id": 3232053448,
      "id": 2353906961,
      "node_id": "PRRC_kwDOAN28mc6MTcUR",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot",
      "path": "bip-0182.md",
      "position": 170,
      "original_position": 170,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThere are outputs in the Bitcoin network we can guarantee cannot\r\n```",
      "created_at": "2025-09-17T00:09:32Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353906961",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353906961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 170,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907006",
      "pull_request_review_id": 3232053448,
      "id": 2353907006,
      "node_id": "PRRC_kwDOAN28mc6MTcU-",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.",
      "path": "bip-0182.md",
      "position": 199,
      "original_position": 199,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions themselves are order-independent.\r\n```",
      "created_at": "2025-09-17T00:09:34Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907006",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 199,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907027",
      "pull_request_review_id": 3232053448,
      "id": 2353907027,
      "node_id": "PRRC_kwDOAN28mc6MTcVT",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.",
      "path": "bip-0182.md",
      "position": 211,
      "original_position": 211,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nbut since Utreexo nodes don't this data, it must be provided.\r\n```",
      "created_at": "2025-09-17T00:09:36Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907027",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907057",
      "pull_request_review_id": 3232053448,
      "id": 2353907057,
      "node_id": "PRRC_kwDOAN28mc6MTcVx",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for",
      "path": "bip-0182.md",
      "position": 239,
      "original_position": 239,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nFor each block, the UTXO proof must be provided with the Bitcoin block for\r\n```",
      "created_at": "2025-09-17T00:09:39Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907057",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907057"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 239,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907074",
      "pull_request_review_id": 3232053448,
      "id": 2353907074,
      "node_id": "PRRC_kwDOAN28mc6MTcWC",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.",
      "path": "bip-0182.md",
      "position": 241,
      "original_position": 241,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nvalidate that the inputs being referenced exist in the UTXO set.\r\n```",
      "created_at": "2025-09-17T00:09:40Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907074",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907074"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 241,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907097",
      "pull_request_review_id": 3232053448,
      "id": 2353907097,
      "node_id": "PRRC_kwDOAN28mc6MTcWZ",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-0181.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the succeeding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it was trivially easy to create a duplicate transaction that was\n+exactly the same, resulting in a duplicate `TXID` for coinbase transactions by re-using\n+the same bitcoin address.",
      "path": "bip-0182.md",
      "position": 268,
      "original_position": 268,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nthe same Bitcoin address.\r\n```",
      "created_at": "2025-09-17T00:09:43Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907097",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907097"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 268,
      "original_line": 268,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907114",
      "pull_request_review_id": 3232053448,
      "id": 2353907114,
      "node_id": "PRRC_kwDOAN28mc6MTcWq",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-0181.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the succeeding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it was trivially easy to create a duplicate transaction that was\n+exactly the same, resulting in a duplicate `TXID` for coinbase transactions by re-using\n+the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrite an existing UTXO.\n+\n+`BIP-0034` introduces a rule that requires the block height to be included in the coinbase field\n+of the coinbase transaction. The main reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest implicated block",
      "path": "bip-0182.md",
      "position": 277,
      "original_position": 277,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nrandom bytes that could be interpreted as block heights. The lowest impacted block\r\n```",
      "created_at": "2025-09-17T00:09:44Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907114",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907114"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907149",
      "pull_request_review_id": 3232053448,
      "id": 2353907149,
      "node_id": "PRRC_kwDOAN28mc6MTcXN",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-0181.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the succeeding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it was trivially easy to create a duplicate transaction that was\n+exactly the same, resulting in a duplicate `TXID` for coinbase transactions by re-using\n+the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrite an existing UTXO.\n+\n+`BIP-0034` introduces a rule that requires the block height to be included in the coinbase field\n+of the coinbase transaction. The main reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest implicated block\n+heights are: 209,921, 490,897, and 1,983,702.\n+\n+Up until block 209,921 the BIP-0030 checks are performed for non-Utreexo nodes.\n+Since Utreexo nodes only keep the UTXO set commitment, it's not possible to\n+perform the `BIP-0030` check. In theory, those blocks can't be reorged, because\n+of checkpoints, that goes back to block height 295,000 with the block hash\n+`00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983`. Any chain that\n+doesn't include this block at height 295,000 isn't valid as removing this check\n+would be a hard-fork. We note, however, that after version `0.30`, Bitcoin Core",
      "path": "bip-0182.md",
      "position": 286,
      "original_position": 286,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Bitcoin Core dropped the leading zero a few years ago:\r\n```suggestion\r\nwould be a hard-fork. We note, however, that after v30, Bitcoin Core\r\n```",
      "created_at": "2025-09-17T00:09:47Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907149",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 286,
      "original_line": 286,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907216",
      "pull_request_review_id": 3232053448,
      "id": 2353907216,
      "node_id": "PRRC_kwDOAN28mc6MTcYQ",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-0181.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the succeeding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it was trivially easy to create a duplicate transaction that was\n+exactly the same, resulting in a duplicate `TXID` for coinbase transactions by re-using\n+the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrite an existing UTXO.\n+\n+`BIP-0034` introduces a rule that requires the block height to be included in the coinbase field\n+of the coinbase transaction. The main reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest implicated block\n+heights are: 209,921, 490,897, and 1,983,702.\n+\n+Up until block 209,921 the BIP-0030 checks are performed for non-Utreexo nodes.\n+Since Utreexo nodes only keep the UTXO set commitment, it's not possible to\n+perform the `BIP-0030` check. In theory, those blocks can't be reorged, because\n+of checkpoints, that goes back to block height 295,000 with the block hash\n+`00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983`. Any chain that\n+doesn't include this block at height 295,000 isn't valid as removing this check\n+would be a hard-fork. We note, however, that after version `0.30`, Bitcoin Core\n+will remove the checkpoints[^1], as they are not needed anymore to prevent attacks\n+against nodes during Initial Block Download. This is effectively a hard-fork,\n+that will probably never actually happen, however.\n+\n+Block 1,983,702 is the first block that Utreexo nodes would be in danger of a\n+consensus failure due to the inability to perform the BIP-0030 checks if someone were\n+to reuse coinbase transaction from block 164,384. However, this block will happen in roughly",
      "path": "bip-0182.md",
      "position": 293,
      "original_position": 293,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nto reuse the coinbase transaction from block 164,384. However, this block will happen in roughly\r\n```",
      "created_at": "2025-09-17T00:09:52Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907216",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907216"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 293,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907296",
      "pull_request_review_id": 3232053448,
      "id": 2353907296,
      "node_id": "PRRC_kwDOAN28mc6MTcZg",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| BlockHash          | 32-byte array            | The hash of the block in which this tx was confirmed. |\n+| TXID               | 32-byte array            | The transaction's TXID                    |\n+| Vout               | 4-byte unsigned integer  | The output index of this UTXO             |\n+| Header code        | 4-byte unsigned integer  | The block height and iscoinbase. This is a value obtained by left shifting the block height that confirmed this transaction by one bit, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| Amount             | 8-byte unsigned integer  | The amount in satoshis for this UTXO      |\n+| Output script size | varint                   | The output script length in bytes              |\n+| Output script      | variable byte array      | The output script of the UTXO            |\n+\n+Each field being defined as follows:\n+\n+##### Version tag\n+\n+We use [tagged hashes](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#user-content-Design) for the hashes committed in the accumulator for versioning\n+purposes. This is added so that if there are changes in the preimage of the\n+hash, the version tag helps to avoid misinterpretation.\n+\n+The Utreexo version tag is the SHA512 hash of the string `UtreexoV1`, which is represented as the vector\n+`[85 116 114 101 101 120 111 86 49]` and hex `0x5574726565786f5631`.  (The resulting 64-byte output is\n+`5b832db8ca26c25be1c542d6cceddda8c145615cff5c35727fb3462610807e20ae534dc3f64299199931772e03787d18156eb3151e0ed1b3098bdc8445861885`).\n+\n+##### Blockhash\n+\n+We commit to the hash of the block which confirms the UTXO. This\n+is not currently used in the validation code, but could be used at a future\n+version to increase the work required for collision attacks.\n+A valid blockhash requires a large amount of work, which would prevent an\n+attacker from performing a standard cycle-finding collision attack in $2^{n/2}$\n+operations for an n-bit hash.\n+\n+This could allow a later or alternate version to use shorter truncated hashes,\n+saving bandwidth and storage while still keeping Bitcoin's $2^{128}$ security.\n+\n+##### TXID\n+\n+The TXID is the transaction ID of the transaction that created this UTXO.\n+\n+##### VOUT\n+\n+The output index of the UTXO in the transaction.\n+\n+##### Header code\n+\n+This field stores the block height and a boolean for marking that the UTXO was\n+created by a coinbase transaction. Mostly serves to save space as the coinbase\n+boolean can be stored in a single bit.\n+\n+This field is a value obtained by left shifting the block height that\n+confirmed this transaction by one bit, and then setting the least significant bit to 1 only\n+if it's part of a coinbase transaction. The code to do that is like so:\n+\n+```\n+header_code = block_height\n+header_code <<= 1\n+if IsCoinBase {\n+    header_code |= 1 // only set the bit 0 if it's a coinbase.\n+}\n+```\n+\n+The block height is needed as during transaction validation, it is used during\n+the check of BIP-0065 CLTV. In current nodes, the block height is stored locally\n+as a part of the UTXO set. Since Utreexo nodes get this data from peers, we need\n+to commit to the block height to avoid security vulnerabilities.\n+\n+The boolean for coinbase outputs is needed as they may not be spent before having 100 confirmations.\n+This data is also currently stored locally as a part of the UTXO set for current nodes.\n+\n+##### Amount\n+\n+This field is added to commit to the value of the UTXO. With current nodes, this\n+is stored in the UTXO set but since we receive this in the proof from our peers,\n+we need to commit to this value to avoid malicious peers that may send over the\n+wrong amount.\n+\n+##### Output script size\n+\n+As the output script (\"scriptPubKey\" in Bitcoin Core and btcd) is a variable length byte array, we prepend it with the\n+length.\n+\n+##### Output script\n+\n+This field is added to commit to the output script of the UTXO. With current\n+nodes, this is stored in the UTXO set but since we receive this in the proof\n+from our peers, we need to commit to this value to avoid malicious peers that\n+may send over the wrong output script.\n+\n+#### Hash function\n+\n+The leaf data is hashed with SHA-512/256, which gives us a 32 byte hash.\n+It was chosen over SHA-256 due to the faster performance on 64 bit systems.\n+\n+#### Excluded UTXOs from the accumulator\n+\n+Not all transaction outputs are added to a node's UTXO set. Normal Bitcoin nodes\n+only form consensus on the set of transactions, not on the UTXO set, so different\n+nodes can omit different outputs and stay compatible as long as those outputs are\n+never spent. Utreexo nodes, however, do require explicit consensus on the UTXO set\n+as all proofs are with respect to the Merkle roots of the entire set.\n+\n+For this reason, we define which UTXOs are not inserted to the accumulator.  Any\n+variations here will result in Utreexo nodes with incompatible proofs.\n+\n+##### Provably unspendable transaction outputs\n+\n+There are outputs in the Bitcoin network that we can guarantee that they cannot\n+be spent without a hard-fork of the network. The following output types are not\n+added to the accumulator:\n+- Outputs whose output script starts with an OP_RETURN (0x6a)\n+- Outputs with an output script larger than 10,000 bytes\n+\n+##### Same block spends\n+\n+Often, UTXOs are created and spent in the same block. This is allowed by Bitcoin\n+consensus rules as long as the output being spent is created by a transaction earlier\n+in the block than the spending transaction.\n+In Utreexo, nodes inspect blocks and identify which outputs are being created\n+and destroyed in the same block, and exclude them from the accumulator and proofs.\n+\n+There's no need to provide proofs for outputs which have been created in the same\n+block. Adding and then immediately removing the output from the accumulator would be\n+possible but doesn't serve any purpose - once outputs are spent, their past existence\n+cannot be proven with the Utreexo accumulator (and SPV proofs already provide that).\n+\n+For these reasons, outputs which are spent in the same block where they are created\n+are omitted from the accumulator, and those inputs are omitted from block proofs.\n+\n+#### Order of operations\n+\n+The Utreexo accumulator lacks associative properties during addition and the\n+ordering of which UTXO hash gets added first is consensus critical. For\n+the modification of the accumulator the steps are as follows:\n+\n+1. Batch remove the UTXOs that were spent in the block based on the algorithm\n+   defined in [Utreexo Accumulator Specification](bip-0181.md). Deletions itself are order-independent.\n+2. Batch add all non-excluded outputs in the order they're included in the\n+   Bitcoin block. Additions are order-dependent.\n+\n+The removal and the addition of the hashes follow the algorithms defined in\n+[Utreexo Accumulator Specification](bip-0181.md).\n+\n+#### Format of the UTXO proof\n+\n+The UTXO proof has 2 elements: the accumulator proof and the leaf data. The\n+leaf data provides the necessary UTXO data for block validation that would be\n+stored locally for non-Utreexo nodes. Non-Utreexo nodes store this data (under \"chainstate/\" for Bitcoin Core)\n+but since utreexo nodes don't this data, it must be provided.\n+\n+The accompanying accumulator proof proves that the given leaf data are committed\n+in the accumulator. Without this accumulator proof, the Utreexo nodes would not have\n+a way to ensure that the given UTXO data exists in the UTXO set. The accumulator proof\n+and the verification ensures that Utreexo nodes are not fooled into accepting transactions\n+whose input UTXOs do not exist.\n+\n+[Accumulator Proof](bip-0181.md#definitions) is defined in BIP-0181, and contains two elements:\n+\n+1. A vector of positions of the UTXO hashes in the accumulator.\n+2. A vector of hashes required to hash up to the roots.\n+\n+For (1), positions are in the order of the leaves that are being proven in\n+the accumulator. These are all the inputs in the natural blockchain order that\n+excludes the same block spends.\n+\n+The UTXO hash preimages follow the same ordering as (1) in the accumulator\n+proofs. Each of the positions in (1) refer to the UTXO hash preimage in the same\n+index.\n+\n+| Field Name          | Data Type           | Byte Size | Description                              |\n+| ------------------- | ------------------- | --------- | ---------------------------------------- |\n+| Accumulator Proof   | variable byte array | variable  | The Utreexo proof as defined in BIP-0181 |\n+| UTXO hash preimages | variable byte array | variable  | The UTXO data needed to validate all the transaction in the block |\n+\n+#### UTXO proof validation\n+\n+For each block, the UTXO proof must be provided with the bitcoin block for\n+validation to be possible. Without the UTXO proof, it's not possible to\n+validate that the inputs being referenced exists in the UTXO set.\n+\n+The end result of the UTXO proof validation results in the vector of UTXO\n+hash preimages that are required to perform the rest of the consensus\n+validation checks. Note that the resulting data from the UTXO proof validation\n+is the same data that would normally be fetched from the locally stored UTXO\n+set.\n+\n+The order of operations for the UTXO proof validation are:\n+\n+1. Hash the UTXO preimages.\n+2. Verify that the UTXO preimages exist in the accumulator with the verification\n+   algorithm specified in BIP-0181.\n+\n+### BIP-0030\n+\n+[`BIP-0030`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki) is an added\n+consensus check that prevents duplicate TXIDs. This check and the historical violations\n+of this check affect the consensus validation for Utreexo nodes.\n+\n+### BIP-0030 and BIP-0034 consensus check\n+\n+Before `BIP-0030`, the Bitcoin consensus rules allowed for duplicate TXIDs. If two\n+transactions shared a same TXID, the transaction outputs of the succeeding\n+transaction would overwrite the previously created UTXOs. It was assumed that\n+TXIDs were unique but it was trivially easy to create a duplicate transaction that was\n+exactly the same, resulting in a duplicate `TXID` for coinbase transactions by re-using\n+the same bitcoin address.\n+\n+`BIP-0030` check is a consensus check that enforces that newly created transactions\n+do not have outputs that overwrite an existing UTXO.\n+\n+`BIP-0034` introduces a rule that requires the block height to be included in the coinbase field\n+of the coinbase transaction. The main reason for the change was to make\n+coinbase transactions unique so that the expensive check of going through the\n+UTXO set wouldn't be needed. However, there were blocks in the past that had\n+random bytes that could be interpreted as block heights. The lowest implicated block\n+heights are: 209,921, 490,897, and 1,983,702.\n+\n+Up until block 209,921 the BIP-0030 checks are performed for non-Utreexo nodes.\n+Since Utreexo nodes only keep the UTXO set commitment, it's not possible to\n+perform the `BIP-0030` check. In theory, those blocks can't be reorged, because\n+of checkpoints, that goes back to block height 295,000 with the block hash\n+`00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983`. Any chain that\n+doesn't include this block at height 295,000 isn't valid as removing this check\n+would be a hard-fork. We note, however, that after version `0.30`, Bitcoin Core\n+will remove the checkpoints[^1], as they are not needed anymore to prevent attacks\n+against nodes during Initial Block Download. This is effectively a hard-fork,\n+that will probably never actually happen, however.\n+\n+Block 1,983,702 is the first block that Utreexo nodes would be in danger of a\n+consensus failure due to the inability to perform the BIP-0030 checks if someone were\n+to reuse coinbase transaction from block 164,384. However, this block will happen in roughly\n+21 years from now, and some mitigations have been proposed [^2].\n+\n+### Historical BIP-0030 violations\n+\n+There were two UTXOs that were overwritten by repeated transactions:\n+`e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468:0` at block height 91,722\n+`d5d27987d2a3dfc724e359870c6644b40e497bdc0589a033220fe15429d88599:0` at block height 91,812\n+\n+Since the leaf hashes that are committed to the Utreexo accumulator commit to\n+the block hash as well, all the leaf hashes are unique and the two historical\n+violations do not happen with how the UTXO set is represented with the Utreexo\n+accumulator. To be consensus compatible with clients that retain only the second\n+occurrences of these outputs, the leaves representing the corresponding first UTXOs in the Utreexo accumulator\n+are hardcoded as unspendable.\n+\n+These two leaf hashes encoded in hex string are:\n+\n+ 1. `84b3af0783b410b4564c5d1f361868559f7cf77cfc65ce2be951210357022fe3`\n+ 2. `bc6b4bf7cebbd33a18d6b0fe1f8ecc7aa5403083c39ee343b985d51fd0295ad8`\n+\n+(1) represents the UTXO created at block height 91,722 and (2) represents the\n+UTXO created at block height 91,812.\n+\n+## Rationale\n+\n+**Why use the Utreexo accumulator to keep track of UTXOs instead of a key-value database like leveldb?**\n+\n+There's two main advantages to using the Utreexo accumulator instead of a key-value database like leveldb:\n+\n+ 1. Puts a cap on the UTXO set growth.\n+ 3. Performance gains with the elimination of random reads/writes.\n+\n+### Puts a cap on the UTXO set growth\n+\n+The UTXO set is the collection of unspent transaction outputs and is used to verify blocks.\n+As the amount of Bitcoin users grow, the UTXO set grows with it.\n+\n+The UTXO set is currently around 10GB in 2025 and with pruning that's all it takes to maintain a full node.\n+However, as the UTXO set grows, the disk storage requirement will grow along with it and increase the barrier to running a full node.\n+\n+Currently, the UTXO set size is $O(log(N))$ where $N$ is the number of UTXOs.",
      "path": "bip-0182.md",
      "position": 334,
      "original_position": 334,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this is meant to say:\r\n```suggestion\r\nCurrently, the UTXO set size is $O(N)$ where $N$ is the number of UTXOs.\r\n```",
      "created_at": "2025-09-17T00:09:56Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907296",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 334,
      "original_line": 334,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907420",
      "pull_request_review_id": 3232053448,
      "id": 2353907420,
      "node_id": "PRRC_kwDOAN28mc6MTcbc",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.",
      "path": "bip-0183.md",
      "position": 18,
      "original_position": 18,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nUtreexo creates a compact representation of the UTXO set that only takes up a couple of kilobytes.\r\n```",
      "created_at": "2025-09-17T00:10:00Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907420",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 18,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907465",
      "pull_request_review_id": 3232053448,
      "id": 2353907465,
      "node_id": "PRRC_kwDOAN28mc6MTccJ",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.",
      "path": "bip-0183.md",
      "position": 62,
      "original_position": 62,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For some reason, \"Merkle\" is consistently capitalized in 181 and 182 but consistently lowercase in 183.",
      "created_at": "2025-09-17T00:10:01Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907465",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 62,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907614",
      "pull_request_review_id": 3232053448,
      "id": 2353907614,
      "node_id": "PRRC_kwDOAN28mc6MTcee",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.",
      "path": "bip-0183.md",
      "position": 63,
      "original_position": 63,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nBoth of these processes happen without any P2P messages by taking an already existing, synchronized archive full node and going through its stored block data.\r\n```",
      "created_at": "2025-09-17T00:10:08Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907614",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907708",
      "pull_request_review_id": 3232053448,
      "id": 2353907708,
      "node_id": "PRRC_kwDOAN28mc6MTcf8",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. ",
      "path": "bip-0183.md",
      "position": 65,
      "original_position": 65,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nOnce an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the Bitcoin network. \r\n```",
      "created_at": "2025-09-17T00:10:12Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907708",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907774",
      "pull_request_review_id": 3232053448,
      "id": 2353907774,
      "node_id": "PRRC_kwDOAN28mc6MTcg-",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).",
      "path": "bip-0183.md",
      "position": 120,
      "original_position": 120,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181.md#merkle-forest).\r\n```",
      "created_at": "2025-09-17T00:10:15Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907774",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 120,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907846",
      "pull_request_review_id": 3232053448,
      "id": 2353907846,
      "node_id": "PRRC_kwDOAN28mc6MTciG",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.",
      "path": "bip-0183.md",
      "position": 170,
      "original_position": 170,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nIf the block header validation passes while the full block validation fails, Node B should request the inclusion proof from a different peer.\r\n```",
      "created_at": "2025-09-17T00:10:18Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907846",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907846"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 170,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907896",
      "pull_request_review_id": 3232053448,
      "id": 2353907896,
      "node_id": "PRRC_kwDOAN28mc6MTci4",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.",
      "path": "bip-0183.md",
      "position": 212,
      "original_position": 212,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe committed data is defined in [Utreexo - Transaction and block validation](bip-0182.md#utxo-hash-preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\r\n```",
      "created_at": "2025-09-17T00:10:20Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907896",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 212,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907951",
      "pull_request_review_id": 3232053448,
      "id": 2353907951,
      "node_id": "PRRC_kwDOAN28mc6MTcjv",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.",
      "path": "bip-0183.md",
      "position": 289,
      "original_position": 289,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nSee BIP [Utreexo Accumulator Specification](bip-0181.md#merkle-forest) for an explanation on how each of the hashes in the merkle forest are positioned.\r\n```",
      "created_at": "2025-09-17T00:10:24Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907951",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907951"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 289,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907966",
      "pull_request_review_id": 3232053448,
      "id": 2353907966,
      "node_id": "PRRC_kwDOAN28mc6MTcj-",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).",
      "path": "bip-0183.md",
      "position": 292,
      "original_position": 292,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nWhile each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#excluded-utxos-from-the-accumulator).\r\n```",
      "created_at": "2025-09-17T00:10:26Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907966",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907966"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 292,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907999",
      "pull_request_review_id": 3232053448,
      "id": 2353907999,
      "node_id": "PRRC_kwDOAN28mc6MTckf",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |",
      "path": "bip-0183.md",
      "position": 303,
      "original_position": 303,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| blockhash                 | 32 byte vector              | The hash of the Bitcoin block that we want the inclusion proof for |\r\n```",
      "created_at": "2025-09-17T00:10:28Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353907999",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353907999"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 303,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908057",
      "pull_request_review_id": 3232053448,
      "id": 2353908057,
      "node_id": "PRRC_kwDOAN28mc6MTclZ",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |",
      "path": "bip-0183.md",
      "position": 365,
      "original_position": 365,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| transaction                | MSG_TX                       | The Bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\r\n```",
      "created_at": "2025-09-17T00:10:31Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353908057",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908057"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 365,
      "original_line": 365,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908089",
      "pull_request_review_id": 3232053448,
      "id": 2353908089,
      "node_id": "PRRC_kwDOAN28mc6MTcl5",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |",
      "path": "bip-0183.md",
      "position": 369,
      "original_position": 369,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the Bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\r\n```",
      "created_at": "2025-09-17T00:10:33Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353908089",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 369,
      "original_line": 369,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908119",
      "pull_request_review_id": 3232053448,
      "id": 2353908119,
      "node_id": "PRRC_kwDOAN28mc6MTcmX",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.",
      "path": "bip-0183.md",
      "position": 384,
      "original_position": 384,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n`MSG_UTREEXO_ROOT` is the Utreexo accumulator state at a given height with a proof to a Utreexo accumulator of the Utreexo roots.\r\n```\r\n\r\nThere are also several instances of lowercase \"utreexo\" in the table below.",
      "created_at": "2025-09-17T00:10:35Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353908119",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 384,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908166",
      "pull_request_review_id": 3232053448,
      "id": 2353908166,
      "node_id": "PRRC_kwDOAN28mc6MTcnG",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.",
      "path": "bip-0183.md",
      "position": 405,
      "original_position": 405,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nFor example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 801 through 1600, 1601 through 2400, and so on.\r\n\r\nIn order start the 1601 through 2400 IBD task, however, the node should know what the state of the UTXO set is at block 1600, so that it can validate and modify the accumulator.\r\n```",
      "created_at": "2025-09-17T00:10:37Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353908166",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 403,
      "original_start_line": 403,
      "start_side": "RIGHT",
      "line": 405,
      "original_line": 405,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908221",
      "pull_request_review_id": 3232053448,
      "id": 2353908221,
      "node_id": "PRRC_kwDOAN28mc6MTcn9",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.",
      "path": "bip-0183.md",
      "position": 415,
      "original_position": 415,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nArchive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the UTXO accumulator state to be at any block height.\r\n```",
      "created_at": "2025-09-17T00:10:40Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353908221",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 415,
      "original_line": 415,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908257",
      "pull_request_review_id": 3232053448,
      "id": 2353908257,
      "node_id": "PRRC_kwDOAN28mc6MTcoh",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.",
      "path": "bip-0183.md",
      "position": 419,
      "original_position": 419,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n`MSG_GET_UTREEXO_ROOT` is used to request a Utreexo accumulator state at a given height.\r\n```",
      "created_at": "2025-09-17T00:10:42Z",
      "updated_at": "2025-09-17T00:11:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353908257",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353908257"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 419,
      "original_line": 419,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353914116",
      "pull_request_review_id": 3232065913,
      "id": 2353914116,
      "node_id": "PRRC_kwDOAN28mc6MTeEE",
      "diff_hunk": "@@ -0,0 +1,369 @@\n+```\n+  BIP: 182\n+  Layer: Peer Services\n+  Title: Utreexo - Transaction and block validation\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0182\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-10-01\n+  License: BSD-3-Clause\n+  Requires: 181\n+```\n+\n+## Abstract\n+\n+This BIP defines the rules for validating blocks and transactions using the\n+Utreexo accumulator. It is important to note that this BIP does not define the\n+Utreexo accumulator itself, for that see [Utreexo Accumulator Specification](bip-0181.md). This document is only concerned with\n+the general rules for validating blocks and transactions using the Utreexo,\n+so that all Utreexo nodes can stay in consensus with one another.\n+\n+## Motivation\n+\n+Although Utreexo in its current form is not proposed as a soft fork, it is essential that\n+all implementations adhere to a consistent workflow when performing consensus-critical\n+operations. This BIP defines that workflow, along with the specific rules and their\n+required ordering.\n+\n+There are five consensus-critical components when using the Utreexo accumulator to\n+represent the UTXO set:\n+\n+ - 1: The serialization format of each UTXO (\"leaf data\").\n+ - 2: The hash function used to hash the leaf data.\n+ - 3: Which transaction outputs are excluded from the accumulator.\n+ - 4: The order of operations for the additions and deletions in the accumulator.\n+ - 5: The format of the UTXO proof.\n+\n+A discrepancy in any of the five components above will result in a divergent\n+accumulator state, leading to consensus incompatibilities.\n+\n+## License\n+\n+This BIP is licensed under the BSD 3-clause license.\n+\n+## Specification\n+\n+### Node Hashes\n+\n+During a node's normal operation, it will need to compute the leaf hash for UTXOs\n+being added or removed from the accumulator. The leaf hash is a 32-byte hash that\n+is computed using the SHA-512/256 hash function. See [UTXO Hash Preimages](#utxo-hash-preimages) for the\n+details on how to compute the leaf hash.\n+\n+Unless otherwise specified, all fields are in little-endian format.\n+\n+#### UTXO Hash Preimages\n+\n+Individual UTXOs are represented as 32-byte hashes in the Utreexo accumulator. To obtain this\n+hash, you must compute the SHA-512/256 hash of the following data:\n+\n+| Name               | Type                     | Description                               |\n+| ------------------ | ------------------------ | ----------------------------------------- |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |\n+| Utreexo_Tag_V1     | 64-byte array            | The version tag to be prepended to the leafhash. |",
      "path": "bip-0182.md",
      "position": 66,
      "original_position": 66,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": 2353906770,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sorry, didn't notice this was intentional. You could consolidate this into one row that says \"128-byte array\", or change the description of the second line to clarify the intended duplication.",
      "created_at": "2025-09-17T00:16:17Z",
      "updated_at": "2025-09-17T00:16:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2353914116",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2353914116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 65,
      "original_start_line": 65,
      "start_side": "RIGHT",
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364737742",
      "pull_request_review_id": 3247453919,
      "id": 2364737742,
      "node_id": "PRRC_kwDOAN28mc6M8wjO",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.",
      "path": "bip-0183.md",
      "position": 139,
      "original_position": 139,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nIt's possible to have an `inv` message with multiple transactions as well.\r\n```",
      "created_at": "2025-09-19T22:48:40Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364737742",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364737742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364739626",
      "pull_request_review_id": 3247453919,
      "id": 2364739626,
      "node_id": "PRRC_kwDOAN28mc6M8xAq",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:",
      "path": "bip-0183.md",
      "position": 148,
      "original_position": 148,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nLegacy block propagation without Compact Blocks is comprised of three steps:\r\n```",
      "created_at": "2025-09-19T22:49:20Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364739626",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364739626"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 148,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364741121",
      "pull_request_review_id": 3247453919,
      "id": 2364741121,
      "node_id": "PRRC_kwDOAN28mc6M8xYB",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.",
      "path": "bip-0183.md",
      "position": 151,
      "original_position": 151,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n1. Node A sends an `inv` message or a block header to Node B.\r\n2. Node B makes a `getdata` request for the block.\r\n```",
      "created_at": "2025-09-19T22:50:00Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364741121",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364741121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 150,
      "original_start_line": 150,
      "start_side": "RIGHT",
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364741827",
      "pull_request_review_id": 3247453919,
      "id": 2364741827,
      "node_id": "PRRC_kwDOAN28mc6M8xjD",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.",
      "path": "bip-0183.md",
      "position": 154,
      "original_position": 154,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe image below illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\r\n```",
      "created_at": "2025-09-19T22:50:22Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364741827",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364741827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 154,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364742988",
      "pull_request_review_id": 3247453919,
      "id": 2364742988,
      "node_id": "PRRC_kwDOAN28mc6M8x1M",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.",
      "path": "bip-0183.md",
      "position": 162,
      "original_position": 162,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n1. Node A sends an `inv` message or a block header to Node B.\r\n2. Node B makes a `getdata` request for the block.\r\n3. Node B makes a `getutreexoproof` request for the block.\r\n```",
      "created_at": "2025-09-19T22:50:53Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364742988",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364742988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 160,
      "original_start_line": 160,
      "start_side": "RIGHT",
      "line": 162,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364743989",
      "pull_request_review_id": 3247453919,
      "id": 2364743989,
      "node_id": "PRRC_kwDOAN28mc6M8yE1",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.",
      "path": "bip-0183.md",
      "position": 173,
      "original_position": 173,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe image below illustrates how a Utreexo node would relay blocks without using Compact Blocks.\r\n```",
      "created_at": "2025-09-19T22:51:29Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364743989",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364743989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 173,
      "original_line": 173,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364751831",
      "pull_request_review_id": 3247453919,
      "id": 2364751831,
      "node_id": "PRRC_kwDOAN28mc6M8z_X",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.",
      "path": "bip-0183.md",
      "position": 185,
      "original_position": 185,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n1. Node A sends an `inv` message or a block header to Node B.\r\n2. Node B makes a `getdata` request (MSG_UTREEXO_SUMMARY) for the given blockhash.\r\n3. Node A sends the `usummary` message to Node B.\r\n4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\r\n5. Node B makes a `getdata` request for the block to Node A.\r\n6. Node B makes a `getuproof` request for the block to Node A.\r\n```",
      "created_at": "2025-09-19T22:55:00Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364751831",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364751831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 180,
      "original_start_line": 180,
      "start_side": "RIGHT",
      "line": 185,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364752638",
      "pull_request_review_id": 3247453919,
      "id": 2364752638,
      "node_id": "PRRC_kwDOAN28mc6M80L-",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.",
      "path": "bip-0183.md",
      "position": 197,
      "original_position": 197,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe  image below illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\r\n```",
      "created_at": "2025-09-19T22:55:30Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364752638",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364752638"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 197,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364753725",
      "pull_request_review_id": 3247453919,
      "id": 2364753725,
      "node_id": "PRRC_kwDOAN28mc6M80c9",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.",
      "path": "bip-0183.md",
      "position": 189,
      "original_position": 189,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nAs with the `getuproof` message, Node B is free to ask for the `usummary` message from a node other than Node A.\r\n```",
      "created_at": "2025-09-19T22:56:09Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364753725",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364753725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 189,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364754757",
      "pull_request_review_id": 3247453919,
      "id": 2364754757,
      "node_id": "PRRC_kwDOAN28mc6M80tF",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.",
      "path": "bip-0183.md",
      "position": 177,
      "original_position": 177,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nSince the inclusion proof is cached for each of the transactions in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\r\n```",
      "created_at": "2025-09-19T22:56:39Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364754757",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364754757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 177,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364762605",
      "pull_request_review_id": 3247453919,
      "id": 2364762605,
      "node_id": "PRRC_kwDOAN28mc6M82nt",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.",
      "path": "bip-0183.md",
      "position": 253,
      "original_position": 253,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nFor any UTXO that gets added to the Utreexo Merkle forest exists a corresponding TTL Info. It includes the necessary information for efficiently caching and requesting proofs.\r\n```",
      "created_at": "2025-09-19T23:01:27Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364762605",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364762605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 253,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364763708",
      "pull_request_review_id": 3247453919,
      "id": 2364763708,
      "node_id": "PRRC_kwDOAN28mc6M8248",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |",
      "path": "bip-0183.md",
      "position": 258,
      "original_position": 258,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| TTL            | varint | The time-to-live value of a leaf in the Utreexo Merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\r\n```",
      "created_at": "2025-09-19T23:02:15Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364763708",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364763708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 258,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364764168",
      "pull_request_review_id": 3247453919,
      "id": 2364764168,
      "node_id": "PRRC_kwDOAN28mc6M83AI",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+",
      "path": "bip-0183.md",
      "position": 262,
      "original_position": 262,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Missing a description here.",
      "created_at": "2025-09-19T23:02:31Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364764168",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364764168"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 262,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364767831",
      "pull_request_review_id": 3247453919,
      "id": 2364767831,
      "node_id": "PRRC_kwDOAN28mc6M835X",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |",
      "path": "bip-0183.md",
      "position": 259,
      "original_position": 259,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| death position | varint | The position of the leaf in the Utreexo Merkle forest at the moment it was removed                                                                                                  |\r\n```",
      "created_at": "2025-09-19T23:04:40Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364767831",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364767831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 259,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364769801",
      "pull_request_review_id": 3247453919,
      "id": 2364769801,
      "node_id": "PRRC_kwDOAN28mc6M84YJ",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |",
      "path": "bip-0183.md",
      "position": 265,
      "original_position": 265,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wrong description. ",
      "created_at": "2025-09-19T23:05:42Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364769801",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364769801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 265,
      "original_line": 265,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364770967",
      "pull_request_review_id": 3247453919,
      "id": 2364770967,
      "node_id": "PRRC_kwDOAN28mc6M84qX",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |",
      "path": "bip-0183.md",
      "position": 266,
      "original_position": 266,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| length       | varint              | The length of the TTLInfo vector                                                                                                                                                                                                                                   |\r\n```",
      "created_at": "2025-09-19T23:06:19Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364770967",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364770967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 266,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364771936",
      "pull_request_review_id": 3247453919,
      "id": 2364771936,
      "node_id": "PRRC_kwDOAN28mc6M845g",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.",
      "path": "bip-0183.md",
      "position": 344,
      "original_position": 344,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing Merkle forest positions required to validate a given block.\r\n```",
      "created_at": "2025-09-19T23:06:57Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364771936",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364771936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 344,
      "original_line": 344,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364772692",
      "pull_request_review_id": 3247453919,
      "id": 2364772692,
      "node_id": "PRRC_kwDOAN28mc6M85FU",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |",
      "path": "bip-0183.md",
      "position": 354,
      "original_position": 354,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all locations |\r\n```",
      "created_at": "2025-09-19T23:07:27Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364772692",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364772692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 354,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364773914",
      "pull_request_review_id": 3247453919,
      "id": 2364773914,
      "node_id": "PRRC_kwDOAN28mc6M85Ya",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.",
      "path": "bip-0183.md",
      "position": 358,
      "original_position": 358,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with its inclusion proof.\r\n```",
      "created_at": "2025-09-19T23:08:23Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364773914",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364773914"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 358,
      "original_line": 358,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364774665",
      "pull_request_review_id": 3247453919,
      "id": 2364774665,
      "node_id": "PRRC_kwDOAN28mc6M85kJ",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |",
      "path": "bip-0183.md",
      "position": 365,
      "original_position": 365,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The direction of the shift should be explicit.",
      "created_at": "2025-09-19T23:09:04Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364774665",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364774665"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 365,
      "original_line": 365,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364776422",
      "pull_request_review_id": 3247453919,
      "id": 2364776422,
      "node_id": "PRRC_kwDOAN28mc6M85_m",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.",
      "path": "bip-0183.md",
      "position": 384,
      "original_position": 384,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should be hash, as there is no height on the message, only a block hash.\r\n\r\n```suggestion\r\n`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given blockhash with a proof to a utreexo accumulator of the utreexo roots.\r\n```",
      "created_at": "2025-09-19T23:10:22Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364776422",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364776422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 384,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364777180",
      "pull_request_review_id": 3247453919,
      "id": 2364777180,
      "node_id": "PRRC_kwDOAN28mc6M86Lc",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |",
      "path": "bip-0183.md",
      "position": 391,
      "original_position": 391,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| numleaves                  | varint                       | The total number of leaves that were added to the accumulator until this block hash. See [numleaves](bip-0181.md#Definitions)                                                                      |\r\n```",
      "created_at": "2025-09-19T23:11:03Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364777180",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364777180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 391,
      "original_line": 391,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364778219",
      "pull_request_review_id": 3247453919,
      "id": 2364778219,
      "node_id": "PRRC_kwDOAN28mc6M86br",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |",
      "path": "bip-0183.md",
      "position": 392,
      "original_position": 392,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| target                     | varint                       | The position of the Utreexo root in the optional accumulator of the Utreexo roots                                                                                                                                |\r\n```",
      "created_at": "2025-09-19T23:11:49Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364778219",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364778219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 392,
      "original_line": 392,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364779061",
      "pull_request_review_id": 3247453919,
      "id": 2364779061,
      "node_id": "PRRC_kwDOAN28mc6M86o1",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |",
      "path": "bip-0183.md",
      "position": 393,
      "original_position": 393,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| blockhash                  | 32 byte vector               | The blockhash for this Utreexo accumulator state                                                                                                                                                                 |\r\n```",
      "created_at": "2025-09-19T23:12:21Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364779061",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364779061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 393,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364779672",
      "pull_request_review_id": 3247453919,
      "id": 2364779672,
      "node_id": "PRRC_kwDOAN28mc6M86yY",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |",
      "path": "bip-0183.md",
      "position": 394,
      "original_position": 394,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| length of the root hashes  | varint                       | The length of the root hash vector                                                                                                                                                                                  |\r\n```",
      "created_at": "2025-09-19T23:12:46Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364779672",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364779672"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 394,
      "original_line": 394,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364780071",
      "pull_request_review_id": 3247453919,
      "id": 2364780071,
      "node_id": "PRRC_kwDOAN28mc6M864n",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |",
      "path": "bip-0183.md",
      "position": 395,
      "original_position": 395,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| root hashes                | vector of 32 byte hashes     | The Utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\r\n```",
      "created_at": "2025-09-19T23:13:02Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364780071",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364780071"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 395,
      "original_line": 395,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364780826",
      "pull_request_review_id": 3247453919,
      "id": 2364780826,
      "node_id": "PRRC_kwDOAN28mc6M87Ea",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |",
      "path": "bip-0183.md",
      "position": 396,
      "original_position": 396,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| length of the proof hashes | varint                       | The length of the proof hashes vector                                                                                                                                                                                |\r\n```",
      "created_at": "2025-09-19T23:13:29Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364780826",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364780826"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 396,
      "original_line": 396,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364781154",
      "pull_request_review_id": 3247453919,
      "id": 2364781154,
      "node_id": "PRRC_kwDOAN28mc6M87Ji",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |",
      "path": "bip-0183.md",
      "position": 397,
      "original_position": 397,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed Utreexo accumulator of the Utreexo roots                                                                                                              |\r\n```",
      "created_at": "2025-09-19T23:13:45Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364781154",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364781154"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 397,
      "original_line": 397,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364782082",
      "pull_request_review_id": 3247453919,
      "id": 2364782082,
      "node_id": "PRRC_kwDOAN28mc6M87YC",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].",
      "path": "bip-0183.md",
      "position": 399,
      "original_position": 399,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThis message is used for implementing an out-of-order block validation node[^2] or softchains[^3].\r\n```",
      "created_at": "2025-09-19T23:14:25Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364782082",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364782082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 399,
      "original_line": 399,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364783140",
      "pull_request_review_id": 3247453919,
      "id": 2364783140,
      "node_id": "PRRC_kwDOAN28mc6M87ok",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.",
      "path": "bip-0183.md",
      "position": 401,
      "original_position": 401,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nBecause the size of the state needed to validate blocks is so small with Utreexo, nodes can perform parallel and out of order IBD.\r\n```",
      "created_at": "2025-09-19T23:15:13Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364783140",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364783140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 401,
      "original_line": 401,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364784964",
      "pull_request_review_id": 3247453919,
      "id": 2364784964,
      "node_id": "PRRC_kwDOAN28mc6M88FE",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.",
      "path": "bip-0183.md",
      "position": 415,
      "original_position": 415,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nArchive nodes create a forest of \"linkup hints\", so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\r\n```",
      "created_at": "2025-09-19T23:16:12Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364784964",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364784964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 415,
      "original_line": 415,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364785644",
      "pull_request_review_id": 3247453919,
      "id": 2364785644,
      "node_id": "PRRC_kwDOAN28mc6M88Ps",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.\n+\n+Its `cmdString` for P2PV1 is `geturoot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `36`.\n+\n+| Field                      | Type                    | Description                                                                                                      |\n+|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that the requested utreexo root message is for                                             |",
      "path": "bip-0183.md",
      "position": 426,
      "original_position": 426,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n| blockhash                  | 32 byte vector          | The hash of the block that the requested Utreexo root message is for                                             |\r\n```",
      "created_at": "2025-09-19T23:16:31Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364785644",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364785644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 426,
      "original_line": 426,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364786290",
      "pull_request_review_id": 3247453919,
      "id": 2364786290,
      "node_id": "PRRC_kwDOAN28mc6M88Zy",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.\n+\n+Its `cmdString` for P2PV1 is `geturoot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `36`.\n+\n+| Field                      | Type                    | Description                                                                                                      |\n+|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that the requested utreexo root message is for                                             |\n+\n+### New Inventory Types\n+\n+#### MSG_UTREEXO_PROOF_HASH\n+\n+Defined as `6`.\n+\n+- It's used in the `inv` and `getdata` messages to communicate positions in the Utreexo merkle forest.\n+- The communicated positions MUST be in order of the referenced UTXO in the inputs.\n+- Unconfirmed UTXOs for the given transaction will NOT have a position associated with it.\n+- MUST be appended to another `invvect` of type `MSG_TX`, `MSG_WITNESS_TX`, `MSG_UTREEXO_TX`, or a `MSG_WITNESS_UTREEXO_TX`.\n+- Ignored if an `invvect` of type `MSG_UTREEXO_PROOF_HASH` is not pre-pended by any of the above 4 `invvect` types.\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+Defined as `7`.\n+\n+It's used in the `getdata` messages to communicate the block hash of the desired Utreexo summary.\n+\n+#### MSG_UTREEXO_FLAG\n+\n+Defined as `1 << 24`.\n+\n+It can be set with `MSG_TX` and `MSG_WITNESS_TX` to indicate in `getdata` messages that a Utreexo tx is desired.",
      "path": "bip-0183.md",
      "position": 450,
      "original_position": 450,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nIt can be set with `MSG_TX` and `MSG_WITNESS_TX` to indicate in `getdata` messages that a Utreexo transaction is desired.\r\n```",
      "created_at": "2025-09-19T23:16:55Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364786290",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364786290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 450,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364787171",
      "pull_request_review_id": 3247453919,
      "id": 2364787171,
      "node_id": "PRRC_kwDOAN28mc6M88nj",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.\n+\n+Its `cmdString` for P2PV1 is `geturoot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `36`.\n+\n+| Field                      | Type                    | Description                                                                                                      |\n+|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that the requested utreexo root message is for                                             |\n+\n+### New Inventory Types\n+\n+#### MSG_UTREEXO_PROOF_HASH\n+\n+Defined as `6`.\n+\n+- It's used in the `inv` and `getdata` messages to communicate positions in the Utreexo merkle forest.\n+- The communicated positions MUST be in order of the referenced UTXO in the inputs.\n+- Unconfirmed UTXOs for the given transaction will NOT have a position associated with it.\n+- MUST be appended to another `invvect` of type `MSG_TX`, `MSG_WITNESS_TX`, `MSG_UTREEXO_TX`, or a `MSG_WITNESS_UTREEXO_TX`.\n+- Ignored if an `invvect` of type `MSG_UTREEXO_PROOF_HASH` is not pre-pended by any of the above 4 `invvect` types.\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+Defined as `7`.\n+\n+It's used in the `getdata` messages to communicate the block hash of the desired Utreexo summary.\n+\n+#### MSG_UTREEXO_FLAG\n+\n+Defined as `1 << 24`.\n+\n+It can be set with `MSG_TX` and `MSG_WITNESS_TX` to indicate in `getdata` messages that a Utreexo tx is desired.\n+\n+#### MSG_UTREEXO_TX\n+\n+Defined as `16777217` or `1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a Utreexo tx is desired.\n+\n+#### MSG_WITNESS_UTREEXO_TX\n+\n+Defined as `1090519041` or `1 << 30 | 1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a witness Utreexo tx is desired.",
      "path": "bip-0183.md",
      "position": 462,
      "original_position": 462,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nUsed to indicate in a `getdata` message that a Utreexo transaction is desired.\r\n\r\n#### MSG_WITNESS_UTREEXO_TX\r\n\r\nDefined as `1090519041` or `1 << 30 | 1 << 24 | 1`.\r\n\r\nUsed to indicate in a `getdata` message that a witness Utreexo transaction is desired.\r\n```",
      "created_at": "2025-09-19T23:17:23Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364787171",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364787171"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 456,
      "original_start_line": 456,
      "start_side": "RIGHT",
      "line": 462,
      "original_line": 462,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364788348",
      "pull_request_review_id": 3247453919,
      "id": 2364788348,
      "node_id": "PRRC_kwDOAN28mc6M8858",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.\n+\n+Its `cmdString` for P2PV1 is `geturoot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `36`.\n+\n+| Field                      | Type                    | Description                                                                                                      |\n+|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that the requested utreexo root message is for                                             |\n+\n+### New Inventory Types\n+\n+#### MSG_UTREEXO_PROOF_HASH\n+\n+Defined as `6`.\n+\n+- It's used in the `inv` and `getdata` messages to communicate positions in the Utreexo merkle forest.\n+- The communicated positions MUST be in order of the referenced UTXO in the inputs.\n+- Unconfirmed UTXOs for the given transaction will NOT have a position associated with it.\n+- MUST be appended to another `invvect` of type `MSG_TX`, `MSG_WITNESS_TX`, `MSG_UTREEXO_TX`, or a `MSG_WITNESS_UTREEXO_TX`.\n+- Ignored if an `invvect` of type `MSG_UTREEXO_PROOF_HASH` is not pre-pended by any of the above 4 `invvect` types.\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+Defined as `7`.\n+\n+It's used in the `getdata` messages to communicate the block hash of the desired Utreexo summary.\n+\n+#### MSG_UTREEXO_FLAG\n+\n+Defined as `1 << 24`.\n+\n+It can be set with `MSG_TX` and `MSG_WITNESS_TX` to indicate in `getdata` messages that a Utreexo tx is desired.\n+\n+#### MSG_UTREEXO_TX\n+\n+Defined as `16777217` or `1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a Utreexo tx is desired.\n+\n+#### MSG_WITNESS_UTREEXO_TX\n+\n+Defined as `1090519041` or `1 << 30 | 1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a witness Utreexo tx is desired.\n+\n+### Commitment scheme for TTL messages\n+\n+We choose an arbitrary height `X` and go through each of `TTL info` in all the the `Utreexo TTL` values up until that height.",
      "path": "bip-0183.md",
      "position": 466,
      "original_position": 466,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nWe choose an arbitrary height `X` and go through each of `TTL Info`s in all of the `Utreexo TTL` values up until that height.\r\n```",
      "created_at": "2025-09-19T23:18:02Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364788348",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364788348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 466,
      "original_line": 466,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364789004",
      "pull_request_review_id": 3247453919,
      "id": 2364789004,
      "node_id": "PRRC_kwDOAN28mc6M89EM",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.\n+\n+Its `cmdString` for P2PV1 is `geturoot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `36`.\n+\n+| Field                      | Type                    | Description                                                                                                      |\n+|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that the requested utreexo root message is for                                             |\n+\n+### New Inventory Types\n+\n+#### MSG_UTREEXO_PROOF_HASH\n+\n+Defined as `6`.\n+\n+- It's used in the `inv` and `getdata` messages to communicate positions in the Utreexo merkle forest.\n+- The communicated positions MUST be in order of the referenced UTXO in the inputs.\n+- Unconfirmed UTXOs for the given transaction will NOT have a position associated with it.\n+- MUST be appended to another `invvect` of type `MSG_TX`, `MSG_WITNESS_TX`, `MSG_UTREEXO_TX`, or a `MSG_WITNESS_UTREEXO_TX`.\n+- Ignored if an `invvect` of type `MSG_UTREEXO_PROOF_HASH` is not pre-pended by any of the above 4 `invvect` types.\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+Defined as `7`.\n+\n+It's used in the `getdata` messages to communicate the block hash of the desired Utreexo summary.\n+\n+#### MSG_UTREEXO_FLAG\n+\n+Defined as `1 << 24`.\n+\n+It can be set with `MSG_TX` and `MSG_WITNESS_TX` to indicate in `getdata` messages that a Utreexo tx is desired.\n+\n+#### MSG_UTREEXO_TX\n+\n+Defined as `16777217` or `1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a Utreexo tx is desired.\n+\n+#### MSG_WITNESS_UTREEXO_TX\n+\n+Defined as `1090519041` or `1 << 30 | 1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a witness Utreexo tx is desired.\n+\n+### Commitment scheme for TTL messages\n+\n+We choose an arbitrary height `X` and go through each of `TTL info` in all the the `Utreexo TTL` values up until that height.\n+\n+If the TTL in the `TTL info` is greater than the [numleaves](bip-0181.md#Definitions) value of the Utreexo accumulator at the chosen height `X`, we reset the `death position` and the `TTL` values to their default of 0.",
      "path": "bip-0183.md",
      "position": 468,
      "original_position": 468,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nIf the TTL in the `TTL Info` is greater than the [numleaves](bip-0181.md#Definitions) value of the Utreexo accumulator at the chosen height `X`, we reset the `death position` and the `TTL` values to their default of 0.\r\n```",
      "created_at": "2025-09-19T23:18:21Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364789004",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364789004"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 468,
      "original_line": 468,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364790248",
      "pull_request_review_id": 3247453919,
      "id": 2364790248,
      "node_id": "PRRC_kwDOAN28mc6M89Xo",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.\n+\n+Its `cmdString` for P2PV1 is `geturoot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `36`.\n+\n+| Field                      | Type                    | Description                                                                                                      |\n+|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that the requested utreexo root message is for                                             |\n+\n+### New Inventory Types\n+\n+#### MSG_UTREEXO_PROOF_HASH\n+\n+Defined as `6`.\n+\n+- It's used in the `inv` and `getdata` messages to communicate positions in the Utreexo merkle forest.\n+- The communicated positions MUST be in order of the referenced UTXO in the inputs.\n+- Unconfirmed UTXOs for the given transaction will NOT have a position associated with it.\n+- MUST be appended to another `invvect` of type `MSG_TX`, `MSG_WITNESS_TX`, `MSG_UTREEXO_TX`, or a `MSG_WITNESS_UTREEXO_TX`.\n+- Ignored if an `invvect` of type `MSG_UTREEXO_PROOF_HASH` is not pre-pended by any of the above 4 `invvect` types.\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+Defined as `7`.\n+\n+It's used in the `getdata` messages to communicate the block hash of the desired Utreexo summary.\n+\n+#### MSG_UTREEXO_FLAG\n+\n+Defined as `1 << 24`.\n+\n+It can be set with `MSG_TX` and `MSG_WITNESS_TX` to indicate in `getdata` messages that a Utreexo tx is desired.\n+\n+#### MSG_UTREEXO_TX\n+\n+Defined as `16777217` or `1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a Utreexo tx is desired.\n+\n+#### MSG_WITNESS_UTREEXO_TX\n+\n+Defined as `1090519041` or `1 << 30 | 1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a witness Utreexo tx is desired.\n+\n+### Commitment scheme for TTL messages\n+\n+We choose an arbitrary height `X` and go through each of `TTL info` in all the the `Utreexo TTL` values up until that height.\n+\n+If the TTL in the `TTL info` is greater than the [numleaves](bip-0181.md#Definitions) value of the Utreexo accumulator at the chosen height `X`, we reset the `death position` and the `TTL` values to their default of 0.\n+Then these `Utreexo TTL` values are hashed with the hash function SHA512/256[^4] and added in height order to the commitment Utreexo accumulator.\n+\n+Note that this commitment Utreexo accumulator is separate from the Utreexo accumulator being used to represent the UTXO set.\n+\n+The resulting [numleaves](bip-0181.md#Definitions) and [roots](bip-0181.md#Definitions) are committed into the distributed binary which then the nodes opting in can use to validate that the `Utreexo TTL` values received from peers was generated in the same way as the described commitment scheme.\n+\n+### Signaling\n+\n+This BIP allocates two new service bits:\n+\n+| Field                | Type           | Description                                                                                                                         |\n+|----------------------|----------------|-------------------------------------------------------------------------------------------------------------------------------------|\n+| NODE_UTREEXO         | 1 << 12        | Nodes that signal this bit MUST be able to propagate inclusion proofs for new blocks and transactions and for their other advertised services. Nodes signaling NODE_UTREEXO and NODE_NETWORK_LIMITED MUST serve inclusion proofs for the last 288 blocks. Nodes signaling NODE_UTREEXO and NODE_NETWORK MUST serve inclusion proofs for all historical blocks.\n+| NODE_UTREEXO_ARCHIVE | 1 << 13        | Nodes that signal this bit MUST be able to serve historical inclusion proofs for all blocks. These nodes do not have to serve historical blocks.\n+\n+`NODE_UTREEXO` signals that the node understands Utreexo and will serve inclusion proofs for advertised txs and blocks.\n+\n+`NODE_UTREEXO_ARCHIVE` is specifically for nodes that only keep the historical inclusion proofs for all the blocks.\n+This bit is to allow for nodes that *only* serve the historical inclusion proofs.\n+\n+Example cases:\n+\n+| Used Service bits                                |  Description                                                                                                                         |\n+|------------------------------------------------- |--------------------------------------------------------------------------------------------------------------------------------------|\n+| NODE_NETWORK, NODE_UTREEXO_ARCHIVE, NODE_UTREEXO | Historical blocks + inclusion proofs for historical blocks + inclusion proofs for txs and new blocks                                 |  \n+| NODE_NETWORK_LIMITED, NODE_UTREEXO               | Latest 288 blocks + inclusion proofs for latest 288 blocks + inclusion proofs for txs and new blocks                                 |\n+| NODE_UTREEXO                                     | Inclusion proofs for txs and new blocks                                                                                              |\n+| NODE_UTREEXO_ARCHIVE                             | Inclusion proofs for historical blocks                                                                                               |\n+\n+## Rationale\n+\n+**Why is there a separate NODE_UTREEXO_ARCHIVE service bit from the NODE_UTREEXO service bit?**\n+\n+For archive nodes, we wanted the ability for a node to keep just the historical Utreexo proofs since the historical blocks can be served by any archival nodes.",
      "path": "bip-0183.md",
      "position": 502,
      "original_position": 502,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nFor archival nodes, we wanted the ability for a node to keep just the historical Utreexo proofs since the historical blocks can be served by any archival node.\r\n```",
      "created_at": "2025-09-19T23:19:09Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364790248",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364790248"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 502,
      "original_line": 502,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364791983",
      "pull_request_review_id": 3247453919,
      "id": 2364791983,
      "node_id": "PRRC_kwDOAN28mc6M89yv",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.\n+\n+Its `cmdString` for P2PV1 is `geturoot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `36`.\n+\n+| Field                      | Type                    | Description                                                                                                      |\n+|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that the requested utreexo root message is for                                             |\n+\n+### New Inventory Types\n+\n+#### MSG_UTREEXO_PROOF_HASH\n+\n+Defined as `6`.\n+\n+- It's used in the `inv` and `getdata` messages to communicate positions in the Utreexo merkle forest.\n+- The communicated positions MUST be in order of the referenced UTXO in the inputs.\n+- Unconfirmed UTXOs for the given transaction will NOT have a position associated with it.\n+- MUST be appended to another `invvect` of type `MSG_TX`, `MSG_WITNESS_TX`, `MSG_UTREEXO_TX`, or a `MSG_WITNESS_UTREEXO_TX`.\n+- Ignored if an `invvect` of type `MSG_UTREEXO_PROOF_HASH` is not pre-pended by any of the above 4 `invvect` types.\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+Defined as `7`.\n+\n+It's used in the `getdata` messages to communicate the block hash of the desired Utreexo summary.\n+\n+#### MSG_UTREEXO_FLAG\n+\n+Defined as `1 << 24`.\n+\n+It can be set with `MSG_TX` and `MSG_WITNESS_TX` to indicate in `getdata` messages that a Utreexo tx is desired.\n+\n+#### MSG_UTREEXO_TX\n+\n+Defined as `16777217` or `1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a Utreexo tx is desired.\n+\n+#### MSG_WITNESS_UTREEXO_TX\n+\n+Defined as `1090519041` or `1 << 30 | 1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a witness Utreexo tx is desired.\n+\n+### Commitment scheme for TTL messages\n+\n+We choose an arbitrary height `X` and go through each of `TTL info` in all the the `Utreexo TTL` values up until that height.\n+\n+If the TTL in the `TTL info` is greater than the [numleaves](bip-0181.md#Definitions) value of the Utreexo accumulator at the chosen height `X`, we reset the `death position` and the `TTL` values to their default of 0.\n+Then these `Utreexo TTL` values are hashed with the hash function SHA512/256[^4] and added in height order to the commitment Utreexo accumulator.\n+\n+Note that this commitment Utreexo accumulator is separate from the Utreexo accumulator being used to represent the UTXO set.\n+\n+The resulting [numleaves](bip-0181.md#Definitions) and [roots](bip-0181.md#Definitions) are committed into the distributed binary which then the nodes opting in can use to validate that the `Utreexo TTL` values received from peers was generated in the same way as the described commitment scheme.\n+\n+### Signaling\n+\n+This BIP allocates two new service bits:\n+\n+| Field                | Type           | Description                                                                                                                         |\n+|----------------------|----------------|-------------------------------------------------------------------------------------------------------------------------------------|\n+| NODE_UTREEXO         | 1 << 12        | Nodes that signal this bit MUST be able to propagate inclusion proofs for new blocks and transactions and for their other advertised services. Nodes signaling NODE_UTREEXO and NODE_NETWORK_LIMITED MUST serve inclusion proofs for the last 288 blocks. Nodes signaling NODE_UTREEXO and NODE_NETWORK MUST serve inclusion proofs for all historical blocks.\n+| NODE_UTREEXO_ARCHIVE | 1 << 13        | Nodes that signal this bit MUST be able to serve historical inclusion proofs for all blocks. These nodes do not have to serve historical blocks.\n+\n+`NODE_UTREEXO` signals that the node understands Utreexo and will serve inclusion proofs for advertised txs and blocks.\n+\n+`NODE_UTREEXO_ARCHIVE` is specifically for nodes that only keep the historical inclusion proofs for all the blocks.\n+This bit is to allow for nodes that *only* serve the historical inclusion proofs.\n+\n+Example cases:\n+\n+| Used Service bits                                |  Description                                                                                                                         |\n+|------------------------------------------------- |--------------------------------------------------------------------------------------------------------------------------------------|\n+| NODE_NETWORK, NODE_UTREEXO_ARCHIVE, NODE_UTREEXO | Historical blocks + inclusion proofs for historical blocks + inclusion proofs for txs and new blocks                                 |  \n+| NODE_NETWORK_LIMITED, NODE_UTREEXO               | Latest 288 blocks + inclusion proofs for latest 288 blocks + inclusion proofs for txs and new blocks                                 |\n+| NODE_UTREEXO                                     | Inclusion proofs for txs and new blocks                                                                                              |\n+| NODE_UTREEXO_ARCHIVE                             | Inclusion proofs for historical blocks                                                                                               |\n+\n+## Rationale\n+\n+**Why is there a separate NODE_UTREEXO_ARCHIVE service bit from the NODE_UTREEXO service bit?**\n+\n+For archive nodes, we wanted the ability for a node to keep just the historical Utreexo proofs since the historical blocks can be served by any archival nodes.\n+In order to differeniate nodes that serve just the historical Utreexo proofs and not the blocks, we needed to create a separate service bit.\n+\n+**Why is there a need for the MSG_UTREEXO_PROOF message? Couldn't there be a MSG_UTREEXO_BLOCK message where the Utreexo proof data is included along with the Bitcoin block data?**\n+\n+It's for the same reason as why we have a separate NODE_UTREEXO_ARCHIVE service bit.\n+\n+We wanted to allow for a node that only keeps the historical Utreexo proofs.\n+If we have only have a MSG_UTREEXO_BLOCK message, all Utreexo archive nodes would need to keep the block data as well.\n+\n+**Why is there a need for TTL messages?**\n+\n+We wanted there to be a caching method that has the same security as [assumed valid](https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks) that would help Utreexo nodes save bandwidth during the initial block download.\n+\n+The TTL data in the TTL message allows each individual Utreexo node to calculate which leaves to cache with the Clairvoyant algorithm[^1], allowing for the most optimal memory utilization.\n+This data could have been provided in the software distribution itself, but to save on binary size, we instead put the roots of the TTL accumulator in the binary and propagate the actual TTL data in the Bitcoin P2P network with the TTL message.\n+Since the TTL data is committed in the TTL accumulator, a Utreexo node can validate that the received TTL message is included in the TTL accumulator.\n+\n+**Why are the positions in the Utreexo merkle forest communicated via inventory vectors instead of a separate message?**\n+\n+We decided to communicate the positions in the Utreexo merkle forest by inventory vectors instead of a separate message to avoid an extra round trip during the transaction propagation.\n+\n+As mentioned above in [Transaction Relay](#transaction-relay), non-Utreexo nodes propagate a transaction in these 3 steps:",
      "path": "bip-0183.md",
      "position": 524,
      "original_position": 524,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nAs mentioned above in [Transaction Relay](#transaction-relay), non-Utreexo nodes propagate a transaction in 3 steps:\r\n```",
      "created_at": "2025-09-19T23:20:00Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364791983",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364791983"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 524,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364794334",
      "pull_request_review_id": 3247453919,
      "id": 2364794334,
      "node_id": "PRRC_kwDOAN28mc6M8-Xe",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.\n+\n+Its `cmdString` for P2PV1 is `geturoot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `36`.\n+\n+| Field                      | Type                    | Description                                                                                                      |\n+|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that the requested utreexo root message is for                                             |\n+\n+### New Inventory Types\n+\n+#### MSG_UTREEXO_PROOF_HASH\n+\n+Defined as `6`.\n+\n+- It's used in the `inv` and `getdata` messages to communicate positions in the Utreexo merkle forest.\n+- The communicated positions MUST be in order of the referenced UTXO in the inputs.\n+- Unconfirmed UTXOs for the given transaction will NOT have a position associated with it.\n+- MUST be appended to another `invvect` of type `MSG_TX`, `MSG_WITNESS_TX`, `MSG_UTREEXO_TX`, or a `MSG_WITNESS_UTREEXO_TX`.\n+- Ignored if an `invvect` of type `MSG_UTREEXO_PROOF_HASH` is not pre-pended by any of the above 4 `invvect` types.\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+Defined as `7`.\n+\n+It's used in the `getdata` messages to communicate the block hash of the desired Utreexo summary.\n+\n+#### MSG_UTREEXO_FLAG\n+\n+Defined as `1 << 24`.\n+\n+It can be set with `MSG_TX` and `MSG_WITNESS_TX` to indicate in `getdata` messages that a Utreexo tx is desired.\n+\n+#### MSG_UTREEXO_TX\n+\n+Defined as `16777217` or `1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a Utreexo tx is desired.\n+\n+#### MSG_WITNESS_UTREEXO_TX\n+\n+Defined as `1090519041` or `1 << 30 | 1 << 24 | 1`.\n+\n+Used to indicate in a `getdata` message that a witness Utreexo tx is desired.\n+\n+### Commitment scheme for TTL messages\n+\n+We choose an arbitrary height `X` and go through each of `TTL info` in all the the `Utreexo TTL` values up until that height.\n+\n+If the TTL in the `TTL info` is greater than the [numleaves](bip-0181.md#Definitions) value of the Utreexo accumulator at the chosen height `X`, we reset the `death position` and the `TTL` values to their default of 0.\n+Then these `Utreexo TTL` values are hashed with the hash function SHA512/256[^4] and added in height order to the commitment Utreexo accumulator.\n+\n+Note that this commitment Utreexo accumulator is separate from the Utreexo accumulator being used to represent the UTXO set.\n+\n+The resulting [numleaves](bip-0181.md#Definitions) and [roots](bip-0181.md#Definitions) are committed into the distributed binary which then the nodes opting in can use to validate that the `Utreexo TTL` values received from peers was generated in the same way as the described commitment scheme.\n+\n+### Signaling\n+\n+This BIP allocates two new service bits:\n+\n+| Field                | Type           | Description                                                                                                                         |\n+|----------------------|----------------|-------------------------------------------------------------------------------------------------------------------------------------|\n+| NODE_UTREEXO         | 1 << 12        | Nodes that signal this bit MUST be able to propagate inclusion proofs for new blocks and transactions and for their other advertised services. Nodes signaling NODE_UTREEXO and NODE_NETWORK_LIMITED MUST serve inclusion proofs for the last 288 blocks. Nodes signaling NODE_UTREEXO and NODE_NETWORK MUST serve inclusion proofs for all historical blocks.\n+| NODE_UTREEXO_ARCHIVE | 1 << 13        | Nodes that signal this bit MUST be able to serve historical inclusion proofs for all blocks. These nodes do not have to serve historical blocks.\n+\n+`NODE_UTREEXO` signals that the node understands Utreexo and will serve inclusion proofs for advertised txs and blocks.\n+\n+`NODE_UTREEXO_ARCHIVE` is specifically for nodes that only keep the historical inclusion proofs for all the blocks.\n+This bit is to allow for nodes that *only* serve the historical inclusion proofs.\n+\n+Example cases:\n+\n+| Used Service bits                                |  Description                                                                                                                         |\n+|------------------------------------------------- |--------------------------------------------------------------------------------------------------------------------------------------|\n+| NODE_NETWORK, NODE_UTREEXO_ARCHIVE, NODE_UTREEXO | Historical blocks + inclusion proofs for historical blocks + inclusion proofs for txs and new blocks                                 |  \n+| NODE_NETWORK_LIMITED, NODE_UTREEXO               | Latest 288 blocks + inclusion proofs for latest 288 blocks + inclusion proofs for txs and new blocks                                 |\n+| NODE_UTREEXO                                     | Inclusion proofs for txs and new blocks                                                                                              |\n+| NODE_UTREEXO_ARCHIVE                             | Inclusion proofs for historical blocks                                                                                               |\n+\n+## Rationale\n+\n+**Why is there a separate NODE_UTREEXO_ARCHIVE service bit from the NODE_UTREEXO service bit?**\n+\n+For archive nodes, we wanted the ability for a node to keep just the historical Utreexo proofs since the historical blocks can be served by any archival nodes.\n+In order to differeniate nodes that serve just the historical Utreexo proofs and not the blocks, we needed to create a separate service bit.\n+\n+**Why is there a need for the MSG_UTREEXO_PROOF message? Couldn't there be a MSG_UTREEXO_BLOCK message where the Utreexo proof data is included along with the Bitcoin block data?**\n+\n+It's for the same reason as why we have a separate NODE_UTREEXO_ARCHIVE service bit.\n+\n+We wanted to allow for a node that only keeps the historical Utreexo proofs.\n+If we have only have a MSG_UTREEXO_BLOCK message, all Utreexo archive nodes would need to keep the block data as well.\n+\n+**Why is there a need for TTL messages?**\n+\n+We wanted there to be a caching method that has the same security as [assumed valid](https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks) that would help Utreexo nodes save bandwidth during the initial block download.\n+\n+The TTL data in the TTL message allows each individual Utreexo node to calculate which leaves to cache with the Clairvoyant algorithm[^1], allowing for the most optimal memory utilization.\n+This data could have been provided in the software distribution itself, but to save on binary size, we instead put the roots of the TTL accumulator in the binary and propagate the actual TTL data in the Bitcoin P2P network with the TTL message.\n+Since the TTL data is committed in the TTL accumulator, a Utreexo node can validate that the received TTL message is included in the TTL accumulator.\n+\n+**Why are the positions in the Utreexo merkle forest communicated via inventory vectors instead of a separate message?**\n+\n+We decided to communicate the positions in the Utreexo merkle forest by inventory vectors instead of a separate message to avoid an extra round trip during the transaction propagation.\n+\n+As mentioned above in [Transaction Relay](#transaction-relay), non-Utreexo nodes propagate a transaction in these 3 steps:\n+\n+  1. Receive the inventory message for the transaction.\n+  2. Send a getdata message for the transaction.\n+  3. Receive the transaction.\n+\n+The Utreexo nodes follow the same 3 steps because of the new MSG_UTREEXO_PROOF_HASH.\n+If we were to implement the following with a separate message, we would add a round trip and the entire transaction propagation would look like these 5 steps:\n+\n+  1. Receive the inventory message for the transaction.\n+  2. Send a message to get the positions in the Utreexo merkle forest for the transaction.\n+  3. Receive the positions in the Utreexo merkle forest.",
      "path": "bip-0183.md",
      "position": 535,
      "original_position": 535,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n  2. Send a message to get the positions in the Utreexo Merkle forest for the transaction.\r\n  3. Receive the positions in the Utreexo Merkle forest.\r\n```",
      "created_at": "2025-09-19T23:21:00Z",
      "updated_at": "2025-09-19T23:21:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364794334",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364794334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": 534,
      "original_start_line": 534,
      "start_side": "RIGHT",
      "line": 535,
      "original_line": 535,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364865372",
      "pull_request_review_id": 3247632882,
      "id": 2364865372,
      "node_id": "PRRC_kwDOAN28mc6M9Ptc",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+```\n+  BIP: 183\n+  Layer: Peer Services\n+  Title: Utreexo - Peer Services\n+  Author: Tadge Dryja <rx@awsomnet.org>\n+          Calvin Kim <bip@calvinkim.info>\n+          Davidson Souza <bip@dlsouza.dev>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0183\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2024-08-08\n+  License: BSD-3-Clause\n+  Requires: 181, 182\n+```\n+\n+## Abstract\n+\n+Utreexo creates a compact representation of the UTXO set that only takes a couple of kilobytes.\n+When spending a transaction, one must provide an inclusion proof for the UTXOs being spent.\n+This BIP defines the networking-layer changes needed to allow nodes to exchange the inclusion proofs.\n+This document **does not** describe how to validate blocks and transactions using the provided data, see [BIP-0182](bip-0182.md) for more details.\n+\n+## Motivation\n+\n+Utreexo nodes require the inclusion proof to fully validate blocks and transactions.\n+Each block has a corresponding inclusion proof with it and this inclusion proof for blocks up to height 906,937 requires an additional 631.85GB, which is roughly 40GB less than the size of the block data.\n+Each transaction also has a corresponding inclusion proof with it and for normal transaction relay, the proof is roughly 3 times the size of the transaction.\n+It's still reasonable for a single node to download this extra data but a little caching goes a long way in reducing the amount of data that one has to download.\n+We define the new P2P messages for the inclusion proofs to support caching to reduce bandwidth while also allowing a high bandwidth, low-latency usage.\n+\n+## License\n+\n+This BIP is licensed under the BSD-3-Clause license.\n+\n+## Overview\n+\n+### Requirements and Compatibility\n+\n+Nodes implementing Utreexo can choose which messages to support.\n+There are a number of configurations possible, and this BIP does not restrict nodes to any subsets of messages.\n+\n+That said, there are three likely types of nodes:\n+1. Compact State Nodes (CSNs)\n+2. Bridge nodes\n+3. Archive nodes\n+\n+CSNs have the goal of minimizing data storage and download while performing block validation.\n+Archive and bridge nodes store more data and provide this data to CSNs.\n+\n+Bridge nodes are nodes that can add inclusion proofs to mempool transactions, support the same set of messages as CSNs, and should in fact be indistinguishable from CSNs on the network.\n+Archive nodes are able to serve the blocks and the inclusion proofs. However, they are not able to generate the inclusion proofs as they do not keep the full UTXO set.\n+\n+Note that the archive and bridge capabilities of a node are separate; a bridge node can be bridge only, without previous block proof data, and an archive node doesn't need to be able to bridge.\n+\n+The one exception to this flexibility is that archive nodes must provide both the blocks and the inclusion proofs.\n+While theoretically possible to split these two resources, the blocks are quite small relative to the block proofs, and it simplifies clients to be able to rely on being able to request both over the same connection.\n+\n+### Pre-P2P: Bridge Building\n+\n+When introducing Utreexo into an existing network, there are two things needed before CSNs can operate.\n+First, archive nodes need to build proofs for old blocks to serve during the initial block download (IBD).\n+Second, nodes need to build and maintain the UTXO merkle forest, and an index of outpoints to leaves of that forest, so that they can build proofs for new transactions.\n+Both of these processes happen without any p2p messages by taking an already existing, synchronized archive full node and going through its stored block data.\n+\n+Once an archive and bridge node have been established, CSNs download blocks and inclusion proofs to IBD and maintain sync with the bitcoin network. \n+\n+### Initial Block Download\n+\n+Conventionally, IBD is done by a headers-first block download, in which the node downloads all the Bitcoin block headers, verifies that they connect, and follows up by by downloading the block data for validation.\n+\n+Below image illustrates how a non-Utreexo node would perform the IBD.\n+\n+![Non-Utreexo IBD](bip-0183/non-utreexo-initial-block-download.png)\n+\n+Utreexo nodes still perform the headers-first phase.\n+However, in addition to blocks, they also require the inclusion proof for UTXOs spent in that block.\n+Hence, a Utreexo node will send a `getutreexoproof` message along with the `getdata` message for a given block.\n+This flow is the simplest change and allows a Utreexo node to validate and perform IBD but this method does require downloading about two times as much data as a conventional node due to the inclusion proof for a block being roughly the same size as the block itself.\n+\n+Below image illustrates how a Utreexo node would perform the IBD.\n+\n+![Utreexo node IBD](bip-0183/utreexo-initial-block-download.png)\n+\n+For Utreexo nodes with memory to spare, we introduce a `TTL` message that will have a time-to-live value for each of the outputs in a given block.\n+\n+With these TTL values, a node receiving the `TTL` message will be able to determine which output to cache with the Clairvoyant algorithm[^1] which allows the IBD-ing node to reduce the bandwidth required in syncing the node in the most efficient way possible.\n+\n+The node will have the block and the TTLs for the outputs of the given block which it can then use to cache parts of the inclusion proof and only request the needed parts of an inclusion proof for future blocks.\n+\n+We note that it is feasible for a node to receive incorrect TTL values from malicious nodes and this can negatively impact the bandwidth savings.\n+This can be mitigated by either:\n+\n+1. Avoiding downloading TTL values for blocks too far into the future since the damage done will be greater.\n+2. Rely on the pre-committed *TTL accumulator* in the node software.\n+   The TTL accumulator has TTLs for each of the blocks accumulated.\n+   With this accumulator, the node can check if the received TTL value is valid or invalid by checking for its existence in the TTL accumulator.\n+\n+The TTL accumulator is described in detail in the section [Commitment scheme for TTL messages](#commitment-scheme-for-ttl-messages) below.\n+\n+Below image illustrates how a Utreexo node would perform a bandwidth efficient IBD.\n+\n+![Bandwidth efficient Utreexo node IBD](bip-0183/bandwidth-efficient-utreexo-initial-block-download.png)\n+\n+### Transaction relay\n+\n+Non-Utreexo transaction relay is done by sending an inv message with the hash of the transaction and a type field that denotes that this hash represents a transaction.\n+If the node receiving the inv does not have a transaction matching that hash, the node then requests the transaction using a getdata message.\n+\n+Below image illustrates how a non-Utreexo node would relay transactions.\n+\n+![Non-Utreexo TX relay](bip-0183/non-utreexo-tx-relay.png)\n+\n+The transaction relay for Utreexo nodes doesn't add any extra round trips.\n+However, it does include extra inventory vectors in the inv message.\n+\n+We introduce a new inventory vector type called `utreexoproofhash`, which makes up the extra information that a Utreexo node will receive.\n+\n+A hash with the type `utreexoproofhash` represents four Utreexo merkle tree positions, each of them little-endian serialized and taking up 8 bytes in the 32-byte hash.\n+When sending an inv message to a Utreexo node for a transaction, we append `utreexoproofhash` inventory vectors to represent the merkle tree positions for each of the UTXOs being referenced in the inputs of the transaction.\n+The Utreexo merkle tree positions are explained in detail in [Utreexo Accumulator Specification](bip-0181#Merkle Forest).\n+Since the hash in an inventory vector is always 32 bytes, any unused space will be padded with the max uint64 value of 18446744073709551615.\n+\n+With these merkle tree positions for the UTXOs referenced in the inputs, we can calculate the needed positions of the merkle hashes to them.\n+These positions are then sent over in the `getdata` message as an another inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay transactions.\n+\n+![Utreexo TX relay](bip-0183/utreexo-tx-relay.png)\n+\n+There may be cases where the transaction is referencing more than 4 merkle positions.\n+In this case, the extra positions are added as another inventory vector.\n+There can be as many additional inventory vectors for the `utreexoproofhash`es as needed.\n+An inventory vector of type `utreexoproofhash` will be ignored if it's not prepended with an inventory vector of type `transaction`.\n+\n+Below image illustrates how a Utreexo node would relay transactions with multiple inventory vectors of the type `utreexoproofhash`.\n+\n+![Utreexo TX relay multiple Utreexo proof hash vectors](bip-0183/utreexo-tx-relay-with-multiple-proofhash-inventory-vectors.png)\n+\n+It's possible to have an inv message with multiple txs as well.\n+Note that an inventory vector of type `utreexoproofhash` MUST be appended to the `tx` inventory vector.\n+\n+Below image illustrates how a Utreexo node would relay multiple transactions.\n+\n+![Utreexo TX relay with multiple txs](bip-0183/utreexo-tx-relay-with-multiple-txs.png)\n+\n+### Block Propagation\n+\n+Legacy block propagation without Compact Blocks comprises of three steps:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node A sends the block data to Node B.\n+\n+Below image illustrates how a non-Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation](bip-0183/non-compact-block-block-propagation.png)\n+\n+The same block propagation with Utreexo nodes will look like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request for the block.\n+3. Node B makes a getutreexoproof request for the block.\n+4. Node A sends the block data to Node B.\n+5. Node A sends the inclusion proof to Node B.\n+\n+Note that while Node A sent the inv or the blockhash to Node B, Node B is free to ask for the Utreexo proof from a node other than Node A.\n+This allows a Utreexo node to be notified of new blocks from non-Utreexo nodes.\n+\n+Since there's no PoW required for the inclusion proof, the block may be valid and the proof may be invalid.\n+If the block header validation passed while the full block validation fails, Node B should request the inclusion proof from a different peer.\n+If the new proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks without using Compact Blocks.\n+\n+![Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/non-compact-block-utreexo-block-propagation.png)\n+\n+Since the inclusion proof is cached for each of the transaction in the mempool, it's possible to omit the proof hashes for the input UTXOs that we can already prove on our own.\n+This method looks like so:\n+\n+1. Node A sends an inv message or a block header to Node B.\n+2. Node B makes a getdata request (MSG_UTREEXO_SUMMARY) for the given blockhash.\n+3. Node A sends the utreexoblocksummary message to Node B.\n+4. Node B calculates which proof hashes and leafdatas it needs to prove this block.\n+5. Node B makes a getdata request for the block to Node A.\n+6. Node B makes a getutreexoproof request for the block to Node A.\n+7. Node A sends the block data to Node B.\n+8. Node A sends the requested inclusion proof data to Node B.\n+\n+As with the getutreexoproof message, Node B is free to ask for the utreexoblocksummary message from a node other than Node A.\n+Since there's no commitment to anything in a utreexoblocksummary message, the information given in it can be false.\n+Should the block fail to validate with this propagation, Node B should request the full proof from a different peer.\n+Should the proof and the block pass validation, we can conclude that Node A is malicious and ban the peer.\n+\n+All of the above propagation works the same with Compact Block propagation as well.\n+The requester would need to send a getdata request (MSG_UTREEXO_SUMMARY) after the Compact Block propagation has concluded for high-bandwidth Compact Block propagation and after the header/inv message was received from the broadcasting peer.\n+\n+Below image illustrates how a Utreexo node would relay blocks in a bandwidth efficient manner without using Compact Blocks.\n+\n+![Bandwidth Saving Non-Compact-Block Block Propagation with Utreexo Nodes](bip-0183/bandwidth-saving-non-compact-block-utreexo-block-propagation.png)\n+\n+## Specification\n+\n+Several new data structures and messages are introduced to make the IBD and tx relay possible.\n+All structures are little-endian encoded unless otherwise noted.\n+\n+### New data structures\n+\n+#### Compact leaf data\n+\n+For a CSN to learn the data associated with a UTXO, it must ask for it from a peer that has it.\n+To authenticate this data, it is committed into the accumulator, and therefore cannot be changed by the peer.\n+The committed data is defined in [Utreexo - Transaction and block validation](bip-0182#UTXO Hash Preimages), but for some information in the leaf data, the receiving peer might already have it, so sending it again is a waste of bandwidth.\n+To save that bandwidth, we only send a Compact Leaf Data, that contains all missing information for the receiving peer to reconstruct the full leaf data.\n+A compact leaf data is defined as:\n+\n+| Field        | type                         | Description     |\n+|--------------|------------------------------|-----------------|\n+| header code  | uint32                       | This is a value obtained by left shifting the block height that confirmed this transaction, and then OR-ing it with 1, only if this transaction is a coinbase. |\n+| amount       | int64                        | The amount in sats locked on this output |\n+| scriptPubkey | reconstructable scriptPubkey | The scriptPubkey in a reconstructable format, see [Reconstructable Script](#Reconstructable-Script) for more details |\n+\n+#### Reconstructable Script\n+\n+For some script types (e.g. `ScriptHash`, `PubkeyHash`, `WitnessScriptHash`, `WitnessPubkeyHash`) the actual locking condition is not in the scriptPubkey, but a hash of it.\n+The script which is evaluated is provided as an element of the scriptSig or witness data.\n+\n+Therefore, we can safely omit the locking script hash from the UTXO data and reconstruct it from the witness or scriptSig.\n+\n+A Reconstructable Script is a tagged union that lets nodes recreate the script without necessarily providing redundant information.\n+If we can reconstruct the committed hash from the transaction data, we just say which type should we expect.\n+Only if the actual script cannot be reconstructed from transaction data, like in the case of taproot outputs, we send the actual script.\n+\n+The serialization and tag values are given below:\n+\n+| Field   | Type                    | Description       | Required                 |\n+|---------|-------------------------|-------------------|--------------------------|\n+| tag     | 1-byte unsigned integer | Script type       | yes                      |\n+| length  | varint                  | The script length | only if tag type is 0x00 |\n+| script  | variable-length vector  | The actual script | only if tag type is 0x00 |\n+\n+The possible values for the tag are:\n+\n+| Value | Script Type         |\n+|-------|---------------------|\n+| 0x00  | Other               |\n+| 0x01  | Pubkey Hash         |\n+| 0x02  | WitnessV0PubkeyHash |\n+| 0x03  | ScriptHash          |\n+| 0x04  | WitnessV0ScriptHash |\n+\n+#### TTL Info\n+\n+For all UTXOs that get added to the Utreexo merkle forest, a TTL info exists for it and includes information necessary for efficiently caching and requesting proofs.\n+The TTL value provides information to determine which leaves should be cached and the death position is used to calculate which positions in the merkle forest we need to prove a block.\n+\n+| Field          | Type   | Description                                                                                                                                                          |\n+|----------------|--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| TTL            | varint | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation |\n+| death position | varint | The position in the Utreexo merkle forest when the leaf was removed                                                                                                  |\n+\n+#### Utreexo TTL\n+\n+| Field        | Type                | Description                                                                                                                                                                                                                                                    |\n+|--------------|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| block height | uint32              | The time-to-live value of a leaf in the Utreexo merkle forest. The value is determined by the amount of leaves that were added to the accumulator since its creation                                                                                           |\n+| length       | varint              | The length of the TTLs                                                                                                                                                                                                                                         |\n+| TTLs         | vector of TTL infos | The TTL Info for the UTXOs that are added to the Utreexo merkle forest in blockchain ordering. See [BIP-0182](bip-0182.md#excluded-utxos-from-the-accumulator) for the UTXOs that are not added to the Utreexo merkle forest |\n+\n+### New Messages\n+\n+#### MSG_UTREEXO_PROOF\n+\n+`MSG_UTREEXO_PROOF` is all the data required for a CSN or archive node using the Utreexo accumulators to validate a Bitcoin block.\n+\n+Its `cmdString` for P2PV1 is `uproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `29`.\n+\n+| Field                          | Type                         | Description                                                                                                                                |\n+|--------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n+| blockhash                      | 32 byte vector               | The hash of the block that this inclusion proof proves                                                                                     |\n+| length of the proof hashes     | varint                       | The length of the proof hashes                                                                                                             |\n+| proof hashes                   | vector of 32 byte vectors    | The hashes requested by MSG_GET_UTREEXO_PROOF. MUST be in tree order                                                                       |\n+| length of the target locations | varint                       | The length of the target locations                                                                                                         |\n+| target locations               | vector of varint values      | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations or none of the locations   |\n+| length of the leafdatas        | varint                       | The length of the leafdatas                                                                                                                |\n+| leafdatas                      | vector of compact leafdatas  | The preimage of the committed UTXOs requested by the MSG_GET_UTREEXO_PROOF. MUST be in blockchain order. See compact leaf data for details |\n+\n+The proof hashes MUST be in merkle forest tree ordering.\n+See BIP [Utreexo Accumulator Specification](bip-0181.md#Merkle Forest) for an explanation on how each of the hashes in the merkle forest are positioned.\n+\n+Each of the target location represents the position of the leaf data at the same index.\n+While each leaf data represent a UTXO in a given block, not all are added as per [Utreexo - Validation Layer](bip-0182.md#Excluded UTXOs from the accumulator).\n+\n+#### MSG_GET_UTREEXO_PROOF\n+\n+`MSG_GET_UTREEXO_PROOF` is a message to request the inclusion proof for a given block.\n+\n+Its `cmdString` for P2PV1 is `getuproof`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `30`.\n+\n+| Field                     | Type                        | Description                                                        |\n+|---------------------------|-----------------------------|--------------------------------------------------------------------|\n+| blockhash                 | 32 byte vector              | The hash of the bitcoin block that we want the inclusion proof for |\n+| include all               | boolean                     | A boolean value to request all parts of the inclusion proof        |\n+| proof request bitmap      | variable-length byte vector | A bitmap of the requested proof hashes                             |\n+| leaf data request bitmap  | variable-length byte vector | A bitmap of the requested leafdatas                                |\n+\n+The bitmaps here are formatted as big-endian and padded to the nearest byte, with 1 meaning a request for the proof hash or the leaf data, and 0 meaning omit the proof hash or the leaf data.\n+\n+Since there's one corresponding leaf data per target location, it's trivial to generate a bitmap for the leafdatas.\n+\n+Using the [proof_positions](bip-0181.md#utility-functions) function, it's possible to generate the positions of the needed proof hashes for a given set of targets.\n+With these positions, we can set the bit in the bitmap for the hashes we require.\n+\n+#### MSG_UTREEXO_TTLS\n+\n+`MSG_UTREEXO_TTLS` is the requested group of Utreexo TTLs that includes the proof hashes needed to validate that the given TTLs were committed in the provided binary.\n+\n+Its `cmdString` for P2PV1 is `uttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `31`.\n+\n+| Field                      | Type                                | Description                                   |\n+|----------------------------|-------------------------------------|-----------------------------------------------|\n+| length of the Utreexo TTLs | varint                              | The length of the Utreexo summaries           |\n+| Utreexo TTLs               | vector of Utreexo summaries         | The vector of the requested Utreexo summaries |\n+| length of the proof hashes | varint                              | The length of the proof hashes                |\n+| proof hashes               | vector of 32 byte hashes            | The vector of the requested proof hashes      |\n+\n+#### MSG_GET_UTREEXO_TTLS\n+\n+`MSG_GET_UTREEXO_TTLS` is used to request a MSG_UTREEXO_TTLS message.\n+\n+Its `cmdString` for P2PV1 is `getuttls`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `32`.\n+\n+| Field                | Type   | Description                                                                                                          |\n+|----------------------|--------|----------------------------------------------------------------------------------------------------------------------|\n+| Version              | uint32 | The height of the committed TTL accumulator. It's used to specify which accumulator the TTL should be proved against |\n+| Start height         | uint32 | The first block which the TTL message will be provided for                                                           |\n+| Max receive exponent | uint8  | Denotes how many TTLs should be provided in total. The provided TTL count will be $2^{Max Receive Exponent}$         |\n+\n+#### MSG_UTREEXO_SUMMARY\n+\n+`MSG_UTREEXO_SUMMARY` is the data needed to calculate the missing merkle forest positions required to validate a given block.\n+\n+Its `cmdString` for P2PV1 is `usummary`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `33`.\n+\n+| Field                      | Type                    | Description                                                                                                     |\n+|----------------------------|-------------------------|-----------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that this Utreexo block summary is for                                                    |\n+| num adds                   | varint                  | The count of leaves added to the accumulator on the block this Utreexo block summary is for                     |\n+| length of target locations | varint                  | The length of the target locations                                                                              |\n+| target locations           | vector of uint64 values | The Utreexo merkle tree locations of the leafdatas. MUST be in blockchain order. MUST include all the locations |\n+\n+#### MSG_UTREEXO_TX\n+\n+`MSG_UTREEXO_TX` is the non-Utreexo Bitcoin transaction appended with the inclusion proof.\n+\n+Its `cmdString` for P2PV1 is `utreexotx`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `34`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                     |\n+|----------------------------|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| transaction                | MSG_TX                       | The bitcoin transaction. Unconfirmed inputs are marked by shifting the index by 1 and setting the LSB                                                                                                           |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                  |\n+| proof hashes               | vector of 32 byte hashes     | The vector of the requested Utreexo summaries                                                                                                                                                                   |\n+| length of the leafdatas    | varint                       | The length of the leafdatas                                                                                                                                                                                     |\n+| leafdatas                  | vector of compact leafdatas  | The preimage of the leafdatas referenced in the bitcoin transaction. MUST be in the order of the referenced inputs. Unconfirmed inputs do not have a corresponding leaf data. See compact leaf data for details |\n+\n+For each of the referenced inputs in the Bitcoin transaction, we mark each unconfirmed UTXO by setting the index of its outpoint:\n+\n+```\n+index <<= 1\n+if IsUnconfirmed {\n+    index |= 1 // only set the bit if the UTXO referenced by the output is unconfirmed\n+}\n+```\n+\n+This step is required because if the unconfirmed UTXO is not explicitly marked, then a malicious peer can omit the leaf data for a confirmed UTXO and mislead us into believing that the transaction is an orphan.\n+\n+#### MSG_UTREEXO_ROOT\n+\n+`MSG_UTREEXO_ROOT` is the utreexo accumulator state at a given height with a proof to a utreexo accumulator of the utreexo roots.\n+\n+Its `cmdString` for P2PV1 is `uroot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `35`.\n+\n+| Field                      | Type                         | Description                                                                                                                                                                                                      |\n+|----------------------------|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| numleaves                  | varint                       | The number of leaves that was ever added to the accumulator at this block height. See [numleaves](bip-0181.md#Definitions)                                                                      |\n+| target                     | varint                       | The position of the utreexo root in the optional accumulator of the utreexo roots                                                                                                                                |\n+| blockhash                  | 32 byte vector               | The blockhash for this utreexo accumulator state                                                                                                                                                                 |\n+| length of the root hashes  | varint                       | The length of the root hashes                                                                                                                                                                                    |\n+| root hashes                | vector of 32 byte hashes     | The utreexo roots for the UTXO set at the blockhash. See [roots](bip-0181.md#Definitions)                                                                                                       |\n+| length of the proof hashes | varint                       | The length of the proof hashes                                                                                                                                                                                   |\n+| proof hashes               | vector of 32 byte hashes     | The proof hashes needed to validate with the pre-committed utreexo accumulator of the utreexo roots                                                                                                              |\n+\n+This message is for implementing an out-of-order block validation node[^2] or softchains[^3].\n+\n+Because the size of the state needed to validate blocks is so small with Utreexo, nodes can perform IBD in parallel and out of order.\n+\n+For example, a computer could divide the task of validating 800,000 blocks into 100 tasks of 8,000 blocks each: blocks 1 through 800, 800 through 1600, 1600 through 2400, and so on.\n+\n+In order start the 1600 through 2400 IBD task, however, the node should know what the state of the utxo set is at block 1600, so that it can validate and modify the accumulator.\n+\n+In order to do this, the binary can provide \"linkup hints\", where the state of the accumulator is given for a desired block hash.\n+\n+While giving the state of the system might seem at first glance to be introducing a trust assumption, these are not trusted states.\n+The node performing IBD tries out the state given for a block height, but checks that when that state is reached from the thread \"below\" that it properly links up, with the accumulator state arrived at through full validation matching the state given.\n+If that link up does not successfully happen, the IBD process should halt.\n+\n+These hints are statements of fact that are hard-coded into the program itself, and if they are false all bets are off about the program.\n+\n+Archive nodes create a forest of Linkup hints, so that they can prove, with respect to the Linkup forest roots in a node performing IBD, what their binary has claimed the utxo accumulator state to be at any block height.\n+\n+#### MSG_GET_UTREEXO_ROOT\n+\n+`MSG_GET_UTREEXO_ROOT` is used to request a utreexo accumulator state at a given height.\n+\n+Its `cmdString` for P2PV1 is `geturoot`.\n+Its [BIP324 P2PV2](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-v2_Bitcoin_P2P_message_structure) message type is `36`.\n+\n+| Field                      | Type                    | Description                                                                                                      |\n+|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------|\n+| blockhash                  | 32 byte vector          | The hash of the block that the requested utreexo root message is for                                             |\n+\n+### New Inventory Types",
      "path": "bip-0183.md",
      "position": 428,
      "original_position": 428,
      "commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "original_commit_id": "bd1e2425872450b4b9d80cdcb47874d9659a3bda",
      "in_reply_to_id": null,
      "user": {
        "login": "luisschwab",
        "id": 97608688,
        "node_id": "U_kgDOBdFj8A",
        "avatar_url": "https://avatars.githubusercontent.com/u/97608688?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luisschwab",
        "html_url": "https://github.com/luisschwab",
        "followers_url": "https://api.github.com/users/luisschwab/followers",
        "following_url": "https://api.github.com/users/luisschwab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luisschwab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luisschwab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luisschwab/subscriptions",
        "organizations_url": "https://api.github.com/users/luisschwab/orgs",
        "repos_url": "https://api.github.com/users/luisschwab/repos",
        "events_url": "https://api.github.com/users/luisschwab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luisschwab/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For all inventory types: be explicit about what needs to be provided and in what format (eg: blockhash, leaf positions, etc..).",
      "created_at": "2025-09-20T00:01:21Z",
      "updated_at": "2025-09-20T00:01:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1923#discussion_r2364865372",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2364865372"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1923"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 428,
      "original_line": 428,
      "side": "RIGHT"
    }
  ]
}