{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/2070",
    "id": 3143734105,
    "node_id": "PR_kwDOAN28mc67YZNZ",
    "html_url": "https://github.com/bitcoin/bips/pull/2070",
    "diff_url": "https://github.com/bitcoin/bips/pull/2070.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/2070.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/2070/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/ec46a20323840b1a6aba83bc2d18b34dd0811245",
    "number": 2070,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "BIP Draft: FROST Signing Protocol for BIP340 Signatures",
    "user": {
      "login": "siv2r",
      "id": 56887198,
      "node_id": "MDQ6VXNlcjU2ODg3MTk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/siv2r",
      "html_url": "https://github.com/siv2r",
      "followers_url": "https://api.github.com/users/siv2r/followers",
      "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
      "organizations_url": "https://api.github.com/users/siv2r/orgs",
      "repos_url": "https://api.github.com/users/siv2r/repos",
      "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/siv2r/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "This PR adds a BIP for the FROST (Flexible Round-Optimized Schnorr Threshold) signing protocol. The development repository is at https://github.com/siv2r/bip-frost-signing.\r\n\r\nThere already exists [RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html), which standardizes the two-round FROST signing protocol, but it is incompatible with Bitcoin's BIP340 X-only public keys. This BIP bridges that gap by providing a BIP340-compatible variant of FROST.\r\n\r\nThis BIP standardizes the FROST3 variant (Section 2.3 of the [ROAST paper](https://eprint.iacr.org/2022/550.pdf)). This variant shares significant similarities with the MuSig2 signing protocol (BIP327). Accordingly, this BIP follows the core design principles of [BIP327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki), and many sections have been directly adapted from it.\r\n\r\nFROST key generation is out of scope for this BIP. There are sister BIPs such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg) and [Trusted Dealer Generation](https://github.com/BEULAHEVANJALIN/bip-frost-trusted-dealer) that specify key generation mechanisms. This BIP must be used in conjunction with either of those for the full workflow from key generation to signature creation. Careful consideration has been taken to ensure the terminology in this BIP matches that of ChillDKG.\r\n\r\nThere are multiple (experimental) implementations of this specification:\r\n- The reference Python implementation included in this PR\r\n- [secp256k1-zkp FROST module](https://github.com/BlockstreamResearch/secp256k1-zkp/pull/278) (yet to implement the test vectors)\r\n- [FROST-BIP340](https://github.com/jesseposner/FROST-BIP340)\r\n- ~[secp256kfun](https://github.com/LLFourn/secp256kfun/blob/master/schnorr_fun/src/frost/session.rs) (implements ChillDKG with FROST signing)~ TODO: verify if secp256k1fun passes our test vectors\r\n\r\n**Disclosure:** AI has been used to rephrase paragraphs for clarity, refactor certain sections of the reference code, and review pull requests made to the development repository. \r\n\r\nFeedback is appreciated! Please comment on this pull request or open an issue at https://github.com/siv2r/bip-frost-signing for any feedback. Thank you!\r\n\r\ncc @jonasnick @real-or-random @jesseposner",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2026-01-03T18:00:46Z",
    "updated_at": "2026-01-22T17:30:08Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merged": false,
    "merge_commit_sha": "b885ae4f78a569eb88da3bd45b3124ca1d2d5f43",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "siv2r:bip-frost-signing",
      "ref": "bip-frost-signing",
      "sha": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 433631019,
        "node_id": "R_kgDOGdivKw",
        "name": "bips",
        "full_name": "siv2r/bips",
        "owner": {
          "login": "siv2r",
          "id": 56887198,
          "node_id": "MDQ6VXNlcjU2ODg3MTk4",
          "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/siv2r",
          "html_url": "https://github.com/siv2r",
          "followers_url": "https://api.github.com/users/siv2r/followers",
          "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
          "organizations_url": "https://api.github.com/users/siv2r/orgs",
          "repos_url": "https://api.github.com/users/siv2r/repos",
          "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/siv2r/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/siv2r/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/siv2r/bips",
        "archive_url": "https://api.github.com/repos/siv2r/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/siv2r/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/siv2r/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/siv2r/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/siv2r/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/siv2r/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/siv2r/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/siv2r/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/siv2r/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/siv2r/bips/contributors",
        "deployments_url": "https://api.github.com/repos/siv2r/bips/deployments",
        "downloads_url": "https://api.github.com/repos/siv2r/bips/downloads",
        "events_url": "https://api.github.com/repos/siv2r/bips/events",
        "forks_url": "https://api.github.com/repos/siv2r/bips/forks",
        "git_commits_url": "https://api.github.com/repos/siv2r/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/siv2r/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/siv2r/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/siv2r/bips.git",
        "issue_comment_url": "https://api.github.com/repos/siv2r/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/siv2r/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/siv2r/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/siv2r/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/siv2r/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/siv2r/bips/languages",
        "merges_url": "https://api.github.com/repos/siv2r/bips/merges",
        "milestones_url": "https://api.github.com/repos/siv2r/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/siv2r/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/siv2r/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/siv2r/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:siv2r/bips.git",
        "stargazers_url": "https://api.github.com/repos/siv2r/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/siv2r/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/siv2r/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/siv2r/bips/subscription",
        "tags_url": "https://api.github.com/repos/siv2r/bips/tags",
        "teams_url": "https://api.github.com/repos/siv2r/bips/teams",
        "trees_url": "https://api.github.com/repos/siv2r/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/siv2r/bips.git",
        "hooks_url": "https://api.github.com/repos/siv2r/bips/hooks",
        "svn_url": "https://github.com/siv2r/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 1,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 18919,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-01-08T07:11:59Z",
        "created_at": "2021-12-01T00:28:09Z",
        "updated_at": "2026-01-03T11:21:21Z",
        "allow_forking": true
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "fc00f51c229088c447b3694cca9bf14ace0e1a96",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5876,
        "stargazers_count": 10514,
        "watchers_count": 10514,
        "size": 18017,
        "default_branch": "master",
        "open_issues_count": 73,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-01-17T04:35:04Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2026-01-22T13:26:31Z",
        "allow_forking": true
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 6675,
    "deletions": 0,
    "changed_files": 39,
    "commits": 2,
    "review_comments": 40,
    "comments": 6
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGI3ZTQyZjkzYjU2NTEwNTVhNGU5YTEyMDJlNzBiMWI0MzI0NmQ0ZDE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "tree": {
        "sha": "b57db43fa590354164a66b4597a0101f0b44ed65",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/b57db43fa590354164a66b4597a0101f0b44ed65"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b57db43fa590354164a66b4597a0101f0b44ed65\nparent fc00f51c229088c447b3694cca9bf14ace0e1a96\nauthor siv2r <siv2ram@gmail.com> 1767446416 +0530\ncommitter siv2r <siv2ram@gmail.com> 1767446827 +0530\n\nAdd BIP FROST Signing for Schnorr threshold signatures\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRv2EYOHAumKdeBnCb+DYEu6GLj3QUCaVkZKwAKCRD+DYEu6GLj\n3apdAQDnR7ccLVi17lCqkHKbtuc78SVx4gCYNSbeZe6copQb9AD/XJFZK9rDuF8R\n6TAwJfSLkPT4ITNxan1n7kweycuguQE=\n=s6Q7\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/fc00f51c229088c447b3694cca9bf14ace0e1a96",
          "sha": "fc00f51c229088c447b3694cca9bf14ace0e1a96",
          "html_url": "https://github.com/bitcoin/bips/commit/fc00f51c229088c447b3694cca9bf14ace0e1a96"
        }
      ],
      "message": "Add BIP FROST Signing for Schnorr threshold signatures",
      "committer": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-03T13:27:07Z"
      },
      "author": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-03T13:20:16Z"
      },
      "sha": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1"
    },
    {
      "event": "mentioned",
      "id": 21837284561,
      "node_id": "MEE_lADOAN28mc7hNLslzwAAAAUVmoTR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284561",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "subscribed",
      "id": 21837284566,
      "node_id": "SE_lADOAN28mc7hNLslzwAAAAUVmoTW",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284566",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "mentioned",
      "id": 21837284569,
      "node_id": "MEE_lADOAN28mc7hNLslzwAAAAUVmoTZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284569",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "subscribed",
      "id": 21837284577,
      "node_id": "SE_lADOAN28mc7hNLslzwAAAAUVmoTh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284577",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "mentioned",
      "id": 21837284584,
      "node_id": "MEE_lADOAN28mc7hNLslzwAAAAUVmoTo",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284584",
      "actor": {
        "login": "jesseposner",
        "id": 12010116,
        "node_id": "MDQ6VXNlcjEyMDEwMTE2",
        "avatar_url": "https://avatars.githubusercontent.com/u/12010116?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jesseposner",
        "html_url": "https://github.com/jesseposner",
        "followers_url": "https://api.github.com/users/jesseposner/followers",
        "following_url": "https://api.github.com/users/jesseposner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jesseposner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jesseposner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jesseposner/subscriptions",
        "organizations_url": "https://api.github.com/users/jesseposner/orgs",
        "repos_url": "https://api.github.com/users/jesseposner/repos",
        "events_url": "https://api.github.com/users/jesseposner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jesseposner/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "subscribed",
      "id": 21837284587,
      "node_id": "SE_lADOAN28mc7hNLslzwAAAAUVmoTr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21837284587",
      "actor": {
        "login": "jesseposner",
        "id": 12010116,
        "node_id": "MDQ6VXNlcjEyMDEwMTE2",
        "avatar_url": "https://avatars.githubusercontent.com/u/12010116?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jesseposner",
        "html_url": "https://github.com/jesseposner",
        "followers_url": "https://api.github.com/users/jesseposner/followers",
        "following_url": "https://api.github.com/users/jesseposner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jesseposner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jesseposner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jesseposner/subscriptions",
        "organizations_url": "https://api.github.com/users/jesseposner/orgs",
        "repos_url": "https://api.github.com/users/jesseposner/repos",
        "events_url": "https://api.github.com/users/jesseposner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jesseposner/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:00:47Z"
    },
    {
      "event": "commented",
      "id": 3707251353,
      "node_id": "IC_kwDOAN28mc7c-CqZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3707251353",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:12:32Z",
      "updated_at": "2026-01-03T18:12:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "I'll fix the typos check soon",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3707251353",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "commented",
      "id": 3707273822,
      "node_id": "IC_kwDOAN28mc7c-IJe",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3707273822",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-03T18:49:43Z",
      "updated_at": "2026-01-04T08:57:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "I can see that GitHub's file changes view shows only one file at a time due to the large number of changes. This is because the reference implementation includes dependencies and auxiliary materials:\r\n\r\n- The reference code uses [secp256k1lab](https://github.com/secp256k1lab/secp256k1lab) python library (vendored as a git subtree, ~20 files) for scalar and group arithmetic. I can remove this from the PR when the library is integrated into this repository (#1855).\r\n- Auxiliary files include `docs/partialsig_forgery.md` (which I can move to a gist if preferred) and a test vector generation script (~1400 lines). I can exclude these if necessary.",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3707273822",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "labeled",
      "id": 21865706760,
      "node_id": "LE_lADOAN28mc7hNLslzwAAAAUXTDUI",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21865706760",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-06T00:53:23Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "renamed",
      "id": 21865763096,
      "node_id": "RTE_lADOAN28mc7hNLslzwAAAAUXTREY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21865763096",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-06T00:57:43Z",
      "rename": {
        "from": "Add BIP: FROST Signing for BIP340-compatible Threshold Signatures",
        "to": "BIP Draft: FROST Signing Protocol for BIP340 Schnorr Signatures"
      }
    },
    {
      "event": "reviewed",
      "id": 3628910689,
      "node_id": "PRR_kwDOAN28mc7YTMhh",
      "url": null,
      "actor": null,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-06T01:14:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "This is just a first glance, but I noticed a few issues:",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3628910689",
      "submitted_at": "2026-01-06T01:14:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGVjNDZhMjAzMjM4NDBiMWE2YWJhODNiYzJkMThiMzRkZDA4MTEyNDU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "tree": {
        "sha": "b1ea7779a989a513e6b0970819876347ebcd5837",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/b1ea7779a989a513e6b0970819876347ebcd5837"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b1ea7779a989a513e6b0970819876347ebcd5837\nparent b7e42f93b5651055a4e9a1202e70b1b43246d4d1\nauthor siv2r <siv2ram@gmail.com> 1767856279 +0530\ncommitter siv2r <siv2ram@gmail.com> 1767856279 +0530\n\nbip-frost-signing: fix typos, preamble, and title\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRv2EYOHAumKdeBnCb+DYEu6GLj3QUCaV9YrgAKCRD+DYEu6GLj\n3QoeAP46owzcKSDC4TAVZawzxmXELo0oPZ3jw4pmJUh5SWFdJgEAtcoIzVJj56Js\nvF38xVueZE6w2CsBYpr94EqbJ8ou/AE=\n=lib2\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
          "sha": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
          "html_url": "https://github.com/bitcoin/bips/commit/b7e42f93b5651055a4e9a1202e70b1b43246d4d1"
        }
      ],
      "message": "bip-frost-signing: fix typos, preamble, and title",
      "committer": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-08T07:11:19Z"
      },
      "author": {
        "name": "siv2r",
        "email": "siv2ram@gmail.com",
        "date": "2026-01-08T07:11:19Z"
      },
      "sha": "ec46a20323840b1a6aba83bc2d18b34dd0811245"
    },
    {
      "event": "renamed",
      "id": 21931755755,
      "node_id": "RTE_lADOAN28mc7hNLslzwAAAAUbPAjr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21931755755",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-08T20:12:02Z",
      "rename": {
        "from": "BIP Draft: FROST Signing Protocol for BIP340 Schnorr Signatures",
        "to": "BIP Draft: FROST Signing Protocol for BIP340 Signatures"
      }
    },
    {
      "event": "reviewed",
      "id": 3641092452,
      "node_id": "PRR_kwDOAN28mc7ZBqlk",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-08T20:17:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the quick turn-around. Itâ€™s on my todo list to give this a more thorough look, but it might take a bit. If you can motivate some other reviewers meanwhile, that would also be welcome.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3641092452",
      "submitted_at": "2026-01-08T20:17:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "commented",
      "id": 3728923010,
      "node_id": "IC_kwDOAN28mc7eQtmC",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3728923010",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-09T13:30:19Z",
      "updated_at": "2026-01-09T13:30:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "> If you can motivate some other reviewers meanwhile, that would also be welcome.\r\n\r\nI've shared it with most of the Bitcoin cryptographers I know and will post it on Twitter and the Bitcoin dev groups I'm part of. Hopefully that will bring in more reviewers!",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3728923010",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "reviewed",
      "id": 3660028850,
      "node_id": "PRR_kwDOAN28mc7aJ5uy",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-14T13:05:15Z",
      "author_association": "NONE",
      "body": "Hi! Quite a remarkable job! We found a few minor issues, and correcting them would improve the overall specification of the BIP.",
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3660028850",
      "submitted_at": "2026-01-14T13:05:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "reviewed",
      "id": 3675747861,
      "node_id": "PRR_kwDOAN28mc7bF3YV",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-18T20:19:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "As I mentioned on X i'm working on this, so you will likely see more comments in the future. Another nice-to-have would be a table of contents ([example](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki#table-of-contents)) as most other BIPs have this. Perhaps this is a limitation of the `.md` document vs `.mediawiki`. Not sure.",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3675747861",
      "submitted_at": "2026-01-18T20:19:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "reviewed",
      "id": 3679618675,
      "node_id": "PRR_kwDOAN28mc7bUoZz",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-19T21:07:06Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3679618675",
      "submitted_at": "2026-01-19T21:07:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    },
    {
      "event": "commented",
      "id": 3776054292,
      "node_id": "IC_kwDOAN28mc7hEgQU",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3776054292",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-21T04:13:19Z",
      "updated_at": "2026-01-21T04:13:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Another nice-to-have would be a table of contents ([example](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki#table-of-contents)) as most other BIPs have this. Perhaps this is a limitation of the `.md` document vs `.mediawiki`. Not sure.\r\n\r\nYes, it's a `.md` issue, this bip initially had a manually written table of contents but was removed after https://github.com/bitcoin/bips/pull/2070#discussion_r2663226155",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3776054292",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "commented",
      "id": 3779764190,
      "node_id": "IC_kwDOAN28mc7hSp_e",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3779764190",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-21T17:08:13Z",
      "updated_at": "2026-01-21T17:08:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "> As I mentioned on X i'm working on this, so you will likely see more comments in the future. Another nice-to-have would be a table of contents ([example](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki#table-of-contents)) as most other BIPs have this. Perhaps this is a limitation of the `.md` document vs `.mediawiki`. Not sure.\r\n\r\nClick there. ;)\r\n\r\n<img width=\"1116\" height=\"620\" alt=\"image\" src=\"https://github.com/user-attachments/assets/60befb5c-55a9-4a64-987c-140e944ab88c\" />\r\n",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3779764190",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "commented",
      "id": 3780661049,
      "node_id": "IC_kwDOAN28mc7hWE85",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3780661049",
      "actor": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-21T19:02:15Z",
      "updated_at": "2026-01-21T19:02:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "> > As I mentioned on X i'm working on this, so you will likely see more comments in the future. Another nice-to-have would be a table of contents ([example](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki#table-of-contents)) as most other BIPs have this. Perhaps this is a limitation of the `.md` document vs `.mediawiki`. Not sure.\r\n> \r\n> Click there. ;)\r\n\r\nThank you! TIL :-)\r\n\r\n",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#issuecomment-3780661049",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2070"
    },
    {
      "event": "reviewed",
      "id": 3691689081,
      "node_id": "PRR_kwDOAN28mc7cCrR5",
      "url": null,
      "actor": null,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-22T11:20:44Z",
      "author_association": "NONE",
      "body": "A few additional minor issues and questions.",
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2070#pullrequestreview-3691689081",
      "submitted_at": "2026-01-22T11:20:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663220161",
      "pull_request_review_id": 3628910689,
      "id": 2663220161,
      "node_id": "PRRC_kwDOAN28mc6evYPB",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 1,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The â€œyamlâ€ here is superfluous and will likely break CI checks.",
      "created_at": "2026-01-06T00:58:33Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663220161",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663220161"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663226155",
      "pull_request_review_id": 3628910689,
      "id": 2663226155,
      "node_id": "PRRC_kwDOAN28mc6evZsr",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational\n+Created:\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Comments-URI:\n+```\n+\n+- [Abstract](#abstract)\n+- [Copyright](#copyright)\n+- [Motivation](#motivation)\n+- [Overview](#overview)\n+  - [Optionality of Features](#optionality-of-features)\n+  - [Key Material and Setup](#key-material-and-setup)\n+    - [Protocol Parties and Network Setup](#protocol-parties-and-network-setup)\n+    - [Signing Inputs and Outputs](#signing-inputs-and-outputs)\n+  - [General Signing Flow](#general-signing-flow)\n+  - [Nonce Generation](#nonce-generation)\n+  - [Identifying Disruptive Signers](#identifying-disruptive-signers)\n+    - [Further Remarks](#further-remarks)\n+  - [Tweaking the Threshold Public Key](#tweaking-the-threshold-public-key)\n+- [Algorithms](#algorithms)\n+  - [Notation](#notation)\n+    - [Cryptographic Types and Operations](#cryptographic-types-and-operations)\n+    - [Auxiliary and Byte-string Operations](#auxiliary-and-byte-string-operations)\n+  - [Key Material and Setup](#key-material-and-setup-1)\n+    - [Signers Context](#signers-context)\n+  - [Tweaking the Threshold Public Key](#tweaking-the-threshold-public-key-1)\n+    - [Tweak Context](#tweak-context)\n+    - [Applying Tweaks](#applying-tweaks)\n+  - [Nonce Generation](#nonce-generation-1)\n+  - [Nonce Aggregation](#nonce-aggregation)\n+  - [Session Context](#session-context)\n+  - [Signing](#signing)\n+  - [Partial Signature Verification](#partial-signature-verification)\n+  - [Partial Signature Aggregation](#partial-signature-aggregation)\n+  - [Test Vectors \\& Reference Code](#test-vectors--reference-code)\n+- [Remarks on Security and Correctness](#remarks-on-security-and-correctness)\n+  - [Modifications to Nonce Generation](#modifications-to-nonce-generation)\n+    - [Deterministic and Stateless Signing for a Single Signer](#deterministic-and-stateless-signing-for-a-single-signer)\n+  - [Tweaking Definition](#tweaking-definition)\n+  - [Negation of the Secret Share when Signing](#negation-of-the-secret-share-when-signing)\n+    - [Negation of the Pubshare when Partially Verifying](#negation-of-the-pubshare-when-partially-verifying)\n+  - [Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation)\n+- [Backwards Compatibility](#backwards-compatibility)\n+- [Changelog](#changelog)\n+- [Acknowledgments](#acknowledgments)",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 52,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks, but it is not necessary to manually include a table of contents. Mediawiki files are automatically rendered with one on GitHub, and you can find one for markdown files here:\r\n<img width=\"812\" height=\"566\" alt=\"image\" src=\"https://github.com/user-attachments/assets/48e1e21b-83f3-4ac0-a3a0-700b57741271\" />\r\n",
      "created_at": "2026-01-06T01:01:53Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663226155",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663226155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663227754",
      "pull_request_review_id": 3628910689,
      "id": 2663227754,
      "node_id": "PRRC_kwDOAN28mc6evaFq",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 8,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This should be labeled as a Standards Track BIP",
      "created_at": "2026-01-06T01:02:41Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663227754",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663227754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663234008",
      "pull_request_review_id": 3628910689,
      "id": 2663234008,
      "node_id": "PRRC_kwDOAN28mc6evbnY",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 3,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Title exceeds 44 characters",
      "created_at": "2026-01-06T01:07:03Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663234008",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663234008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663239079",
      "pull_request_review_id": 3628910689,
      "id": 2663239079,
      "node_id": "PRRC_kwDOAN28mc6evc2n",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational\n+Created:\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Comments-URI:",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 11,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The headers here are a bit out of order. They must be in a specific order (see https://bips.xyz/2#bip-header-preamble), and CI checks will fail if they arenâ€™t.\r\n\r\nThe order should be:\r\n\r\n```suggestion\r\nComments-URI:\r\nStatus: Draft\r\nType: Informational\r\nCreated:\r\nLicense: CC0-1.0\r\nLicense-Code: MIT\r\nPost-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\r\n```",
      "created_at": "2026-01-06T01:10:57Z",
      "updated_at": "2026-01-06T01:14:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663239079",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663239079"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 5,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663953656",
      "pull_request_review_id": 3629782051,
      "id": 2663953656,
      "node_id": "PRRC_kwDOAN28mc6eyLT4",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 3,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663234008,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "suggestion: \"FROST Signing Protocol for BIP340 Signatures\" (exactly 44 characters)",
      "created_at": "2026-01-06T07:37:48Z",
      "updated_at": "2026-01-06T07:37:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2663953656",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2663953656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671151161",
      "pull_request_review_id": 3638053436,
      "id": 2671151161,
      "node_id": "PRRC_kwDOAN28mc6fNog5",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 1,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663220161,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I added it because the syntax highlighting looked nice. Removed it.",
      "created_at": "2026-01-08T07:13:24Z",
      "updated_at": "2026-01-08T07:13:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671151161",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671151161"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671152130",
      "pull_request_review_id": 3638054775,
      "id": 2671152130,
      "node_id": "PRRC_kwDOAN28mc6fNowC",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational\n+Created:\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Comments-URI:\n+```\n+\n+- [Abstract](#abstract)\n+- [Copyright](#copyright)\n+- [Motivation](#motivation)\n+- [Overview](#overview)\n+  - [Optionality of Features](#optionality-of-features)\n+  - [Key Material and Setup](#key-material-and-setup)\n+    - [Protocol Parties and Network Setup](#protocol-parties-and-network-setup)\n+    - [Signing Inputs and Outputs](#signing-inputs-and-outputs)\n+  - [General Signing Flow](#general-signing-flow)\n+  - [Nonce Generation](#nonce-generation)\n+  - [Identifying Disruptive Signers](#identifying-disruptive-signers)\n+    - [Further Remarks](#further-remarks)\n+  - [Tweaking the Threshold Public Key](#tweaking-the-threshold-public-key)\n+- [Algorithms](#algorithms)\n+  - [Notation](#notation)\n+    - [Cryptographic Types and Operations](#cryptographic-types-and-operations)\n+    - [Auxiliary and Byte-string Operations](#auxiliary-and-byte-string-operations)\n+  - [Key Material and Setup](#key-material-and-setup-1)\n+    - [Signers Context](#signers-context)\n+  - [Tweaking the Threshold Public Key](#tweaking-the-threshold-public-key-1)\n+    - [Tweak Context](#tweak-context)\n+    - [Applying Tweaks](#applying-tweaks)\n+  - [Nonce Generation](#nonce-generation-1)\n+  - [Nonce Aggregation](#nonce-aggregation)\n+  - [Session Context](#session-context)\n+  - [Signing](#signing)\n+  - [Partial Signature Verification](#partial-signature-verification)\n+  - [Partial Signature Aggregation](#partial-signature-aggregation)\n+  - [Test Vectors \\& Reference Code](#test-vectors--reference-code)\n+- [Remarks on Security and Correctness](#remarks-on-security-and-correctness)\n+  - [Modifications to Nonce Generation](#modifications-to-nonce-generation)\n+    - [Deterministic and Stateless Signing for a Single Signer](#deterministic-and-stateless-signing-for-a-single-signer)\n+  - [Tweaking Definition](#tweaking-definition)\n+  - [Negation of the Secret Share when Signing](#negation-of-the-secret-share-when-signing)\n+    - [Negation of the Pubshare when Partially Verifying](#negation-of-the-pubshare-when-partially-verifying)\n+  - [Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation)\n+- [Backwards Compatibility](#backwards-compatibility)\n+- [Changelog](#changelog)\n+- [Acknowledgments](#acknowledgments)",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 52,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663226155,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah, I was not aware of this. Thanks!",
      "created_at": "2026-01-08T07:13:49Z",
      "updated_at": "2026-01-08T07:13:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671152130",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671152130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671152564",
      "pull_request_review_id": 3638055293,
      "id": 2671152564,
      "node_id": "PRRC_kwDOAN28mc6fNo20",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational\n+Created:\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Comments-URI:",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 11,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663239079,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Rearragned",
      "created_at": "2026-01-08T07:14:02Z",
      "updated_at": "2026-01-08T07:14:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671152564",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671152564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": 5,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671153815",
      "pull_request_review_id": 3638056831,
      "id": 2671153815,
      "node_id": "PRRC_kwDOAN28mc6fNpKX",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 3,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663234008,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I like the suggestion. Updated the title.",
      "created_at": "2026-01-08T07:14:34Z",
      "updated_at": "2026-01-08T07:14:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671153815",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671153815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671154143",
      "pull_request_review_id": 3638057205,
      "id": 2671154143,
      "node_id": "PRRC_kwDOAN28mc6fNpPf",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Status: Draft\n+License: CC0-1.0\n+License-Code: MIT\n+Type: Informational",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 8,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663227754,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed",
      "created_at": "2026-01-08T07:14:44Z",
      "updated_at": "2026-01-08T07:14:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2671154143",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2671154143"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2673736993",
      "pull_request_review_id": 3641081865,
      "id": 2673736993,
      "node_id": "PRRC_kwDOAN28mc6fXf0h",
      "diff_hunk": "@@ -0,0 +1,862 @@\n+```yaml\n+BIP:\n+Title: FROST Signing Protocol for BIP340 Schnorr Signatures",
      "path": "bip-frost-signing.md",
      "position": 1,
      "original_position": 3,
      "commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "original_commit_id": "b7e42f93b5651055a4e9a1202e70b1b43246d4d1",
      "in_reply_to_id": 2663234008,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I also adopted it for the title of this PR. :)",
      "created_at": "2026-01-08T20:12:18Z",
      "updated_at": "2026-01-08T20:12:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2673736993",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2673736993"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2673745481",
      "pull_request_review_id": 3641092452,
      "id": 2673745481,
      "node_id": "PRRC_kwDOAN28mc6fXh5J",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?",
      "path": "bip-frost-signing.md",
      "position": 8,
      "original_position": 8,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "As currently BIPâ€¯2 still regulates the BIPâ€¯Process, this should still be Created. (Looking forward to BIPâ€¯3 activating any year now. ;))\r\n\r\n```suggestion\r\nCreated: ?\r\n```",
      "created_at": "2026-01-08T20:14:54Z",
      "updated_at": "2026-01-08T20:17:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2673745481",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2673745481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 8,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2676196310",
      "pull_request_review_id": 3643933132,
      "id": 2676196310,
      "node_id": "PRRC_kwDOAN28mc6fg4PW",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?",
      "path": "bip-frost-signing.md",
      "position": 8,
      "original_position": 8,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2673745481,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Okay, I'll revert it back.",
      "created_at": "2026-01-09T13:27:07Z",
      "updated_at": "2026-01-09T13:27:07Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2676196310",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2676196310"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 8,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689891911",
      "pull_request_review_id": 3660028850,
      "id": 2689891911,
      "node_id": "PRRC_kwDOAN28mc6gVH5H",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation",
      "path": "bip-frost-signing.md",
      "position": 23,
      "original_position": 23,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The first sections of the BIP use `code-style` formatting for variables, which\r\nis convenient in Markdown and improves readability. However, the following sections,\r\nstarting with **General Signing Flow**, do not follow this convention, resulting in an\r\ninconsistent style. \r\nWe suggest adopting a single formatting style throughout the document.",
      "created_at": "2026-01-14T10:36:52Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689891911",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689891911"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 23,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689921315",
      "pull_request_review_id": 3660028850,
      "id": 2689921315,
      "node_id": "PRRC_kwDOAN28mc6gVPEj",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.",
      "path": "bip-frost-signing.md",
      "position": 99,
      "original_position": 99,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The first two paragraphs of the **General Signing Flow** section are repetitive. We suggest keeping the second paragraph, as it is easier to follow.",
      "created_at": "2026-01-14T10:42:38Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689921315",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689921315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 99,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689930973",
      "pull_request_review_id": 3660028850,
      "id": 2689930973,
      "node_id": "PRRC_kwDOAN28mc6gVRbd",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |",
      "path": "bip-frost-signing.md",
      "position": 261,
      "original_position": 261,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It is better to reorder the table to place the scalar `to_bytes` functions before the\r\n`from_bytes` functions, in order to be consistent with the order of the point transformation\r\nfunctions.",
      "created_at": "2026-01-14T10:44:46Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689930973",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689930973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 261,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689949680",
      "pull_request_review_id": 3660028850,
      "id": 2689949680,
      "node_id": "PRRC_kwDOAN28mc6gVV_w",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*",
      "path": "bip-frost-signing.md",
      "position": 289,
      "original_position": 289,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This note duplicates the footnote 8 and used twice in the text. We think, it would be simpler to just add modulo _n =_ `order` wherever scalar arithmetic is used.",
      "created_at": "2026-01-14T10:50:08Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689949680",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689949680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 289,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689983627",
      "pull_request_review_id": 3660028850,
      "id": 2689983627,
      "node_id": "PRRC_kwDOAN28mc6gVeSL",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*",
      "path": "bip-frost-signing.md",
      "position": 449,
      "original_position": 449,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The multiplication operator `*` is not displayed in the compiled version when calculating `pubnonce` array indices.",
      "created_at": "2026-01-14T11:02:01Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2689983627",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2689983627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 449,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690021238",
      "pull_request_review_id": 3660028850,
      "id": 2690021238,
      "node_id": "PRRC_kwDOAN28mc6gVnd2",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*",
      "path": "bip-frost-signing.md",
      "position": 509,
      "original_position": 509,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The computed value P is only used in the subsequent line. It may be clearer to just write _pubshare = cbytes(dâ€²Â·G)_, similar to the `DeterministicSign` algorithm.",
      "created_at": "2026-01-14T11:14:50Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690021238",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690021238"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 509,
      "original_line": 509,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690026960",
      "pull_request_review_id": 3660028850,
      "id": 2690026960,
      "node_id": "PRRC_kwDOAN28mc6gVo3Q",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*\n+- LetÂ *pubshare = cbytes(P)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d'*Â (SeeÂ [*Negation of Secret Share When Signing*](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:",
      "path": "bip-frost-signing.md",
      "position": 526,
      "original_position": 526,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Missing the `v` argument, which is listed as an input parameter below.",
      "created_at": "2026-01-14T11:16:58Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690026960",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690026960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 526,
      "original_line": 526,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690035306",
      "pull_request_review_id": 3660028850,
      "id": 2690035306,
      "node_id": "PRRC_kwDOAN28mc6gVq5q",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*\n+- LetÂ *pubshare = cbytes(P)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d'*Â (SeeÂ [*Negation of Secret Share When Signing*](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:\n+\n+- Inputs:\n+  - The partial signatureÂ *psig*: a 32-byte array, serialized scalar\n+  - The list public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte arrays, each an output of *NonceGen*\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+  - The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+  - The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+  - The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+  - The messageÂ *m*: a byte array[^max-msg-len]\n+  - The index *i* of the signer in the list of public nonces where *0 < i â‰¤ u*\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*",
      "path": "bip-frost-signing.md",
      "position": 537,
      "original_position": 537,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`thresh_pk` is never used and should be replaced with a wildcard.",
      "created_at": "2026-01-14T11:19:50Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690035306",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690035306"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 537,
      "original_line": 537,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690050015",
      "pull_request_review_id": 3660028850,
      "id": 2690050015,
      "node_id": "PRRC_kwDOAN28mc6gVuff",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*\n+- LetÂ *pubshare = cbytes(P)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d'*Â (SeeÂ [*Negation of Secret Share When Signing*](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:\n+\n+- Inputs:\n+  - The partial signatureÂ *psig*: a 32-byte array, serialized scalar\n+  - The list public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte arrays, each an output of *NonceGen*\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+  - The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+  - The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+  - The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+  - The messageÂ *m*: a byte array[^max-msg-len]\n+  - The index *i* of the signer in the list of public nonces where *0 < i â‰¤ u*\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *aggnonce = NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*; fail if that fails\n+- Let *session_ctx = (signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)*\n+- RunÂ *PartialSigVerifyInternal(psig, id<sub>i</sub>, pubnonce<sub>i</sub>, pubshare<sub>i</sub>, session_ctx)*\n+- Return success iff no failure occurred before reaching this point.\n+\n+Internal Algorithm *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*:\n+\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *s = scalar_from_bytes_nonzero_checked(psig)*; fail if that fails\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *R<sub>\\*,1</sub>Â = cpoint(pubnonce[0:33]), R<sub>\\*,2</sub>Â = cpoint(pubnonce[33:66])*\n+- LetÂ *Re<sub>\\*</sub>' = R<sub>\\*,1</sub>Â + b &middot; R<sub>\\*,2</sub>*\n+- Let effective nonceÂ *Re<sub>\\*</sub>Â = Re<sub>\\*</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *Re<sub>\\*</sub>Â = -Re<sub>\\*</sub>'*\n+- LetÂ *P = cpoint(pubshare)*; fail if that fails\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*[^lambda-cant-fail]\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *g' = g &middot; gacc*Â (SeeÂ [*Negation of Pubshare When Partially Verifying*](#negation-of-the-pubshare-when-partially-verifying))\n+- Fail ifÂ *s &middot; G â‰  Re<sub>\\*</sub>Â + e &middot; &lambda; &middot; g' &middot; P*\n+- Return success iff no failure occurred before reaching this point.\n+\n+[^lambda-cant-fail]: *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)* cannot fail when called from *PartialSigVerifyInternal* as *PartialSigVerify* picks *my_id* from *id<sub>1..u</sub>*\n+\n+### Partial Signature Aggregation\n+\n+Algorithm *PartialSigAgg(psig<sub>1..u</sub>, id<sub>1..u</sub>, session_ctx)*:\n+\n+- Inputs:\n+  - The numberÂ *u*Â of signatures withÂ *t â‰¤ u â‰¤ n*\n+  - The list of partial signaturesÂ *psig<sub>1..u</sub>*:Â *u*Â 32-byte arrays, each an output of *Sign*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, _, tacc, _, _, _, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- ForÂ *i = 1 .. u*:\n+  - Let *s<sub>i</sub> = scalar_from_bytes_nonzero_checked(psig<sub>i</sub>)*; fail if that fails and blame signer *id<sub>i</sub>* for invalid partial signature.\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *s = s<sub>1</sub>Â + ... + s<sub>u</sub>Â + e &middot; g &middot; tacc*\n+- ReturnÂ *sig =Â xbytes(R) || scalar_to_bytes(s)*\n+\n+### Test Vectors & Reference Code",
      "path": "bip-frost-signing.md",
      "position": 577,
      "original_position": 577,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Links to the code and test vectors do not work.",
      "created_at": "2026-01-14T11:24:47Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690050015",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690050015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 577,
      "original_line": 577,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690063885",
      "pull_request_review_id": 3660028850,
      "id": 2690063885,
      "node_id": "PRRC_kwDOAN28mc6gVx4N",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.\n+\n+[^max-msg-len]: In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).\n+\n+### Nonce Aggregation\n+\n+Algorithm *NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*:\n+\n+- Inputs:\n+  - The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+  - The list of participant public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte array, each an output of *NonceGen*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* integers, each with 0 â‰¤ *id<sub>i</sub>* < *n*\n+- ForÂ *j = 1 .. 2*:\n+  - ForÂ *i = 1 .. u*:\n+    - LetÂ *R<sub>i,j</sub>Â = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])*; fail if that fails and blame signerÂ *id<sub>i</sub>*Â for invalidÂ *pubnonce*\n+  - LetÂ *R<sub>j</sub>Â = R<sub>1,j</sub>Â + R<sub>2,j</sub>Â + ... + R<sub>u,j</sub>*\n+- ReturnÂ *aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)*\n+\n+### Session Context\n+\n+The Session Context is a data structure consisting of the following elements:\n+\n+- The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- The aggregate public nonce *aggnonce*: a 66-byte array, output of *NonceAgg*\n+- The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+- The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+- The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+- The messageÂ *m*: a byte array[^max-msg-len]\n+\n+We write \"Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\" to assign names to the elements of a Session Context.\n+\n+Algorithm *GetSessionValues(session_ctx)*:\n+\n+- Let *(signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx*\n+- *ValidateSignersCtx(signers_ctx)*; fail if that fails\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx<sub>v</sub>*\n+- Let *ser_ids* = *SerializeIds(id<sub>1..u</sub>)*\n+- LetÂ *b* = *scalar_from_bytes_wrapping(hash<sub>FROST/noncecoef</sub>(ser_ids || aggnonce || xbytes(Q) || m))*\n+- Fail if *b = Scalar(0)*\n+- LetÂ *R<sub>1</sub>Â = cpoint_ext(aggnonce[0:33]), R<sub>2</sub>Â = cpoint_ext(aggnonce[33:66])*; fail if that fails and blame the coordinator for invalidÂ *aggnonce*.\n+- LetÂ *R' = R<sub>1</sub>Â + b &middot; R<sub>2</sub>*\n+- IfÂ *is_infinity(R'):*\n+  - Let final nonceÂ *R = G*Â ([see Dealing with Infinity in Nonce Aggregation](#dealing-with-infinity-in-nonce-aggregation))\n+- Else:\n+  - Let final nonceÂ *R = R'*\n+- LetÂ *e = scalar_from_bytes_wrapping(hash<sub>BIP0340/challenge</sub>((xbytes(R) || xbytes(Q) || m)))*\n+- Fail if *e = Scalar(0)*\n+- ReturnÂ (Q, gacc, tacc, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e)\n+\n+Internal Algorithm *SerializeIds(id<sub>1..u</sub>)*:\n+\n+- *res = empty_bytestring*\n+- For *id* in *sorted(id<sub>1..u</sub>)*:\n+  - *res = res || bytes(4, id)*\n+- Return *res*\n+\n+### Signing\n+\n+Algorithm *Sign(secnonce, secshare, my_id, session_ctx)*:\n+\n+- Inputs:\n+  - The secret nonceÂ *secnonce*Â that has never been used as input toÂ *Sign*Â before: a 64-byte array[^secnonce-ser]\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *k<sub>1</sub>' = scalar_from_bytes_nonzero_checked(secnonce[0:32])*; fail if that fails\n+- Let *k<sub>2</sub>' = scalar_from_bytes_nonzero_checked(secnonce[32:64])*; fail if that fails\n+- LetÂ *k<sub>1</sub>Â = k<sub>1</sub>', k<sub>2</sub>Â = k<sub>2</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *k<sub>1</sub>Â = -k<sub>1</sub>', k<sub>2</sub>Â = -k<sub>2</sub>'*\n+- Let *d' = scalar_from_bytes_nonzero_checked(secshare)*; fail if that fails\n+- LetÂ *P = d' &middot; G*\n+- LetÂ *pubshare = cbytes(P)*\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*; fail if that fails\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *d = g &middot; gacc &middot; d'*Â (SeeÂ [*Negation of Secret Share When Signing*](#negation-of-the-secret-share-when-signing))\n+- LetÂ *s = k<sub>1</sub>Â + b &middot; k<sub>2</sub>Â + e &middot; &lambda; &middot; d*\n+- LetÂ *psig = scalar_to_bytes(s)*\n+- LetÂ *pubnonce = cbytes(k<sub>1</sub>' &middot; G) || cbytes(k<sub>2</sub>' &middot; G)*\n+- IfÂ *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*Â (see below) returns failure, fail[^why-verify-partialsig]\n+- Return partial signatureÂ *psig*\n+\n+[^why-verify-partialsig]: Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret share. It is recommended but can be omitted if the computation cost is prohibitive.\n+\n+### Partial Signature Verification\n+\n+Algorithm *PartialSigVerify(psig, pubnonce<sub>1..u</sub>, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)*:\n+\n+- Inputs:\n+  - The partial signatureÂ *psig*: a 32-byte array, serialized scalar\n+  - The list public noncesÂ *pubnonce<sub>1..u</sub>*:Â *u*Â 66-byte arrays, each an output of *NonceGen*\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+  - The numberÂ *v*Â of tweaks withÂ *0 â‰¤ v < 2^32*\n+  - The list of tweaksÂ *tweak<sub>1..v</sub>*:Â *v*Â 32-byte arrays, each a serialized scalar\n+  - The list of tweak modesÂ *is_xonly_t<sub>1..v</sub>*Â :Â *v*Â booleans\n+  - The messageÂ *m*: a byte array[^max-msg-len]\n+  - The index *i* of the signer in the list of public nonces where *0 < i â‰¤ u*\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *aggnonce = NonceAgg(pubnonce<sub>1..u</sub>, id<sub>1..u</sub>)*; fail if that fails\n+- Let *session_ctx = (signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)*\n+- RunÂ *PartialSigVerifyInternal(psig, id<sub>i</sub>, pubnonce<sub>i</sub>, pubshare<sub>i</sub>, session_ctx)*\n+- Return success iff no failure occurred before reaching this point.\n+\n+Internal Algorithm *PartialSigVerifyInternal(psig, my_id, pubnonce, pubshare, session_ctx)*:\n+\n+- LetÂ *(Q, gacc, _, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, b, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- Let *s = scalar_from_bytes_nonzero_checked(psig)*; fail if that fails\n+- Fail if *pubshare* not in *pubshare<sub>1..u</sub>*\n+- Fail if *my_id* not in *id<sub>1..u</sub>*\n+- LetÂ *R<sub>\\*,1</sub>Â = cpoint(pubnonce[0:33]), R<sub>\\*,2</sub>Â = cpoint(pubnonce[33:66])*\n+- LetÂ *Re<sub>\\*</sub>' = R<sub>\\*,1</sub>Â + b &middot; R<sub>\\*,2</sub>*\n+- Let effective nonceÂ *Re<sub>\\*</sub>Â = Re<sub>\\*</sub>'*Â ifÂ *has_even_y(R)*, otherwise letÂ *Re<sub>\\*</sub>Â = -Re<sub>\\*</sub>'*\n+- LetÂ *P = cpoint(pubshare)*; fail if that fails\n+- LetÂ *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)*[^lambda-cant-fail]\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *g' = g &middot; gacc*Â (SeeÂ [*Negation of Pubshare When Partially Verifying*](#negation-of-the-pubshare-when-partially-verifying))\n+- Fail ifÂ *s &middot; G â‰  Re<sub>\\*</sub>Â + e &middot; &lambda; &middot; g' &middot; P*\n+- Return success iff no failure occurred before reaching this point.\n+\n+[^lambda-cant-fail]: *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id)* cannot fail when called from *PartialSigVerifyInternal* as *PartialSigVerify* picks *my_id* from *id<sub>1..u</sub>*\n+\n+### Partial Signature Aggregation\n+\n+Algorithm *PartialSigAgg(psig<sub>1..u</sub>, id<sub>1..u</sub>, session_ctx)*:\n+\n+- Inputs:\n+  - The numberÂ *u*Â of signatures withÂ *t â‰¤ u â‰¤ n*\n+  - The list of partial signaturesÂ *psig<sub>1..u</sub>*:Â *u*Â 32-byte arrays, each an output of *Sign*\n+  - The list of participant identifiersÂ *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n-1*\n+  - TheÂ *session_ctx*: aÂ [Session Context](#session-context) data structure\n+- LetÂ *(Q, _, tacc, _, _, _, R, e) = GetSessionValues(session_ctx)*; fail if that fails\n+- ForÂ *i = 1 .. u*:\n+  - Let *s<sub>i</sub> = scalar_from_bytes_nonzero_checked(psig<sub>i</sub>)*; fail if that fails and blame signer *id<sub>i</sub>* for invalid partial signature.\n+- LetÂ *g = Scalar(1)*Â ifÂ *has_even_y(Q)*, otherwise letÂ *g = Scalar(-1)*\n+- LetÂ *s = s<sub>1</sub>Â + ... + s<sub>u</sub>Â + e &middot; g &middot; tacc*\n+- ReturnÂ *sig =Â xbytes(R) || scalar_to_bytes(s)*\n+\n+### Test Vectors & Reference Code\n+\n+We provide a naive, highly inefficient, and non-constant timeÂ [pure Python 3 reference implementation of the threshold public key tweaking, nonce generation, partial signing, and partial signature verification algorithms](./reference/reference.py).\n+\n+Standalone JSON test vectors are also available in theÂ [same directory](./reference/vectors/), to facilitate porting the test vectors into other implementations.\n+\n+> [!CAUTION]\n+> The reference implementation is for demonstration purposes only and not to be used in production environments.\n+\n+## Remarks on Security and Correctness\n+\n+### Modifications to Nonce Generation\n+\n+Implementers must avoid modifying the *NonceGen* algorithm without being fully aware of the implications.\n+We provide two modifications to *NonceGen* that are secure when applied correctly and may be useful in special circumstances, summarized in the following table.\n+\n+| | needs secure randomness | needs secure counter | needs to keep state securely | needs aggregate nonce of all other signers (only possible for one signer) |\n+| --- | --- | --- | --- | --- |\n+| **NonceGen** | âœ“ | | âœ“ | |\n+| **CounterNonceGen** | | âœ“ | âœ“ | |\n+| **DeterministicSign** | | | | âœ“ |\n+\n+First, on systems where obtaining uniformly random values is much harder than maintaining a global atomic counter, it can be beneficial to modify *NonceGen*.\n+The resulting algorithm *CounterNonceGen* does not draw *rand'* uniformly at random but instead sets *rand'* to the value of an atomic counter that is incremented whenever it is read.\n+With this modification, the secret share *secshare* of the signer generating the nonce is **not** an optional argument and must be provided to *NonceGen*.\n+The security of the resulting scheme then depends on the requirement that reading the counter must never yield the same counter value in two *NonceGen* invocations with the same *secshare*.\n+\n+Second, if there is a unique signer who generates their nonce last (i.e., after receiving the aggregate nonce from all other signers), it is possible to modify nonce generation for this single signer to not require high-quality randomness.\n+Such a nonce generation algorithm *DeterministicSign* is specified below.\n+Note that the only optional argument is *rand*, which can be omitted if randomness is entirely unavailable.\n+*DeterministicSign* requires the argument *aggothernonce* which should be set to the output of *NonceAgg* run on the *pubnonce* value of **all** other signers (but can be provided by an untrusted party).\n+Hence, using *DeterministicSign* is only possible for the last signer to generate a nonce and makes the signer stateless, similar to the stateless signer described in the [Nonce Generation](#nonce-generation) section.\n+<!-- REVIEW just say n is < 2^32 during intro, than mentioning it everywhere -->\n+\n+#### Deterministic and Stateless Signing for a Single Signer\n+\n+Algorithm *DeterministicSign(secshare, my_id, aggothernonce, signers_ctx, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, rand)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar\n+  - The participant identifier *my_id*: an integer with *0 â‰¤ my_id â‰¤ n-1*\n+  - The aggregate public nonce *aggothernonce* (see [above](#modifications-to-nonce-generation)): a 66-byte array, output of *NonceAgg*\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+  - The number *v* of tweaks with *0 â‰¤ v < 2^32*\n+  - The list of tweaks *tweak<sub>1..v</sub>*: *v* 32-byte arrays, each a serialized scalar\n+  - The list of tweak methods *is_xonly_t<sub>1..v</sub>*: *v* booleans\n+  - The message *m*: a byte array[^max-msg-len]\n+  - The auxiliary randomness *rand*: a 32-byte array, serialized scalar (optional argument)\n+- If the optional argument *rand* is present:\n+  - Let *secshare' = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand))*\n+- Else:\n+  - Let *secshare' = secshare*\n+- Let *(_, _, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Let *tweak_ctx<sub>0</sub> = TweakCtxInit(thresh_pk)*; fail if that fails\n+- ForÂ *i = 1 .. v*:\n+  - LetÂ *tweak_ctx<sub>i</sub>Â = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)*; fail if that fails\n+- Let *tweaked_tpk = GetXonlyPubkey(tweak_ctx<sub>v</sub>)*\n+- Let *k<sub>i</sub> = scalar_from_bytes_wrapping(hash<sub>FROST/deterministic/nonce</sub>(secshare' || aggothernonce || tweaked_tpk || bytes(8, len(m)) || m || bytes(1, i - 1)))* for *i = 1,2*\n+- Fail if *k<sub>1</sub> = Scalar(0)* or *k<sub>2</sub> = Scalar(0)*\n+- Let *R<sub>\\*,1</sub> = k<sub>1</sub> &middot; G, R<sub>\\*,2</sub> = k<sub>2</sub> &middot; G*\n+- Let *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- Let *d = scalar_from_bytes_nonzero_checked(secshare')*; fail if that fails\n+- Let *my_pubshare = cbytes(d &middot; G)*\n+- Fail if *my_pubshare* is not present in *pubshare<sub>1..u</sub>*\n+- Let *secnonce = scalar_to_bytes(k<sub>1</sub>) || scalar_to_bytes(k<sub>2</sub>)*\n+- Let *aggnonce = NonceAgg((pubnonce, aggothernonce), (my_id, COORDINATOR_ID))*[^coordinator-id-sentinel]; fail if that fails and blame coordinator for invalid *aggothernonce*.\n+- Let *session_ctx = (signers_ctx, aggnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)*\n+- Return (pubnonce, Sign(secnonce, secshare, my_id, session_ctx))\n+\n+[^coordinator-id-sentinel]: *COORDINATOR_ID* is a sentinel value (not an actual participant identifier) used to track the source of *aggothernonce* for error attribution. If *NonceAgg* fails, the coordinator is blamed for providing an invalid *aggothernonce*. In the reference implementation, *COORDINATOR_ID* is represented as `None`.\n+\n+### Tweaking Definition\n+\n+Two modes of tweaking the threshold public key are supported. They correspond to the following algorithms:\n+\n+Algorithm *ApplyPlainTweak(P, t)*:\n+\n+- Inputs:\n+  - *P*: a point\n+  - The tweakÂ *t*: a scalar\n+- ReturnÂ *P + t &middot; G*\n+\n+Algorithm *ApplyXonlyTweak(P, t)*:\n+\n+- Inputs:\n+  - *P*: a point\n+  - The tweakÂ *t*: a scalar\n+- ReturnÂ *with_even_y(P) + t &middot; G*\n+\n+<!-- REVIEW: Should we point to BIP327 for this proof? Unless we use agnostic tweaking -->\n+### Negation of the Secret Share when Signing\n+\n+> [!NOTE]\n+> In the following equations, all scalar arithmetic is understood to be modulo the group order, as specified in the [Notation](#notation) section.\n+\n+During the signing process, the *[Sign](#signing)* algorithm might have to negate the secret share in order to produce a partial signature for an X-only threshold public key, which may be tweaked *v* times (X-only or plain).\n+\n+The following elliptic curve points arise as intermediate steps when creating a signature:\n+\n+- The values *P<sub>i</sub>* (pubshare), *d<sub>i</sub>'* (secret share), and *Q<sub>0</sub>* (threshold public key) are produced by a FROST key generation protocol. We have  \n+  <pre>\n+    P<sub>i</sub> = d<sub>i</sub>'&middot;G\n+    Q<sub>0</sub> = &lambda;<sub>id<sub>1</sub></sub>&middot;P<sub>1</sub>Â + &lambda;<sub>id<sub>2</sub></sub>&middot;P<sub>2</sub>Â + ... + &lambda;<sub>id<sub>u</sub></sub>&middot;P<sub>u</sub>\n+  </pre>  \n+  Here, *&lambda;<sub>id<sub>i</sub></sub>* denotes the interpolating value for the *i*-th signing participant in the [Signers Context](#signers-context).\n+\n+- *Q<sub>i</sub>*Â is the tweaked threshold public key after theÂ *i*-th execution ofÂ *ApplyTweak*Â forÂ *1 â‰¤ i â‰¤ v*. It holds that  \n+  <pre>\n+    Q<sub>i</sub>Â = f(i-1) + t<sub>i</sub>&middot;GÂ forÂ i = 1, ..., vÂ where\n+      f(i-1) := with_even_y(Q<sub>i-1</sub>)Â ifÂ is_xonly_t<sub>i</sub>Â and\n+      f(i-1) := Q<sub>i-1</sub>Â otherwise.\n+  </pre>\n+- *with_even_y(Q*<sub>v</sub>*)*Â is the final result of the threshold public key tweaking operations. It corresponds to the output ofÂ *GetXonlyPubkey*Â applied on the final Tweak Context.\n+\n+The signer's goal is to produce a partial signature corresponding to the final result of threshold pubkey derivation and tweaking, i.e., the X-only public keyÂ *with_even_y(Q<sub>v</sub>)*.\n+\n+For *1 â‰¤ i â‰¤ v*, we denote the value *g* computed in the *i*-th execution of *ApplyTweak* by *g<sub>i-1</sub>*. Therefore, *g<sub>i-1</sub>* equals *Scalar(-1)* if and only if *is_xonly_t<sub>i</sub>* is true and *Q<sub>i-1</sub>* has an odd Y coordinate. In other words, *g<sub>i-1</sub>* indicates whether *Q<sub>i-1</sub>* needed to be negated to apply an X-only tweak:\n+<pre>\n+  f(i-1) = g<sub>i-1</sub>&middot;Q<sub>i-1</sub> for 1 â‰¤ i â‰¤ v\n+</pre>\n+Furthermore, the *Sign* and *PartialSigVerify* algorithms set value *g* depending on whether Q<sub>v</sub> needed to be negated to produce the (X-only) final output. For consistency, this value *g* is referred to as *g<sub>v</sub>* in this section.\n+<pre>\n+  with_even_y(Q<sub>v</sub>) = g<sub>v</sub>&middot;Q<sub>v</sub>\n+</pre>\n+\n+So, the (X-only) final public key is\n+<pre>\n+  with_even_y(Q<sub>v</sub>)\n+    = g<sub>v</sub>&middot;Q<sub>v</sub>\n+    = g<sub>v</sub>&middot;(f(v-1) + t<sub>v</sub>&middot;G)\n+    = g<sub>v</sub>&middot;(g<sub>v-1</sub>&middot;(f(v-2) + t<sub>v-1</sub>&middot;G) + t<sub>v</sub>&middot;G)\n+    = g<sub>v</sub>&middot;g<sub>v-1</sub>&middot;f(v-2) + g<sub>v</sub>&middot;(t<sub>v</sub> + g<sub>v-1</sub>&middot;t<sub>v-1</sub>)&middot;G\n+    = g<sub>v</sub>&middot;g<sub>v-1</sub>&middot;f(v-2) + (sum<sub>i=v-1..v</sub> t<sub>i</sub> &middot; prod<sub>j=i..v</sub> g<sub>j</sub>)&middot;G\n+    = g<sub>v</sub>&middot;g<sub>v-1</sub>&middot; ... &middot;g<sub>1</sub>&middot;f(0) + (sum<sub>i=1..v</sub> t<sub>i</sub> &middot; prod<sub>j=i..v</sub> g<sub>j</sub>)&middot;G\n+    = g<sub>v</sub>&middot; ... &middot;g<sub>0</sub>&middot;Q<sub>0</sub> + g<sub>v</sub>&middot;tacc<sub>v</sub>&middot;G\n+</pre>\n+where tacc<sub>i</sub> is computed by TweakCtxInit and ApplyTweak as follows:\n+<pre>\n+  tacc<sub>0</sub> = 0\n+  tacc<sub>i</sub> = t<sub>i</sub> + g<sub>i-1</sub>&middot;tacc<sub>i-1</sub> for i=1..v\n+</pre>\n+  for which it holds that\n+<pre>\n+  g<sub>v</sub>&middot;tacc<sub>v</sub> = sum<sub>i=1..v</sub> t<sub>i</sub> &middot; prod<sub>j=i..v</sub> g<sub>j</sub>\n+</pre>\n+\n+*TweakCtxInit* and *ApplyTweak* compute\n+<pre>\n+  gacc<sub>0</sub> = 1\n+  gacc<sub>i</sub> = g<sub>i-1</sub> &middot; gacc<sub>i-1</sub> for i=1..v\n+</pre>\n+So we can rewrite above equation for the final public key as\n+<pre>\n+  with_even_y(Q<sub>v</sub>) = g<sub>v</sub> &middot; gacc<sub>v</sub> &middot; Q<sub>0</sub> + g<sub>v</sub> &middot; tacc<sub>v</sub> &middot; G\n+</pre>\n+\n+Then we have\n+<pre>\n+  with_even_y(Q<sub>v</sub>) - g<sub>v</sub>&middot;tacc<sub>v</sub>&middot;G\n+    = g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;Q<sub>0</sub>\n+    = g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;(&lambda;<sub>id<sub>1</sub></sub>&middot;P<sub>1</sub> + ... + &lambda;<sub>id<sub>u</sub></sub>&middot;P<sub>u</sub>)\n+    = g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;(&lambda;<sub>id<sub>1</sub></sub>&middot;d<sub>1</sub>'&middot;G + ... + &lambda;<sub>id<sub>u</sub></sub>&middot;d<sub>u</sub>'&middot;G)\n+    = sum<sub>j=1..u</sub>(g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;&lambda;<sub>id<sub>j</sub></sub>&middot;d<sub>j</sub>')&middot;G\n+</pre>\n+\n+Intuitively, *gacc<sub>i</sub>* tracks accumulated sign flipping and *tacc<sub>i</sub>* tracks the accumulated tweak value after applying the first *i* individual tweaks. Additionally, *g<sub>v</sub>* indicates whether *Q<sub>v</sub>* needed to be negated to produce the final X-only result. Thus, participant *i* multiplies their secret share *d<sub>i</sub>'* with *g<sub>v</sub>&middot;gacc<sub>v</sub>* in the [*Sign*](#signing) algorithm.\n+\n+#### Negation of the Pubshare when Partially Verifying\n+\n+As explained in [Negation Of The Secret Share When Signing](#negation-of-the-secret-share-when-signing) the signer uses a possibly negated secret share\n+<pre>\n+  d = g<sub>v</sub>&middot;gacc<sub>v</sub>&middot;d'\n+</pre>\n+when producing a partial signature to ensure that the aggregate signature will correspond to a threshold public key with even Y coordinate.\n+\n+The [*PartialSigVerifyInternal*](#partial-signature-verification) algorithm is supposed to check\n+<pre>\n+  s&middot;G = Re<sub>*</sub> + e&middot;&lambda;&middot;d&middot;G\n+</pre>\n+\n+The verifier doesn't have access to *d &middot; G* but can construct it using the participant *pubshare* as follows:\n+<pre>\n+d&middot;G\n+  = g<sub>v</sub> &middot; gacc<sub>v</sub> &middot; d' &middot; G\n+  = g<sub>v</sub> &middot; gacc<sub>v</sub> &middot; cpoint(pubshare)\n+</pre>\n+Note that the threshold public key and list of tweaks are inputs to partial signature verification, so the verifier can also construct *g<sub>v</sub>* and *gacc<sub>v</sub>*.\n+\n+### Dealing with Infinity in Nonce Aggregation\n+\n+If the coordinator provides *aggnonce = bytes(33,0) || bytes(33,0)*, either the coordinator is dishonest or there is at least one dishonest signer (except with negligible probability).\n+If signing aborted in this case, it would be impossible to determine who is dishonest.\n+Therefore, signing continues so that the culprit is revealed when collecting and verifying partial signatures.\n+\n+However, the final nonce *R* of a BIP340 Schnorr signature cannot be the point at infinity.\n+If we would nonetheless allow the final nonce to be the point at infinity, then the scheme would lose the following property:\n+if *PartialSigVerify* succeeds for all partial signatures, then *PartialSigAgg* will return a valid Schnorr signature.\n+Since this is a valuable feature, we modify [FROST3 signing][roast] to avoid producing an invalid Schnorr signature while still allowing detection of the dishonest signer: In *GetSessionValues*, if the final nonce *R* would be the point at infinity, set it to the generator instead (an arbitrary choice).",
      "path": "bip-frost-signing.md",
      "position": 774,
      "original_position": 774,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It might be better to also mention ROAST in the **Motivation** section when discussing FROST3.",
      "created_at": "2026-01-14T11:29:26Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690063885",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690063885"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 774,
      "original_line": 774,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690144915",
      "pull_request_review_id": 3660028850,
      "id": 2690144915,
      "node_id": "PRRC_kwDOAN28mc6gWFqT",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).",
      "path": "bip-frost-signing.md",
      "position": 80,
      "original_position": 80,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The _Signers Context_ link is formatted in italics, deviating from the style in the rest of the specification. To maintain a consistent style, italics formatting should be removed from links that do not represent specific functions.\r\nSimilar issues appear in other sections:\r\n**Key Material and Setup**: _Signers Context_ (line:80)\r\n**General Signing Flow**: _Signers Context_, _Tweak Context_ (line:102)\r\n**Signing**: See _Negation of Secret Share When Signing_ (line:515)\r\n**Partial Signature Verification**: See _Negation of Pubshare When Partially Verifying_ (line:555)",
      "created_at": "2026-01-14T11:55:36Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690144915",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690144915"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 80,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690155491",
      "pull_request_review_id": 3660028850,
      "id": 2690155491,
      "node_id": "PRRC_kwDOAN28mc6gWIPj",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.",
      "path": "bip-frost-signing.md",
      "position": 66,
      "original_position": 66,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Minor typo: negates â†’ negate",
      "created_at": "2026-01-14T11:59:26Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690155491",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690155491"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690157273",
      "pull_request_review_id": 3660028850,
      "id": 2690157273,
      "node_id": "PRRC_kwDOAN28mc6gWIrZ",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.",
      "path": "bip-frost-signing.md",
      "position": 63,
      "original_position": 63,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Minor typo: implementations's â†’ implementation's",
      "created_at": "2026-01-14T12:00:10Z",
      "updated_at": "2026-01-14T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2690157273",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2690157273"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2702695740",
      "pull_request_review_id": 3675747861,
      "id": 2702695740,
      "node_id": "PRRC_kwDOAN28mc6hF908",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*",
      "path": "bip-frost-signing.md",
      "position": 426,
      "original_position": 426,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can you explain why `i=1,2`? This is unclear to me. Why not `i=1,2,3,...,n`? I don't understand why we stop at `2`. ",
      "created_at": "2026-01-18T20:18:30Z",
      "updated_at": "2026-01-18T20:19:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2702695740",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2702695740"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 426,
      "original_line": 426,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2702707516",
      "pull_request_review_id": 3675756079,
      "id": 2702707516,
      "node_id": "PRRC_kwDOAN28mc6hGAs8",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*",
      "path": "bip-frost-signing.md",
      "position": 426,
      "original_position": 426,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2702695740,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Nevermind this is because you need a public and secret nonce feel free to resolve ðŸ˜¬ ",
      "created_at": "2026-01-18T20:37:29Z",
      "updated_at": "2026-01-18T20:37:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2702707516",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2702707516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 426,
      "original_line": 426,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2706071004",
      "pull_request_review_id": 3679618675,
      "id": 2706071004,
      "node_id": "PRRC_kwDOAN28mc6hS13c",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:",
      "path": "bip-frost-signing.md",
      "position": 420,
      "original_position": 420,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "How would you suggest handling this case in C? \r\n\r\nWe have a message `m` that equal to the empty bytestring? This is tested in the test vectors accompying this file [here](https://github.com/bitcoin/bips/pull/2070/files#diff-8e1aea52a17a71e665c111d9431eaa41c23f481545f240ae26e1b3675a1611c4R14).\r\n\r\nThe python implmentation allows us to represent 2 different states that are (perhaps?) semantically mean the same thing is my understanding. Here are the 2 cases\r\n\r\n1. `m` is not present (encoded as `00`) with the prefix\r\n2. `m` is present, but its the empty bytestring (encoded as `0100`) with the prefix.\r\n\r\nThis can be represented in the type system of higher level languages like C++, Python, Rust, Scala etc.\r\n\r\nFrom looking at the [API on zkp](https://github.com/BlockstreamResearch/secp256k1-zkp/pull/278/files#diff-80b51497bd08deb468dbfb0c80429ace7109ea19b2e5e58e5aa7060e7517b3d0R302), it seems like this wouldn't be possible to represent?",
      "created_at": "2026-01-19T21:07:06Z",
      "updated_at": "2026-01-19T21:07:06Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2706071004",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2706071004"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 420,
      "original_line": 420,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2706319665",
      "pull_request_review_id": 3679866957,
      "id": 2706319665,
      "node_id": "PRRC_kwDOAN28mc6hTykx",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:",
      "path": "bip-frost-signing.md",
      "position": 420,
      "original_position": 420,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2706071004,
      "user": {
        "login": "vitrixLab",
        "id": 144500546,
        "node_id": "U_kgDOCJznQg",
        "avatar_url": "https://avatars.githubusercontent.com/u/144500546?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vitrixLab",
        "html_url": "https://github.com/vitrixLab",
        "followers_url": "https://api.github.com/users/vitrixLab/followers",
        "following_url": "https://api.github.com/users/vitrixLab/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vitrixLab/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vitrixLab/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vitrixLab/subscriptions",
        "organizations_url": "https://api.github.com/users/vitrixLab/orgs",
        "repos_url": "https://api.github.com/users/vitrixLab/repos",
        "events_url": "https://api.github.com/users/vitrixLab/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vitrixLab/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In **`C`** this must be modeled explicitly as an optional bytes type, otherwise we cannot distinguish\r\nâ€œm not presentâ€ (00) from â€œ`m present but empty`â€ `(0100).`\r\n\r\nI recommend representing this as `{ uint8_t *ptr; size_t len; bool is_present; }` and encoding based on `is_present`.\r\n\r\nCollapsing these cases would break the test vectors and change the hash domain.\r\n\r\n#sc",
      "created_at": "2026-01-19T23:34:01Z",
      "updated_at": "2026-01-19T23:36:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2706319665",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2706319665"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 420,
      "original_line": 420,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2710936061",
      "pull_request_review_id": 3685315607,
      "id": 2710936061,
      "node_id": "PRRC_kwDOAN28mc6hlZn9",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*",
      "path": "bip-frost-signing.md",
      "position": 426,
      "original_position": 426,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2702695740,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "According to the protocol, each signer generates two pairs of nonces, as specified by $\\text{Preround(pk)}$ in [Figure 4 of the paper](https://eprint.iacr.org/2023/899.pdf). These secret nonces are later combined during signing. We could technically generate more than two nonces ([section 2.2 of Musig2 paper](https://eprint.iacr.org/2020/1261.pdf)), but that might be an overkill.",
      "created_at": "2026-01-21T04:37:55Z",
      "updated_at": "2026-01-21T04:37:55Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2710936061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2710936061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 426,
      "original_line": 426,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2711035567",
      "pull_request_review_id": 3685416929,
      "id": 2711035567,
      "node_id": "PRRC_kwDOAN28mc6hlx6v",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:",
      "path": "bip-frost-signing.md",
      "position": 420,
      "original_position": 420,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2706071004,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "We distinguish between a zeroed byte array and an empty byte string. Thus, `m` being absent (*empty_bytestring*) is different from `m` being equal to zero bytes (of any length), and we want to generate distinct nonces for these cases.\r\n\r\nYes, the current the [zkp API doesn't add the message prefix correctly](https://github.com/BlockstreamResearch/secp256k1-zkp/pull/278/changes#r1716621392) which needs to be fixed.\r\n\r\nI agree with @vitrixLab, we can model this in C with an `is_present` variable, [Musig2 does exactly this](https://github.com/bitcoin-core/secp256k1/blob/4721e077b4ac9a9ab80db3fd9a05d6dda207f5c1/src/modules/musig/session_impl.h#L339). \r\n\r\n```\r\nunsigned char msg_present;\r\nmsg_present = msg32 != NULL;\r\nsecp256k1_sha256_write(&sha, &msg_present, 1);\r\nif (msg_present) {\r\n    secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\r\n}\r\n```    ",
      "created_at": "2026-01-21T05:35:42Z",
      "updated_at": "2026-01-21T05:36:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2711035567",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2711035567"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 420,
      "original_line": 420,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2713530350",
      "pull_request_review_id": 3688404503,
      "id": 2713530350,
      "node_id": "PRRC_kwDOAN28mc6hvS_u",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?",
      "path": "bip-frost-signing.md",
      "position": 8,
      "original_position": 8,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2673745481,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sorry, it happened more quickly than I anticipated! :)",
      "created_at": "2026-01-21T17:07:32Z",
      "updated_at": "2026-01-21T17:07:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2713530350",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2713530350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 8,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716245465",
      "pull_request_review_id": 3691689081,
      "id": 2716245465,
      "node_id": "PRRC_kwDOAN28mc6h5p3Z",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*",
      "path": "bip-frost-signing.md",
      "position": 316,
      "original_position": 316,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The same function is also invoked in the `DeriveInterpolatingValue()` algorithm, which is called through the following chain:\r\n    `ValidateSignersCtx()->DeriveThreshPubkey()->DeriveInterpolatingValue()`.\r\nIs there a compelling reason to perform this check at the top level, or could the ID duplication check be retained solely at a lower level within `DeriveInterpolatingValue()`?\r\n\r\nIn addition, the `ValidateSignersCtx()` algorithm checks the condition `t > n`. However, as stated in the description, the valid range is `1 <= t <= n`. Therefore, it would be clearer to replace the condition â€œFail if `t > n`â€ with â€œFail if not `1 <= t <= n`â€.",
      "created_at": "2026-01-22T10:20:35Z",
      "updated_at": "2026-01-22T16:06:28Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2716245465",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716245465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 316,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716254648",
      "pull_request_review_id": 3691689081,
      "id": 2716254648,
      "node_id": "PRRC_kwDOAN28mc6h5sG4",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*\n+- LetÂ *R<sub>\\*,1</sub>Â = k<sub>1</sub> &middot; G*, *R<sub>\\*,2</sub>Â = k<sub>2</sub> &middot; G*\n+- LetÂ *pubnonce = cbytes(R<sub>\\*,1</sub>) || cbytes(R<sub>\\*,2</sub>)*\n+- LetÂ *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*[^secnonce-ser]\n+- ReturnÂ *(secnonce, pubnonce)*\n+\n+[^sk-xor-rand]: The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing share itself. It is xored with the secret share (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret share.\n+\n+[^secnonce-ser]: The algorithms as specified here assume that the *secnonce* is stored as a 64-byte array using the serialization *secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)*. The same format is used in the reference implementation and in the test vectors. However, since the *secnonce* is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the *secnonce* is merely a suggestion. The *secnonce* is effectively a local data structure of the signer which comprises the value triple *(k<sub>1</sub>, k<sub>2</sub>)*, and implementations may choose any suitable method to carry it from *NonceGen* (first communication round) to *Sign* (second communication round). In particular, implementations may choose to hide the *secnonce* in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a *secnonce* accidentally.",
      "path": "bip-frost-signing.md",
      "position": 435,
      "original_position": 435,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "...which comprises the value triple...\r\nMinor typo: triple â†’ pair",
      "created_at": "2026-01-22T10:23:03Z",
      "updated_at": "2026-01-22T11:20:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2716254648",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716254648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 435,
      "original_line": 435,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716310520",
      "pull_request_review_id": 3691689081,
      "id": 2716310520,
      "node_id": "PRRC_kwDOAN28mc6h55v4",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*\n+\n+- Fail ifÂ *my_id*Â not inÂ *id<sub>1..u</sub>*\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Let *num = Scalar(1)*\n+- Let *deno = Scalar(1)*\n+- For *i = 1..u*:\n+  - If *id<sub>i</sub> â‰  my_id*:\n+    - Let *num = num &middot; Scalar(id<sub>i</sub> + 1)*\n+    - Let *deno = deno &middot; Scalar(id<sub>i</sub> - my_id)*\n+- *&lambda; = num &middot; deno<sup>-1</sup>*\n+- Return *&lambda;*\n+\n+### Tweaking the Threshold Public Key\n+\n+#### Tweak Context\n+\n+The Tweak Context is a data structure consisting of the following elements:\n+\n+- The pointÂ *Q*Â representing the potentially tweaked threshold public key: a *GE*\n+- The accumulated tweakÂ *tacc*: a *Scalar*\n+- The valueÂ *gacc*: *Scalar(1)* or *Scalar(-1)*\n+\n+We write \"Let *(Q, gacc, tacc) = tweak_ctx*\" to assign names to the elements of a Tweak Context.\n+\n+Algorithm *TweakCtxInit(thresh_pk):*\n+\n+- Input:\n+  - The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+- Let *Q = cpoint(thresh_pk)*; fail if that fails\n+- Fail if *is_infinity(Q)*\n+- Let *gacc = Scalar(1)*\n+- Let *tacc = Scalar(0)*\n+- Return *tweak_ctx = (Q, gacc, tacc)*\n+\n+Algorithm *GetXonlyPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *xbytes(Q)*\n+\n+Algorithm *GetPlainPubkey(tweak_ctx)*:\n+\n+- Inputs:\n+  - The *tweak_ctx*: a [Tweak Context](#tweak-context) data structure\n+- LetÂ *(Q, _, _) = tweak_ctx*\n+- ReturnÂ *cbytes(Q)*\n+\n+#### Applying Tweaks\n+\n+Algorithm *ApplyTweak(tweak_ctx, tweak, is_xonly_t)*:\n+\n+- Inputs:\n+  - TheÂ *tweak_ctx*: aÂ [Tweak Context](#tweak-context)Â data structure\n+  - TheÂ *tweak*: a 32-byte array, serialized scalar\n+  - The tweak modeÂ *is_xonly_t*: a boolean\n+- LetÂ *(Q, gacc, tacc) = tweak_ctx*\n+- IfÂ *is_xonly_t*Â andÂ not *has_even_y(Q)*:\n+  - LetÂ *g = Scalar(-1)*\n+- Else:\n+  - LetÂ *g = Scalar(1)*\n+- Let *t = scalar_from_bytes_nonzero_checked(tweak)*; fail if that fails\n+- LetÂ *Q' = g &middot; Q + t &middot; G*\n+  - Fail ifÂ *is_infinity(Q')*\n+- LetÂ *gacc' = g &middot; gacc*\n+- LetÂ *tacc' = t + g &middot; tacc*\n+- ReturnÂ *tweak_ctx' = (Q', gacc', tacc')*\n+\n+### Nonce Generation\n+\n+Algorithm *NonceGen(secshare, pubshare, thresh_pk, m, extra_in)*:\n+\n+- Inputs:\n+  - The participant secret signing shareÂ *secshare*: a 32-byte array, serialized scalar (optional argument)\n+  - The participant public shareÂ *pubshare*: a 33-byte array, compressed serialized point (optional argument)\n+  <!-- REVIEW: why is this xonly? why not include the 33-bytes serialization? -->\n+  - The x-only threshold public keyÂ *thresh_pk*: a 32-byte array, X-only serialized point (optional argument)\n+  - The messageÂ *m*: a byte array (optional argument)[^max-msg-len]\n+  - The auxiliary inputÂ *extra_in*: a byte array withÂ *0 â‰¤ len(extra_in) â‰¤ 2<sup>32</sup>-1*Â (optional argument)\n+- LetÂ *rand' = random_bytes(32)*\n+- If the optional argumentÂ *secshare*Â is present:\n+  - LetÂ *rand = xor_bytes(secshare, hash<sub>FROST/aux</sub>(rand'))*[^sk-xor-rand]\n+- Else:\n+  - LetÂ *rand = rand'*\n+- If the optional argumentÂ *pubshare*Â is not present:\n+  - LetÂ *pubshare* = *empty_bytestring*\n+- If the optional argumentÂ *thresh_pk*Â is not present:\n+  - LetÂ *thresh_pk* = *empty_bytestring*\n+- If the optional argumentÂ *m*Â is not present:\n+  - LetÂ *m_prefixed = bytes(1, 0)*\n+- Else:\n+  - LetÂ *m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m*\n+- If the optional argumentÂ *extra_in*Â is not present:\n+  - LetÂ *extra_in = empty_bytestring*\n+- LetÂ *k<sub>i</sub>Â = scalar_from_bytes_wrapping(hash<sub>FROST/nonce</sub>(rand || bytes(1, len(pubshare)) || pubshare || bytes(1, len(thresh_pk)) || thresh_pk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1)))*Â forÂ *i = 1,2*\n+- Fail ifÂ *k<sub>1</sub>Â = Scalar(0)*Â orÂ *k<sub>2</sub>Â = Scalar(0)*",
      "path": "bip-frost-signing.md",
      "position": 427,
      "original_position": 427,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "While reading the implementation, I noticed that it includes a check ensuring that `k_1 != k_2`. At first glance, omitting this check does not appear to introduce any vulnerabilities, and we have verified this. However, I would appreciate hearing your opinion on this point.",
      "created_at": "2026-01-22T10:38:30Z",
      "updated_at": "2026-01-22T11:20:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2716310520",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716310520"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 427,
      "original_line": 427,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716459467",
      "pull_request_review_id": 3691689081,
      "id": 2716459467,
      "node_id": "PRRC_kwDOAN28mc6h6eHL",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*\n+\n+### Key Material and Setup\n+\n+#### Signers Context\n+\n+The Signers Context is a data structure consisting of the following elements:\n+\n+- The total number *n* of participants involved in key generation: an integer with *2 â‰¤ n < 2<sup>32</sup>*\n+- The threshold number *t* of participants required to issue a signature: an integer with *1 â‰¤ t â‰¤ n*\n+- The number *u* of signing participants: an integer with *t â‰¤ u â‰¤ n*\n+- The list of participant identifiers *id<sub>1..u</sub>*: *u* distinct integers, each with *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+- The list of participant public shares *pubshare<sub>1..u</sub>*: *u* 33-byte arrays, each a compressed serialized point\n+- The threshold public key *thresh_pk*: a 33-byte array, compressed serialized point\n+\n+We write \"Let *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\" to assign names to the elements of Signers Context.\n+\n+Algorithm *ValidateSignersCtx(signers_ctx)*:\n+\n+- Inputs:\n+  - The *signers_ctx*: a [Signers Context](#signers-context) data structure\n+- *(n, t, u, id<sub>1..u</sub>, pubshare<sub>1..u</sub>, thresh_pk) = signers_ctx*\n+- Fail if *t > n*\n+- Fail if not *t â‰¤ u â‰¤ n*\n+- For *i = 1 .. u*:\n+  - Fail if not *0 â‰¤ id<sub>i</sub> â‰¤ n - 1*\n+  - Fail if *cpoint(pubshare<sub>i</sub>)* fails\n+- Fail if *has_duplicates(id<sub>1..u</sub>)*\n+- Fail if *DeriveThreshPubkey(id<sub>1..u</sub>, pubshare<sub>1..u</sub>) â‰  thresh_pk*\n+- No return\n+\n+Internal Algorithm *DeriveThreshPubkey(id<sub>1..u</sub>,  pubshare<sub>1..u</sub>)*[^derive-thresh-no-validate-inputs]\n+\n+- *Q = inf_point*\n+- For *i = 1..u*:\n+  - *P* = cpoint(pubshare<sub>i</sub>); fail if that fails\n+  - *&lambda; = DeriveInterpolatingValue(id<sub>1..u</sub>, id<sub>i</sub>)*\n+  - *Q = Q + &lambda; &middot; P*\n+- Return *cbytes(Q)*\n+\n+[^derive-thresh-no-validate-inputs]: *DeriveThreshPubkey* does not check that its inputs are in range. This validation is performed by *ValidateSignersCtx*, which is its only caller.\n+\n+Internal Algorithm *DeriveInterpolatingValue(id<sub>1..u</sub>, my_id):*",
      "path": "bip-frost-signing.md",
      "position": 331,
      "original_position": 331,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": null,
      "user": {
        "login": "DarkWindman",
        "id": 78978625,
        "node_id": "MDQ6VXNlcjc4OTc4NjI1",
        "avatar_url": "https://avatars.githubusercontent.com/u/78978625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DarkWindman",
        "html_url": "https://github.com/DarkWindman",
        "followers_url": "https://api.github.com/users/DarkWindman/followers",
        "following_url": "https://api.github.com/users/DarkWindman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DarkWindman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DarkWindman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DarkWindman/subscriptions",
        "organizations_url": "https://api.github.com/users/DarkWindman/orgs",
        "repos_url": "https://api.github.com/users/DarkWindman/repos",
        "events_url": "https://api.github.com/users/DarkWindman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DarkWindman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In fact, the specification very subtly avoids an explicit global shift of all identifiers, simplifying the description to the use of `id+1` only in the numerator. However, will not this create possible misunderstandings in the future? Perhaps it would make sense to mention this earlier in the specification? I would be glad to hear your thoughts!",
      "created_at": "2026-01-22T11:13:40Z",
      "updated_at": "2026-01-22T11:20:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2716459467",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2716459467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 331,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2717872165",
      "pull_request_review_id": 3693637663,
      "id": 2717872165,
      "node_id": "PRRC_kwDOAN28mc6h_3Al",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.",
      "path": "bip-frost-signing.md",
      "position": 99,
      "original_position": 99,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2689921315,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah yes, thank you! I left this one in by mistake.",
      "created_at": "2026-01-22T17:20:49Z",
      "updated_at": "2026-01-22T17:20:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2717872165",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2717872165"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 99,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2717912357",
      "pull_request_review_id": 3693689480,
      "id": 2717912357,
      "node_id": "PRRC_kwDOAN28mc6iAA0l",
      "diff_hunk": "@@ -0,0 +1,822 @@\n+```\n+BIP: ?\n+Title: FROST Signing Protocol for BIP340 Signatures\n+Author: Sivaram Dhakshinamoorthy <siv2ram@gmail.com>\n+Comments-URI:\n+Status: Draft\n+Type: Standards Track\n+Assigned: ?\n+License: CC0-1.0 or MIT\n+Post-History: https://groups.google.com/g/bitcoindev/c/PeMp2HQl-H4/m/AcJtK0aKAwAJ\n+Requires: 32, 340, 341\n+```\n+\n+## Abstract\n+\n+This document proposes a standard for theÂ Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. The standard is compatible withÂ [BIP340][bip340]Â public keys and signatures. It supportsÂ *tweaking*, which allows derivingÂ [BIP32][bip32]Â child keys from the threshold public key and creatingÂ [BIP341][bip341]Â Taproot outputs with key and script paths.\n+\n+## Copyright\n+\n+This document is made available under [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).\n+The accompanying source code is licensed under the [MIT license](https://opensource.org/license/mit).\n+\n+## Motivation\n+\n+<!-- REVIEW: Should we add a paragraph about `OP_CHECKSIGADD` like BIP327 does? -->\n+\n+The FROST signature scheme enables threshold Schnorr signatures. In a `t`-of-`n` threshold configuration, any `t`[^t-edge-cases] participants can cooperatively produce a Schnorr signature that is indistinguishable from a signature produced by a single signer. FROST signatures are unforgeable as long as fewer than `t` participants are corrupted. The signing protocol remains functional provided that at least `t` honest participants retain access to their secret key shares.\n+\n+[^t-edge-cases]: While `t = n` and `t = 1` are in principle supported, simpler alternatives are available in these cases. In the case `t = n`, using a dedicated `n`-of-`n` multi-signature scheme such as MuSig2 (see [BIP327][bip327]) instead of FROST avoids the need for an interactive DKG. The case `t = 1` can be realized by letting one signer generate an ordinary [BIP340][bip340] key pair and transmitting the key pair to every other signer, who can check its consistency and then simply use the ordinary [BIP340][bip340] signing algorithm. Signers still need to ensure that they agree on a key pair.\n+\n+The IRTF has published [RFC 9591][rfc9591], which specifies the FROST signing protocol for several elliptic curve and hash function combinations, including secp256k1 with SHA-256, the cryptographic primitives used in Bitcoin. However, the signatures produced by RFC 9591 are incompatible with BIP340 Schnorr signatures due to the X-only public keys introduced in BIP340. Additionally, RFC 9591 does not specify key tweaking mechanisms, which are essential for Bitcoin applications such as [BIP32][bip32] key derivation and [BIP341][bip341] Taproot. This document addresses these limitations by specifying a BIP340-compatible variant of FROST signing protocol that supports key tweaking.\n+\n+Following the initial publication of the FROST protocol[[KG20][frost1]], several optimized variants have been proposed to improve computational efficiency and bandwidth optimization: FROST2[[CKM21][frost2]], FROST2-BTZ[[BTZ21][stronger-security-frost]], and FROST3[[CGRS23][olaf]]. Among these variants, FROST3 is the most efficient variant to date.\n+\n+This document specifies the FROST3 variant[^frost3-security]. The FROST3 signing protocol shares substantial similarities with the MuSig2 signing protocol specified in [BIP327][bip327]. Accordingly, this specification adopts several design principles from BIP327, including support for key tweaking, partial signature verification, and identifiable abort mechanisms. We note that significant portions of this document have been directly adapted from BIP327 due to the similarities in the signing protocols. Key generation for FROST signing is out of scope for this document.\n+\n+[^frost3-security]: The FROST3 signing scheme has been proven existentially unforgeable for both trusted dealer and distributed key generation setups. When using a trusted dealer for key generation, security reduces to the standard One-More Discrete Logarithm (OMDL) assumption. When instantiated with a distributed key generation protocol such as SimplPedPoP, security reduces to the Algebraic One-More Discrete Logarithm (AOMDL) assumption.\n+\n+## Overview\n+\n+Implementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+### Optionality of Features\n+\n+The goal of this proposal is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+\n+- Applying plain tweaks after x-only tweaks.\n+- Applying tweaks at all.\n+- Dealing with messages that are not exactly 32 bytes.\n+- Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+### Key Material and Setup\n+\n+<!-- REVIEW: should we use \"identifiers `i`\", secret share `secshare_i` style here? -->\n+A FROST key generation protocol configures a group of `n` participants with a *threshold public key* (representing a `t`-of-`n` threshold policy).\n+The corresponding *threshold secret key* is Shamir secret-shared among all `n` participants, where each participant holds a distinct long-term *secret share*.\n+This ensures that any subset of at least `t` participants can jointly run the FROST signing protocol to produce a signature under the *threshold secret key*.\n+\n+Key generation for FROST signing is out of scope for this document. Implementations can use either a trusted dealer setup, as specified in [Appendix C of RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-trusted-dealer-key-generati), or a distributed key generation (DKG) protocol such as [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg). The appropriate choice depends on the implementations's trust model and operational requirements.\n+\n+This protocol distinguishes between two public key formats: *plain public keys* are 33-byte compressed public keys traditionally used in Bitcoin, while *X-only public keys* are 32-byte keys defined in [BIP340][bip340].\n+Key generation protocols produce *public shares* and *threshold public keys* in the plain format. During signing, we conditionally negates *secret shares* to ensure the resulting threshold-signature verifies under the corresponding *X-only threshold public key*.\n+\n+> [!WARNING]\n+> Key generation protocols must commit the *threshold public key* to an unspendable script path as recommended in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-23). This prevents a malicious party from embedding a hidden script path during key generation that would allow them to bypass the `t`-of-`n` threshold policy.\n+\n+#### Protocol Parties and Network Setup\n+\n+There are `u` (where `t <= u <= n < 2^32`) participants and one coordinator initiating the FROST signing protocol.\n+Each participant has a point-to-point communication link to the coordinator (but participants do not have direct communication links to each other).\n+\n+If there is no dedicated coordinator, one of the participants can act as the coordinator.\n+\n+#### Signing Inputs and Outputs\n+\n+Each signing session requires two inputs: a participant's long-term *secret share* `secshare_i` (individual to each participant, not shared with the coordinator) and a [*Signers Context*](#signers-context)[^signers-ctx-struct] data structure (common to all participants and the coordinator).\n+\n+[^signers-ctx-struct]: The *Signers Context* represents the public data of signing participants: their identifiers (*id<sub>1..u</sub>*) and public shares (*pubshare<sub>1..u</sub>*).\n+Implementations may represent this as simply as two separate lists passed to signing APIs.\n+The threshold public key *thresh_pk* can be stored for efficiency or recomputed when needed using *DeriveThreshPubkey*.\n+Similarly, the values *n* and *t* are used only for validation, and can be omitted if validation is not performed.\n+\n+This signing protocol is compatible with any key generation protocol that produces valid FROST keys.\n+Valid keys satisfy: (1) each *secret share* is a Shamir share of the *threshold secret key*, and (2) each *public share* equals the scalar multiplication `secshare * G`.\n+Implementations may **optionally** validate key compatibility for a signing session using the *ValidateSignersCtx* function.\n+For comprehensive validation of the entire key material, *ValidateSignersCtx* can be run on all possible `u` signing participants.\n+\n+> [!IMPORTANT]\n+> Passing *ValidateSignersCtx* ensures functional compatibility with the signing protocol but does not guarantee the security of the key generation protocol itself.\n+\n+The output of the FROST signing protocol is a BIP340 Schnorr signature that verifies under the *threshold public key* as if it were produced by a single signer using the *threshold secret key*.\n+\n+### General Signing Flow\n+\n+We assume that the coordinator and the signing participants (in the algorithms specified below, is stored in a data structure called [Signers Context](#signers-context)) are selected externally to the signing protocol before it is initiated. They could also optionally tweak the *threshold public key* now, by initializing [Tweak Context](#tweak-context) with it.\n+\n+The coordinator and signing participants must be determined before initiating the signing protocol.\n+This information is stored in a [*Signers Context*](#signers-context) data structure.\n+The *threshold public key* may optionally be tweaked by initializing a [*Tweak Context*](#tweak-context) at this stage.\n+\n+Whenever the signing participants want to sign a message, the basic order of operations to create a threshold-signature is as follows:\n+\n+**First broadcast round:**\n+Signers begin the signing session by running *NonceGen* to compute their *secnonce* and *pubnonce*.[^nonce-serialization-detail]\n+Each signer sends their *pubnonce* to the coordinator, who aggregates them using *NonceAgg* to produce an aggregate nonce and sends it back to all signers.\n+\n+[^nonce-serialization-detail]: We treat the *secnonce* and *pubnonce* as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively.\n+This treatment may be confusing for readers familiar with the MuSig2 paper.\n+However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.\n+\n+**Second broadcast round:**\n+At this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [Session Context](#session-context).\n+Every signer computes a partial signature by running *Sign* with their long-term *secret share*, *secnonce* and the session context.\n+Then, the signers broadcast their partial signatures to the coordinator, who runs *PartialSigAgg* to produce the final signature.\n+If all parties behaved honestly, the result passes [BIP340][bip340] verification.\n+\n+![Frost signing flow](./bip-frost-signing/docs/frost-signing-flow.png)\n+\n+A malicious coordinator can cause the signing session to fail but cannot compromise the unforgeability of the scheme. Even when colluding with up to `t-1` signers, a malicious coordinator cannot forge a signature.\n+\n+> [!TIP]\n+> The *Sign* algorithm must **not** be executed twice with the same *secnonce*.\n+> Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of *Sign*.\n+> To avoid accidental reuse of *secnonce*, an implementation may securely erase the *secnonce* argument by overwriting it with 64 zero bytes after it has been read by *Sign*.\n+> A *secnonce* consisting of only zero bytes is invalid for *Sign* and will cause it to fail.\n+\n+To simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing *GetSessionValues* multiple times.\n+Actual implementations can cache these values.\n+As a result, the [Session Context](#session-context) may look very different in implementations or may not exist at all.\n+However, computation of *GetSessionValues* and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+### Nonce Generation\n+\n+*NonceGen* must have access to a high-quality random generator to draw an unbiased, uniformly random value *rand'*.\n+In contrast to BIP340 signing, the values *k<sub>1</sub>* and *k<sub>2</sub>* **must not be derived deterministically** from the session parameters because deriving nonces deterministically allows for a [complete key-recovery attack in multi-party discrete logarithm-based signatures](https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6).\n+<!-- TODO: link a research paper, instead of a blog, for the multi-party discrete logarithm-based signatures. Maybe summarize the issue in a foot note? -->\n+\n+The optional arguments to *NonceGen* enable a defense-in-depth mechanism that may prevent secret share exposure if *rand'* is accidentally not drawn uniformly at random.\n+If the value *rand'* was identical in two *NonceGen* invocations, but any other argument was different, the *secnonce* would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same *secnonce* for *Sign* in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments *secshare*, *pubshare*, *thresh_pk*, and *m* if these session parameters are already determined during nonce generation.\n+The auxiliary input *extra_in* can contain additional contextual data that has a chance of changing between *NonceGen* runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of *NonceGen* is relatively strong, particularly when facing an active adversary.\n+\n+In some applications, the coordinator may enable preprocessing of nonce generation to reduce signing latency.\n+Participants run *NonceGen* to generate a batch of *pubnonce* values before the message or *Signers Context*[^preprocess-round1] is known, which are stored with the coordinator (e.g., on a centralized server).\n+During this preprocessing phase, only the available arguments are provided to *NonceGen*.\n+When a signing session begins, the coordinator selects and aggregates *pubnonces* of the signing participants, enabling them to run *Sign* immediately once the message is determined.\n+This way, the final signature is created quicker and with fewer round trips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+<!-- TODO: learn about security of FROST3 pre-process round. Write remarks about it, in security section -->\n+\n+[^preprocess-round1]: When preprocessing *NonceGen* round, the *Signers Context* can be extended to include the *pubnonces* of the signing participants, as these are generated and stored before the signing session begins.\n+\n+FROST signers are typically stateful: they generate *secnonce*, store it, and later use it to produce a partial signature after receiving the aggregated nonce.\n+However, stateless signing is possible when one signer receives the aggregate nonce of all OTHER signers before generating their own nonce.\n+In coordinator-based setups, the coordinator facilitates this by collecting pubnonces from the other signers, computing their aggregate (*aggothernonce*), and providing it to the stateless signer.\n+The stateless signer then runs *NonceGen*, *NonceAgg*, and *Sign* in sequence, sending its *pubnonce* and partial signature simultaneously to the coordinator, who computes the final aggregate nonce for all participants.\n+In coordinator-less setups, any one signer can achieve stateless operation by generating their nonce after seeing all other signers' *pubnonces*.\n+Stateless signers may want to consider signing deterministically (see [Modifications to Nonce Generation](#modifications-to-nonce-generation)) to remove the reliance on the random number generator in the *NonceGen* algorithm.\n+\n+<!-- TODO: rewrite it for coordinator setup -->\n+### Identifying Disruptive Signers\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+\n+- The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+- Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the coordinator is trusted).\n+- The partial signatures received from all signers are verified using the algorithm *PartialSigVerify*.\n+\n+If these conditions hold and an honest party (signer or coordinator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the participant identifier of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+#### Further Remarks\n+\n+Some of the algorithms specified below may also assign blame to a malicious coordinator.\n+While this is possible for some particular misbehavior of the coordinator, it is not guaranteed that a malicious coordinator can be identified.\n+More specifically, a malicious coordinator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm *PartialSigVerify* is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are *not* signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret share for that particular participant public share.[^partialsig-forgery]\n+However, if *PartialSigVerify* succeeds for all partial signatures then *PartialSigAgg* will return a valid Schnorr signature.\n+\n+[^partialsig-forgery]: Assume a malicious participant intends to forge a partial signature for the participant with public share *P*. It participates in the signing session pretending to be two distinct signers: one with the public share *P* and the other with its own public share. The adversary then sets the nonce for the second signer in such a way that allows it to generate a partial signature for *P*. As a side effect, it cannot generate a valid partial signature for its own public share. An explanation of the steps required to create a partial signature forgery can be found in [this document](https://gist.github.com/siv2r/0eab97bae9b7186ef2a4919e49d3b426).\n+\n+### Tweaking the Threshold Public Key\n+\n+The threshold public key can be *tweaked*, which modifies the key as defined in the [Tweaking Definition](#tweaking-definition) subsection.\n+In order to apply a tweak, the Tweak Context output by *TweakCtxInit* is provided to the *ApplyTweak* algorithm with the *is_xonly_t* argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting Tweak Context can be used to apply another tweak with *ApplyTweak* or obtain the threshold public key with *GetXonlyPubkey* or *GetPlainPubkey*.\n+\n+The purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The FROST signing algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.[^arbitrary-tweaks]\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the threshold public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only threshold public key is required.\n+For example, to do [BIP32][bip32] derivation, you call *GetPlainPubkey* to be able to compute the tweak, whereas [BIP341][bip341] TapTweaks require X-only public keys that are obtained with *GetXonlyPubkey*.\n+\n+[^arbitrary-tweaks]: It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of FROST.\n+\n+The tweak mode provided to *ApplyTweak* depends on the application:\n+Plain tweaking can be used to derive child public keys from a threshold public key using [BIP32][bip32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [BIP341][bip341].\n+A Taproot-tweaked public key commits to a *script path*, allowing users to create transaction outputs that are spendable either with a FROST threshold-signature or by providing inputs that satisfy the script path.\n+Script path spends require a control block that contains a parity bit for the tweaked X-only public key.\n+The bit can be obtained with `GetPlainPubkey(tweak_ctx)[0] & 1`.\n+\n+## Algorithms\n+\n+The following specification of the algorithms has been written with a focus on clarity. As a result, the specified algorithms are not always optimal in terms of computation and space. In particular, some values are recomputed but can be cached in actual implementations (see [General Signing Flow](#general-signing-flow)).\n+\n+### Notation\n+\n+The algorithms are defined over the **[secp256k1](https://www.secg.org/sec2-v2.pdf) group and its associated scalar field**. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+\n+#### Cryptographic Types and Operations\n+\n+We rely on the following types and conventions throughout this document:\n+\n+- **Types:** Points on the curve are represented by the object *GE*, and scalars are represented by *Scalar*.\n+- **Naming:** Points are denoted using uppercase letters (e.g., *P*, *Q*), while scalars are denoted using lowercase letters (e.g., *r*, *s*).\n+- **Mathematical Context:** Points are group elements under elliptic curve addition. The group includes all points on the secp256k1 curve plus the point at infinity (the identity element).\n+- **Arithmetic:** The operators +, -, and &middot; are overloaded depending on their operands:\n+  - **Scalar Arithmetic:**[^implicit-mod] When applied to two *Scalar* operands, +, -, and &middot; denote integer addition, subtraction, and multiplication modulo the group order.\n+  - **Point Addition:** When applied to two *GE* operands, + denotes the elliptic curve [group addition operation](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law).\n+  - **Scalar Multiplication:** The notation r &middot; P denotes [scalar multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) (the repeated addition of point P, r times).\n+\n+[^implicit-mod]: The algorithms in upcoming sections, when a scalar arithmetic is performed, the *mod order* is implicit. They don't spell it out. For example, no a &middot; b mod order, they just say a &middot; b.\n+\n+The reference code vendors the secp256k1lab library to handle underlying arithmetic, serialization, deserialization, and auxiliary functions. To improve the readability of this specification, we utilize simplified notation aliases for the library's internal methods, as mapped below:\n+\n+<!-- markdownlint-disable MD033 -->\n+| Notation | secp256k1lab | Description |\n+| --- | --- | --- |\n+| *p* | *FE.SIZE* | Field element size |\n+| *order* | *GE.ORDER* | Group order |\n+| *G* | *G* | The secp256k1 generator point |\n+| *inf_point* | *GE()* | The infinity point |\n+| *is_infinity(P)* | *P.infinity()* | Returns whether *P* is the point at infinity |\n+| *x(P)* | *P.x* | Returns the x-coordinate of a non-infinity point *P*, in the range *[0, pâˆ’1]* |\n+| *y(P)* | *P.y* | Returns the y-coordinate of a non-infinity point *P*, in the range *[0, p-1]* |\n+| *has_even_y(P)* | *P.has_even_y()* | Returns whether *P* has an even y-coordinate |\n+| *with_even_y(P)* | - | Returns the version of point *P* that has an even y-coordinate. If *P* already has an even y-coordinate (or is infinity), it is returned unchanged. Otherwise, its negation *-P* is returned |\n+| *xbytes(P)* | *P.to_bytes_xonly()* | Returns the 32-byte x-only serialization of a non-infinity point *P* |\n+| *cbytes(P)* | *P.to_bytes_compressed()* | Returns the 33-byte compressed serialization of a non-infinity point *P* |\n+| *cbytes_ext(P)* | *P.to_bytes_compressed<br>_with_infinity()* | Returns the 33-byte compressed serialization of a point *P*. If *P* is the point at infinity, it is encoded as a 33-byte array of zeros. |\n+| *lift_x(x)*[^liftx-soln] | *GE.lift_x(x)* | Decodes a 32-byte x-only serialization *x* into a non-infinity point P. The resulting point always has an even y-coordinate. |\n+| *cpoint(b)* | *GE.from_bytes_compressed(b)* | Decodes a 33-byte compressed serialization *b* into a non-infinity point |\n+| *cpoint_ext(b)* | *GE.from_bytes_compressed<br>_with_infinity(b)* | Decodes a 33-byte compressed serialization *b* into a point. If *b* is a 33-byte array of zeros, it returns the point at infinity |\n+| *scalar_from_bytes_checked(b)* | *Scalar.from_bytes_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is â‰¥ *order* |\n+| *scalar_from_bytes<br>_nonzero_checked(b)* | *Scalar.from_bytes<br>_nonzero_checked(b)* | Deserializes a 32-byte array *b* to a scalar, fails if the value is zero or â‰¥ *order* |\n+| *scalar_from_bytes_wrapping(b)* | *Scalar.from_bytes_wrapping(b)* | Deserializes a 32-byte array *b* to a scalar, reducing the value modulo *order* |\n+| *scalar_to_bytes(s)* | *s.to_bytes()* | Returns the 32-byte serialization of a scalar *s* |\n+| *hash<sub>tag</sub>(x)* | *tagged_hash(x)* | Computes a 32-byte domain-separated hash of the byte array *x*. The output is *SHA256(SHA256(tag) \\|\\| SHA256(tag) \\|\\| x)*, where *tag* is UTF-8 encoded string unique to the context |\n+| *random_bytes(n)* | - | Returns *n* bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG) |\n+| *xor_bytes(a, b)* | *xor_bytes(a, b)* | Returns byte-wise xor of *a* and *b* |\n+<!-- markdownlint-enable MD033 -->\n+\n+[^liftx-soln]: Given a candidate X coordinate *x* in the range *0..p-1*, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then *x* is not a valid X coordinate either, i.e., no point *P* exists for which *x(P) = x*. The valid Y coordinates for a given candidate *x* are the square roots of *c = x<sup>3</sup> + 7 mod p* and they can be computed as *y = Â±c<sup>(p+1)/4</sup> mod p* (see [Quadratic residue](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)) if they exist, which can be checked by squaring and comparing with *c*.\n+\n+#### Auxiliary and Byte-string Operations\n+\n+The following helper functions and notation are used for operations on standard integers and byte arrays, independent of curve arithmetic. Note that like Scalars, these variables are denoted by lowercase letters (e.g., *x*, *n*); the intended type is implied by context.\n+\n+| Notation | Description |\n+| --- | --- |\n+| *\\|\\|* | Refers to byte array concatenation |\n+| *len(x)* | Returns the length of the byte array *x* in bytes |\n+| *x[i:j]* | Returns the sub-array of the byte array *x* starting at index *i* (inclusive) and ending at *j* (exclusive). The result has length *j - i* |\n+| *empty_bytestring* | A constant representing an empty byte array where length is 0 |\n+| *bytes(n, x)* | Returns the big-endian *n*-byte encoding of the integer *x* |\n+| *count(x, lst)* | Returns the number of times the element *x* occurs in the list *lst* |\n+| *has_duplicates(lst)* | Returns *True* if any element in *lst* appears more than once, *False* otherwise |\n+| *sorted(lst)* | Returns a new list containing the elements of *lst* arranged in ascending order |\n+| *(a, b, ...)* | Refers to a tuple containing the listed elements |\n+\n+> [!NOTE]\n+> In the following algorithms, all scalar arithmetic is understood to be modulo the group order. For example, *a &middot; b* implicitly means *a &middot; b mod order*",
      "path": "bip-frost-signing.md",
      "position": 289,
      "original_position": 289,
      "commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "original_commit_id": "ec46a20323840b1a6aba83bc2d18b34dd0811245",
      "in_reply_to_id": 2689949680,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I don't understand what you're suggesting. Should I use `mod n` explicitly in the equations instead of adding the note? Or are you saying to remove the repeated footnote? \r\n\r\nI've removed the duplicate footnote for now.",
      "created_at": "2026-01-22T17:30:08Z",
      "updated_at": "2026-01-22T17:30:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2070#discussion_r2717912357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2717912357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2070"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 289,
      "original_line": 289,
      "side": "RIGHT"
    }
  ]
}