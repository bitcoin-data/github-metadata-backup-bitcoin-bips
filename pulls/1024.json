{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1024",
    "id": 507366514,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTA3MzY2NTE0",
    "html_url": "https://github.com/bitcoin/bips/pull/1024",
    "diff_url": "https://github.com/bitcoin/bips/pull/1024.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1024.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1024",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1024/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1024/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1024/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
    "number": 1024,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "WIP [don't merge] Add BIP324 - Version 2 Peer-to-Peer Message Transport Protocol",
    "user": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Discussions happend here:\r\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/thread.html#16806\r\nhttps://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52#comments\r\n\r\nImplementations is partially merged in Bitcoin Core (AEAD, KDF).",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2020-10-21T08:49:42Z",
    "updated_at": "2022-10-21T04:35:09Z",
    "closed_at": "2022-05-05T16:33:01Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merge_commit_sha": "9751937d495152fa849e8fac8be23801fced46a9",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "jonasschnelli:master",
      "ref": "master",
      "sha": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "user": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 26754477,
        "node_id": "MDEwOlJlcG9zaXRvcnkyNjc1NDQ3Nw==",
        "name": "bips",
        "full_name": "jonasschnelli/bips",
        "owner": {
          "login": "jonasschnelli",
          "id": 178464,
          "node_id": "MDQ6VXNlcjE3ODQ2NA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/jonasschnelli",
          "html_url": "https://github.com/jonasschnelli",
          "followers_url": "https://api.github.com/users/jonasschnelli/followers",
          "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
          "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
          "repos_url": "https://api.github.com/users/jonasschnelli/repos",
          "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/jonasschnelli/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/jonasschnelli/bips",
        "archive_url": "https://api.github.com/repos/jonasschnelli/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/jonasschnelli/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/jonasschnelli/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/jonasschnelli/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/jonasschnelli/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/jonasschnelli/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/jonasschnelli/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/jonasschnelli/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/jonasschnelli/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/jonasschnelli/bips/contributors",
        "deployments_url": "https://api.github.com/repos/jonasschnelli/bips/deployments",
        "downloads_url": "https://api.github.com/repos/jonasschnelli/bips/downloads",
        "events_url": "https://api.github.com/repos/jonasschnelli/bips/events",
        "forks_url": "https://api.github.com/repos/jonasschnelli/bips/forks",
        "git_commits_url": "https://api.github.com/repos/jonasschnelli/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/jonasschnelli/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/jonasschnelli/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/jonasschnelli/bips.git",
        "issue_comment_url": "https://api.github.com/repos/jonasschnelli/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/jonasschnelli/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/jonasschnelli/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/jonasschnelli/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/jonasschnelli/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/jonasschnelli/bips/languages",
        "merges_url": "https://api.github.com/repos/jonasschnelli/bips/merges",
        "milestones_url": "https://api.github.com/repos/jonasschnelli/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/jonasschnelli/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/jonasschnelli/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/jonasschnelli/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:jonasschnelli/bips.git",
        "stargazers_url": "https://api.github.com/repos/jonasschnelli/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/jonasschnelli/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/jonasschnelli/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/jonasschnelli/bips/subscription",
        "tags_url": "https://api.github.com/repos/jonasschnelli/bips/tags",
        "teams_url": "https://api.github.com/repos/jonasschnelli/bips/teams",
        "trees_url": "https://api.github.com/repos/jonasschnelli/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/jonasschnelli/bips.git",
        "hooks_url": "https://api.github.com/repos/jonasschnelli/bips/hooks",
        "svn_url": "https://github.com/jonasschnelli/bips",
        "homepage": "bitcoin.org",
        "language": "Python",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 9335,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2020-10-30T08:05:34Z",
        "created_at": "2014-11-17T11:51:58Z",
        "updated_at": "2020-10-30T08:05:40Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "7e3284dafda168da34888977dbf4a55519b0c54d",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5178,
        "stargazers_count": 8116,
        "watchers_count": 8116,
        "size": 13694,
        "default_branch": "master",
        "open_issues_count": 115,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-08T12:03:37Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2023-06-12T10:53:19Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 474,
    "deletions": 0,
    "changed_files": 2,
    "commits": 1,
    "review_comments": 25,
    "comments": 6
  },
  "events": [
    {
      "event": "labeled",
      "id": 3902670861,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDM5MDI2NzA4NjE=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3902670861",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-21T08:49:42Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "commented",
      "id": 713421069,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcxMzQyMTA2OQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/713421069",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-21T09:00:05Z",
      "updated_at": "2020-10-21T09:00:05Z",
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1024#issuecomment-713421069",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1024"
    },
    {
      "event": "commented",
      "id": 714389257,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcxNDM4OTI1Nw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/714389257",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-22T10:14:37Z",
      "updated_at": "2020-10-22T10:14:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "Question: why not to stick to the same messaging structure used by the current LN and increase the number of encoding standards/protocol/library code?",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1024#issuecomment-714389257",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1024"
    },
    {
      "event": "commented",
      "id": 714451369,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcxNDQ1MTM2OQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/714451369",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-22T12:13:47Z",
      "updated_at": "2020-10-22T12:13:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "@dr-orlovsky \r\nI think BOLT8 is very similar to the proposed AEAD scheme we use in BIP324. I guess BOLT8 was inspired by BIP151 which is the predecessor of BIP324.\r\nThe main differences are the handshake as well as the MACing of the encrypted length.\r\n\r\nThe reason why I don't think using BOLT8 directly are the following:\r\n* LN nodes have static node keys (nodeid), Bitcoin doesn't. Bitcoin Nodes try to be non fingerprintable.\r\n* One goal of designing BIP324 was to not increase the bandwidth (traffic) requirement of peers. My observations shows that roughly 50% of all sent and receives bitcoin messages of a node are <= 64 bytes (even higher for pruned peers). Adding another 16byte MAC for each package would increase the traffic requirement significant (IMO without reasonable security benefits).",
      "user": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1024#issuecomment-714451369",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1024"
    },
    {
      "event": "mentioned",
      "id": 3908729209,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzkwODcyOTIwOQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3908729209",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-22T12:13:47Z"
    },
    {
      "event": "subscribed",
      "id": 3908729221,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM5MDg3MjkyMjE=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3908729221",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-22T12:13:47Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTQ1MzE3Mzc6MmQzMzFlOGE4OTdhYmRkMDlmYzNhZjhlMzUyYmIwYjc0ZjJjYmM5Mw==",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "tree": {
        "sha": "2b88b85d053207f4b91652e97579200e0c5db42f",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/2b88b85d053207f4b91652e97579200e0c5db42f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/f7ea92c02bf879d264ea9f5f465f0abd617a6c7b",
          "sha": "f7ea92c02bf879d264ea9f5f465f0abd617a6c7b",
          "html_url": "https://github.com/bitcoin/bips/commit/f7ea92c02bf879d264ea9f5f465f0abd617a6c7b"
        }
      ],
      "message": "Add BIP324 - Version 2 Peer-to-Peer Message Transport Protocol",
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2020-10-30T08:05:23Z"
      },
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2020-10-21T08:40:46Z"
      },
      "sha": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3939966760,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzkzOTk2Njc2MA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3939966760",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-30T08:05:38Z"
    },
    {
      "event": "reviewed",
      "id": 521173701,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTczNzAx",
      "url": null,
      "actor": null,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1024#pullrequestreview-521173701",
      "submitted_at": "2020-10-31T22:40:38Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
    },
    {
      "event": "renamed",
      "id": 3953842858,
      "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50Mzk1Mzg0Mjg1OA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3953842858",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-03T16:48:02Z",
      "rename": {
        "from": "Add BIP324 - Version 2 Peer-to-Peer Message Transport Protocol",
        "to": "WIP [don't merge] Add BIP324 - Version 2 Peer-to-Peer Message Transport Protocol"
      }
    },
    {
      "event": "reviewed",
      "id": 887343272,
      "node_id": "PRR_kwDOAN28mc4048io",
      "url": null,
      "actor": null,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "narich",
        "id": 25741211,
        "node_id": "MDQ6VXNlcjI1NzQxMjEx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25741211?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/narich",
        "html_url": "https://github.com/narich",
        "followers_url": "https://api.github.com/users/narich/followers",
        "following_url": "https://api.github.com/users/narich/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/narich/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/narich/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/narich/subscriptions",
        "organizations_url": "https://api.github.com/users/narich/orgs",
        "repos_url": "https://api.github.com/users/narich/repos",
        "events_url": "https://api.github.com/users/narich/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/narich/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1024#pullrequestreview-887343272",
      "submitted_at": "2022-02-18T14:26:05Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
    },
    {
      "event": "commented",
      "id": 1118650764,
      "node_id": "IC_kwDOAN28mc5CrUGM",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1118650764",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T14:51:09Z",
      "updated_at": "2022-05-05T14:51:09Z",
      "author_association": "MEMBER",
      "body": "@jonasschnelli Are you still working on this?",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1024#issuecomment-1118650764",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1024"
    },
    {
      "event": "mentioned",
      "id": 6557202201,
      "node_id": "MEE_lADOAN28mc4rShJJzwAAAAGG1vcZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557202201",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T14:51:09Z"
    },
    {
      "event": "subscribed",
      "id": 6557202215,
      "node_id": "SE_lADOAN28mc4rShJJzwAAAAGG1vcn",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557202215",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T14:51:09Z"
    },
    {
      "event": "commented",
      "id": 1118698772,
      "node_id": "IC_kwDOAN28mc5Crf0U",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1118698772",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:28:34Z",
      "updated_at": "2022-05-05T15:30:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "@luke-jr: I think @dhruv has taken over [work](https://gist.github.com/dhruv/5b1275751bc98f3b64bcafce7876b489) on BIP 324. In fact (assuming @dhruv agrees) this PR could probably be closed in favor of a future PR from @dhruv.",
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1024#issuecomment-1118698772",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1024"
    },
    {
      "event": "mentioned",
      "id": 6557496256,
      "node_id": "MEE_lADOAN28mc4rShJJzwAAAAGG23PA",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557496256",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:28:35Z"
    },
    {
      "event": "subscribed",
      "id": 6557496280,
      "node_id": "SE_lADOAN28mc4rShJJzwAAAAGG23PY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557496280",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:28:35Z"
    },
    {
      "event": "mentioned",
      "id": 6557496294,
      "node_id": "MEE_lADOAN28mc4rShJJzwAAAAGG23Pm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557496294",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:28:35Z"
    },
    {
      "event": "subscribed",
      "id": 6557496307,
      "node_id": "SE_lADOAN28mc4rShJJzwAAAAGG23Pz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557496307",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:28:35Z"
    },
    {
      "event": "commented",
      "id": 1118714521,
      "node_id": "IC_kwDOAN28mc5CrjqZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1118714521",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:38:52Z",
      "updated_at": "2022-05-05T15:38:52Z",
      "author_association": "MEMBER",
      "body": "@michaelfolkson @luke-jr I agree we can close this PR. The new new draft is very different and reviewing the diff will not make sense. I will link this closed PR in the new one.",
      "user": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1024#issuecomment-1118714521",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1024"
    },
    {
      "event": "mentioned",
      "id": 6557580710,
      "node_id": "MEE_lADOAN28mc4rShJJzwAAAAGG3L2m",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557580710",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:38:53Z"
    },
    {
      "event": "subscribed",
      "id": 6557580722,
      "node_id": "SE_lADOAN28mc4rShJJzwAAAAGG3L2y",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557580722",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:38:53Z"
    },
    {
      "event": "mentioned",
      "id": 6557580742,
      "node_id": "MEE_lADOAN28mc4rShJJzwAAAAGG3L3G",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557580742",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:38:53Z"
    },
    {
      "event": "subscribed",
      "id": 6557580758,
      "node_id": "SE_lADOAN28mc4rShJJzwAAAAGG3L3W",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557580758",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T15:38:53Z"
    },
    {
      "event": "closed",
      "id": 6557959191,
      "node_id": "CE_lADOAN28mc4rShJJzwAAAAGG4oQX",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/6557959191",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-05T16:33:01Z"
    },
    {
      "event": "comment_deleted",
      "id": 7637091315,
      "node_id": "CDE_lADOAN28mc4rShJJzwAAAAHHNMPz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7637091315",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-21T04:34:50Z"
    },
    {
      "event": "locked",
      "id": 7637092813,
      "node_id": "LOE_lADOAN28mc4rShJJzwAAAAHHNMnN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7637092813",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-21T04:35:09Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515544378",
      "pull_request_review_id": 521173701,
      "id": 515544378,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NDM3OA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.",
      "path": "bip-0324.mediawiki",
      "position": 18,
      "original_position": 18,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't like \"current\" for the same reason I don't like it on Wikipedia, it will be weird reading this document in 5 years. Better just write \"the P2P protocol supported in Bitcoin 0.20.1\".\r\n\r\n\"partially inefficient\" in which way? Because of the double-SHA256? Surely the lack of encryption isn't inefficient, which is what most of the section talks about. I would at least just remove \"partially\", inefficiency isn't black/white in any case, so the word \"partially\" doesn't add anything.",
      "created_at": "2020-10-31T21:56:20Z",
      "updated_at": "2020-10-31T22:40:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515544378",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515544378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 18,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515544398",
      "pull_request_review_id": 521173701,
      "id": 515544398,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NDM5OA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.",
      "path": "bip-0324.mediawiki",
      "position": 14,
      "original_position": 14,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Inconsistent hyphenation in peer-to-peer",
      "created_at": "2020-10-31T21:56:37Z",
      "updated_at": "2020-10-31T22:40:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515544398",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515544398"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515544602",
      "pull_request_review_id": 521173701,
      "id": 515544602,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NDYwMg==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.",
      "path": "bip-0324.mediawiki",
      "position": 24,
      "original_position": 24,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be nice if there were some rough figures referenced here, maybe in seconds per byte?",
      "created_at": "2020-10-31T21:59:02Z",
      "updated_at": "2020-10-31T22:40:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515544602",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515544602"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515544931",
      "pull_request_review_id": 521173701,
      "id": 515544931,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NDkzMQ==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.",
      "path": "bip-0324.mediawiki",
      "position": 28,
      "original_position": 28,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why invoke OSI? It is not clear what is deep in OSI. Apparently it is anything that can wrap the Bitcoin P2P protocol. But such a protocol could also leverage the application layer. I think it would be better to just say it can wrap Bitcoin.",
      "created_at": "2020-10-31T22:02:18Z",
      "updated_at": "2020-10-31T22:40:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515544931",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515544931"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 28,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545417",
      "pull_request_review_id": 521173701,
      "id": 515545417,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NTQxNw==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.",
      "path": "bip-0324.mediawiki",
      "position": 58,
      "original_position": 58,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Before you connect, you can't know whether the node supports V2. Why not say \"maintain\" instead of \"make\"?\r\n\r\nWhy is \"peers\" plural here, when it is singular above? An implementer of this BIP will write node software for a single peer, so I think singular works better. Better use plural for the other nodes.",
      "created_at": "2020-10-31T22:07:30Z",
      "updated_at": "2020-10-31T22:40:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515545417",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545450",
      "pull_request_review_id": 521173701,
      "id": 515545450,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NTQ1MA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |",
      "path": "bip-0324.mediawiki",
      "position": 67,
      "original_position": 67,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What does HDATA stand for?",
      "created_at": "2020-10-31T22:07:54Z",
      "updated_at": "2020-10-31T22:40:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515545450",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545561",
      "pull_request_review_id": 521173701,
      "id": 515545561,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NTU2MQ==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.",
      "path": "bip-0324.mediawiki",
      "position": 83,
      "original_position": 83,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What does it mean to recalculate after negating?",
      "created_at": "2020-10-31T22:09:11Z",
      "updated_at": "2020-10-31T22:40:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515545561",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 83,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545622",
      "pull_request_review_id": 521173701,
      "id": 515545622,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NTYyMg==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.",
      "path": "bip-0324.mediawiki",
      "position": 86,
      "original_position": 86,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "32byte without spacing or hyphenation is weird.",
      "created_at": "2020-10-31T22:09:30Z",
      "updated_at": "2020-10-31T22:40:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515545622",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545622"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545666",
      "pull_request_review_id": 521173701,
      "id": 515545666,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NTY2Ng==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);",
      "path": "bip-0324.mediawiki",
      "position": 97,
      "original_position": 97,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would be good to specify that this indexing is inclusive, since not all languages work like that.",
      "created_at": "2020-10-31T22:09:57Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515545666",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545666"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 97,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545944",
      "pull_request_review_id": 521173701,
      "id": 515545944,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NTk0NA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.",
      "path": "bip-0324.mediawiki",
      "position": 88,
      "original_position": 88,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "here you hyphenate ephemeral-key, but above it is written without the hyphen but with a space",
      "created_at": "2020-10-31T22:12:58Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515545944",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545997",
      "pull_request_review_id": 521173701,
      "id": 515545997,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NTk5Nw==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.",
      "path": "bip-0324.mediawiki",
      "position": 86,
      "original_position": 86,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "what does \"pure\" mean? seems like this is the only place you use that term.",
      "created_at": "2020-10-31T22:13:37Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515545997",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515545997"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515546014",
      "pull_request_review_id": 521173701,
      "id": 515546014,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NjAxNA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.",
      "path": "bip-0324.mediawiki",
      "position": 102,
      "original_position": 102,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "is it necessary to use \"will\" here? Can't one of the capitalized RFC verbs be used?",
      "created_at": "2020-10-31T22:13:53Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515546014",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515546014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515546601",
      "pull_request_review_id": 521173701,
      "id": 515546601,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NjYwMQ==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.",
      "path": "bip-0324.mediawiki",
      "position": 109,
      "original_position": 109,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I suggest changing plural for singular. \r\n\r\nIf it is a MAY there is no need to say \"optionally\". Also, I don't think you can say \"detecting by\". Maybe a native speaker like @jnewbery can chime in. I'd suggest \"allow unencrypted v1 communication after detecting a v1 version message with its 11 byte prefix `4byte net magic || \"version\"`",
      "created_at": "2020-10-31T22:19:53Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515546601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515546601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515546879",
      "pull_request_review_id": 521173701,
      "id": 515546879,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0Njg3OQ==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:",
      "path": "bip-0324.mediawiki",
      "position": 113,
      "original_position": 113,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "* \"Once the secret is calculated on each side\" -> \"Once the secret has been calculated on both sides\"\r\n* \"with HKDF\" -> \"with the HKDF\"\r\n* \"after the following specification\" -> \"using the following specification\"\r\n\r\nThese are just my suggestions, I think it is easier to read but a native speaker like @jnewbery could confirm.",
      "created_at": "2020-10-31T22:23:20Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515546879",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515546879"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 113,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515546910",
      "pull_request_review_id": 521173701,
      "id": 515546910,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NjkxMA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).",
      "path": "bip-0324.mediawiki",
      "position": 140,
      "original_position": 140,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "openSSH -> OpenSSH.\r\n\r\nWhat does the ampersand mean?\r\n\r\nI think the x is multiplication, but I'd suggest just spelling it out instead: \"21 times 3 is less than 64\".",
      "created_at": "2020-10-31T22:23:41Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515546910",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515546910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 140,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547214",
      "pull_request_review_id": 521173701,
      "id": 515547214,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NzIxNA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).\n+\n+ChaCha20 is a stream cipher designed by Daniel Bernstein and described in <ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.",
      "path": "bip-0324.mediawiki",
      "position": 142,
      "original_position": 142,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"any unused bytes simply discarded\" -> \"unused bytes discarded\".\r\n\r\n\"128 or 256 bits\". Surely this must be fixed for the purposes of this spec? If one of these configurations is unused in this BIP, maybe it would be nice to explain which one it is. If they can somehow both be used, it would be nice with a pointer to the section where this is selected.",
      "created_at": "2020-10-31T22:27:31Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515547214",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 142,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547478",
      "pull_request_review_id": 521173701,
      "id": 515547478,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NzQ3OA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).\n+\n+ChaCha20 is a stream cipher designed by Daniel Bernstein and described in <ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.\n+\n+Poly1305 <ref>[http://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>, also by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit integrity tag given a message and a single-use 256 bit secret key.\n+\n+The chacha20-poly1305@bitcoin combines these two primitives into an authenticated encryption mode. The construction used is based on that proposed for TLS by Adam Langley in <ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs in the layout of data passed to the MAC and in the addition of encryption of the packet lengths.",
      "path": "bip-0324.mediawiki",
      "position": 146,
      "original_position": 146,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I suggest \"The construction is based on a proposal for TLS\".\r\n\r\nWhen you say \"in addition\", I think you mean that this is yet another difference. But since this is a text using mathematics, I think it would be better to avoid this phrasing and instead say \"..., but differs in the layout of the data passed to the MAC. It also encrypts the packet lengths differently.\"",
      "created_at": "2020-10-31T22:31:02Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515547478",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547478"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 146,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547669",
      "pull_request_review_id": 521173701,
      "id": 515547669,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NzY2OQ==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).\n+\n+ChaCha20 is a stream cipher designed by Daniel Bernstein and described in <ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.\n+\n+Poly1305 <ref>[http://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>, also by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit integrity tag given a message and a single-use 256 bit secret key.\n+\n+The chacha20-poly1305@bitcoin combines these two primitives into an authenticated encryption mode. The construction used is based on that proposed for TLS by Adam Langley in <ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs in the layout of data passed to the MAC and in the addition of encryption of the packet lengths.\n+\n+==== Detailed Construction ====\n+\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as output from the key exchange. Each key (K_1 and K_2) are used by two separate instances of chacha20.\n+\n+The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3 byte packet length field and has its own sequence number. The second instance, keyed by K_2, is used in conjunction with poly1305 to build an AEAD (Authenticated Encryption with Associated Data) that is used to encrypt and authenticate the entire packet.\n+\n+Two separate cipher instances are used here so as to keep the packet lengths confidential (best effort; for passive observing) but not create an oracle for the packet payload cipher by decrypting and using the packet length prior to checking the MAC. By using an independently-keyed cipher instance to encrypt the length, an active attacker seeking to exploit the packet input handling as a decryption oracle can learn nothing about the payload contents or its MAC (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers can still obtain the message length (ex. active ciphertext bit flipping or traffic shemantics analysis)",
      "path": "bip-0324.mediawiki",
      "position": 154,
      "original_position": 154,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I suggest \"e.g.\" instead of \"ex.\". \"Shematics\" is not a word. Do you mean \"schematics\" or \"semantics\"?",
      "created_at": "2020-10-31T22:33:08Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515547669",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547669"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 154,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547782",
      "pull_request_review_id": 521173701,
      "id": 515547782,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0Nzc4Mg==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).\n+\n+ChaCha20 is a stream cipher designed by Daniel Bernstein and described in <ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.\n+\n+Poly1305 <ref>[http://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>, also by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit integrity tag given a message and a single-use 256 bit secret key.\n+\n+The chacha20-poly1305@bitcoin combines these two primitives into an authenticated encryption mode. The construction used is based on that proposed for TLS by Adam Langley in <ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs in the layout of data passed to the MAC and in the addition of encryption of the packet lengths.\n+\n+==== Detailed Construction ====\n+\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as output from the key exchange. Each key (K_1 and K_2) are used by two separate instances of chacha20.\n+\n+The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3 byte packet length field and has its own sequence number. The second instance, keyed by K_2, is used in conjunction with poly1305 to build an AEAD (Authenticated Encryption with Associated Data) that is used to encrypt and authenticate the entire packet.\n+\n+Two separate cipher instances are used here so as to keep the packet lengths confidential (best effort; for passive observing) but not create an oracle for the packet payload cipher by decrypting and using the packet length prior to checking the MAC. By using an independently-keyed cipher instance to encrypt the length, an active attacker seeking to exploit the packet input handling as a decryption oracle can learn nothing about the payload contents or its MAC (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers can still obtain the message length (ex. active ciphertext bit flipping or traffic shemantics analysis)\n+\n+The AEAD is constructed as follows: for each packet, generate a Poly1305 key by taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20 block counter of zero. The K_2 ChaCha20 block counter is then set to the little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance is used for encryption of the packet payload.\n+\n+==== Packet Handling ====\n+\n+When receiving a packet, the length must be decrypted first. When 3 bytes of ciphertext length have been received, they may be decrypted.\n+\n+A ChaCha20 round always calculates 64bytes which is sufficient to encrypt a 3 bytes length field 21 times (21*3 = 63). The length field sequence number can thus be used 21 times (keystream caching).",
      "path": "bip-0324.mediawiki",
      "position": 162,
      "original_position": 162,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Here you use `*` for multiplication, it should be consistent with the other inline formulas. I suggest using full English words so that it is clear.",
      "created_at": "2020-10-31T22:34:28Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515547782",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 162,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547905",
      "pull_request_review_id": 521173701,
      "id": 515547905,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NzkwNQ==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).\n+\n+ChaCha20 is a stream cipher designed by Daniel Bernstein and described in <ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.\n+\n+Poly1305 <ref>[http://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>, also by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit integrity tag given a message and a single-use 256 bit secret key.\n+\n+The chacha20-poly1305@bitcoin combines these two primitives into an authenticated encryption mode. The construction used is based on that proposed for TLS by Adam Langley in <ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs in the layout of data passed to the MAC and in the addition of encryption of the packet lengths.\n+\n+==== Detailed Construction ====\n+\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as output from the key exchange. Each key (K_1 and K_2) are used by two separate instances of chacha20.\n+\n+The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3 byte packet length field and has its own sequence number. The second instance, keyed by K_2, is used in conjunction with poly1305 to build an AEAD (Authenticated Encryption with Associated Data) that is used to encrypt and authenticate the entire packet.\n+\n+Two separate cipher instances are used here so as to keep the packet lengths confidential (best effort; for passive observing) but not create an oracle for the packet payload cipher by decrypting and using the packet length prior to checking the MAC. By using an independently-keyed cipher instance to encrypt the length, an active attacker seeking to exploit the packet input handling as a decryption oracle can learn nothing about the payload contents or its MAC (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers can still obtain the message length (ex. active ciphertext bit flipping or traffic shemantics analysis)\n+\n+The AEAD is constructed as follows: for each packet, generate a Poly1305 key by taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20 block counter of zero. The K_2 ChaCha20 block counter is then set to the little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance is used for encryption of the packet payload.\n+\n+==== Packet Handling ====\n+\n+When receiving a packet, the length must be decrypted first. When 3 bytes of ciphertext length have been received, they may be decrypted.\n+\n+A ChaCha20 round always calculates 64bytes which is sufficient to encrypt a 3 bytes length field 21 times (21*3 = 63). The length field sequence number can thus be used 21 times (keystream caching).\n+\n+The length field must be enc-/decrypted with the ChaCha20 keystream keyed with K_1 defined by block counter 0, the length field sequence number in little endian and a keystream position from 0 to 60.",
      "path": "bip-0324.mediawiki",
      "position": 164,
      "original_position": 164,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I suggest replacing \"enc-/decrypted\" with \"encrypted/decrypted\".\r\n\r\n'Little endian\" is not hyphenated the same as above.",
      "created_at": "2020-10-31T22:35:39Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515547905",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515547905"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 164,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548035",
      "pull_request_review_id": 521173701,
      "id": 515548035,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0ODAzNQ==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).\n+\n+ChaCha20 is a stream cipher designed by Daniel Bernstein and described in <ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.\n+\n+Poly1305 <ref>[http://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>, also by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit integrity tag given a message and a single-use 256 bit secret key.\n+\n+The chacha20-poly1305@bitcoin combines these two primitives into an authenticated encryption mode. The construction used is based on that proposed for TLS by Adam Langley in <ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs in the layout of data passed to the MAC and in the addition of encryption of the packet lengths.\n+\n+==== Detailed Construction ====\n+\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as output from the key exchange. Each key (K_1 and K_2) are used by two separate instances of chacha20.\n+\n+The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3 byte packet length field and has its own sequence number. The second instance, keyed by K_2, is used in conjunction with poly1305 to build an AEAD (Authenticated Encryption with Associated Data) that is used to encrypt and authenticate the entire packet.\n+\n+Two separate cipher instances are used here so as to keep the packet lengths confidential (best effort; for passive observing) but not create an oracle for the packet payload cipher by decrypting and using the packet length prior to checking the MAC. By using an independently-keyed cipher instance to encrypt the length, an active attacker seeking to exploit the packet input handling as a decryption oracle can learn nothing about the payload contents or its MAC (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers can still obtain the message length (ex. active ciphertext bit flipping or traffic shemantics analysis)\n+\n+The AEAD is constructed as follows: for each packet, generate a Poly1305 key by taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20 block counter of zero. The K_2 ChaCha20 block counter is then set to the little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance is used for encryption of the packet payload.\n+\n+==== Packet Handling ====\n+\n+When receiving a packet, the length must be decrypted first. When 3 bytes of ciphertext length have been received, they may be decrypted.\n+\n+A ChaCha20 round always calculates 64bytes which is sufficient to encrypt a 3 bytes length field 21 times (21*3 = 63). The length field sequence number can thus be used 21 times (keystream caching).\n+\n+The length field must be enc-/decrypted with the ChaCha20 keystream keyed with K_1 defined by block counter 0, the length field sequence number in little endian and a keystream position from 0 to 60.\n+\n+Pseudo code example:\n+<pre>\n+// init\n+sequence_nr_payload = 0; //payload sequence number\n+sequence_nr_length_field = 0; //length field sequence number (will be reused)\n+aad_length_field_pos = 0; //position in the length field cipher instance keystream chunk\n+\n+...\n+\n+// actual encryption\n+if cache_length_field_sequence_number != sequence_nr_length_field {\n+  cache_keystream_64_bytes = ChaCha20(key=K_1, iv=little_endian(sequence_nr_length_field), counter=0);\n+  cache_length_field_sequence_number = sequence_nr_length_field\n+}\n+packet_length = XOR_TO_LE(cache_length_field_sequence_number[aad_length_field_pos - aad_length_field_pos+3], ciphertext[0-3])\n+\n+sequence_nr_payload++;\n+aad_length_field_pos += 3; //skip 3 bytes in keystream\n+if (aad_length_field_pos + 3 > 64) { //if we are outside of the 64byte keystream...\n+  aad_length_field_pos = 0; // reset at position 0\n+  sequence_nr_length_field++; // increase length field sequence number\n+}\n+</pre>\n+\n+Once the entire packet has been received, the MAC MUST be checked before decryption. A per-packet Poly1305 key is generated as described above and the MAC tag is calculated using Poly1305 with this key over the ciphertext of the packet length and the payload together. The calculated MAC is then compared in constant time with the one appended to the packet and the packet decrypted using ChaCha20 as described above (with K_2, the packet sequence number as nonce and a starting block counter of 1).\n+\n+Detection of an invalid MAC MUST lead to immediate connection termination.\n+\n+To send a packet, first encode the 3 byte length and encrypt it using K_1 as described above. Encrypt the packet payload (using K_2) and append it to the encrypted length. Finally, calculate a MAC tag and append it.\n+\n+The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on the receive channel.\n+\n+The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages on the send channel.\n+\n+Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast, therefore it is very likely that encrypted messages will not require additional CPU cycles per byte when compared to the current unencrypted p2p message format (ChaCha20/Poly1305 versus double SHA256).\n+\n+The initial packet sequence numbers are 0.",
      "path": "bip-0324.mediawiki",
      "position": 202,
      "original_position": 202,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Since there is only one initial element of anything, I suggest using singular.",
      "created_at": "2020-10-31T22:37:05Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515548035",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 202,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548098",
      "pull_request_review_id": 521173701,
      "id": 515548098,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0ODA5OA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).\n+\n+ChaCha20 is a stream cipher designed by Daniel Bernstein and described in <ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.\n+\n+Poly1305 <ref>[http://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>, also by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit integrity tag given a message and a single-use 256 bit secret key.\n+\n+The chacha20-poly1305@bitcoin combines these two primitives into an authenticated encryption mode. The construction used is based on that proposed for TLS by Adam Langley in <ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs in the layout of data passed to the MAC and in the addition of encryption of the packet lengths.\n+\n+==== Detailed Construction ====\n+\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as output from the key exchange. Each key (K_1 and K_2) are used by two separate instances of chacha20.\n+\n+The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3 byte packet length field and has its own sequence number. The second instance, keyed by K_2, is used in conjunction with poly1305 to build an AEAD (Authenticated Encryption with Associated Data) that is used to encrypt and authenticate the entire packet.\n+\n+Two separate cipher instances are used here so as to keep the packet lengths confidential (best effort; for passive observing) but not create an oracle for the packet payload cipher by decrypting and using the packet length prior to checking the MAC. By using an independently-keyed cipher instance to encrypt the length, an active attacker seeking to exploit the packet input handling as a decryption oracle can learn nothing about the payload contents or its MAC (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers can still obtain the message length (ex. active ciphertext bit flipping or traffic shemantics analysis)\n+\n+The AEAD is constructed as follows: for each packet, generate a Poly1305 key by taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20 block counter of zero. The K_2 ChaCha20 block counter is then set to the little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance is used for encryption of the packet payload.\n+\n+==== Packet Handling ====\n+\n+When receiving a packet, the length must be decrypted first. When 3 bytes of ciphertext length have been received, they may be decrypted.\n+\n+A ChaCha20 round always calculates 64bytes which is sufficient to encrypt a 3 bytes length field 21 times (21*3 = 63). The length field sequence number can thus be used 21 times (keystream caching).\n+\n+The length field must be enc-/decrypted with the ChaCha20 keystream keyed with K_1 defined by block counter 0, the length field sequence number in little endian and a keystream position from 0 to 60.\n+\n+Pseudo code example:\n+<pre>\n+// init\n+sequence_nr_payload = 0; //payload sequence number\n+sequence_nr_length_field = 0; //length field sequence number (will be reused)\n+aad_length_field_pos = 0; //position in the length field cipher instance keystream chunk\n+\n+...\n+\n+// actual encryption\n+if cache_length_field_sequence_number != sequence_nr_length_field {\n+  cache_keystream_64_bytes = ChaCha20(key=K_1, iv=little_endian(sequence_nr_length_field), counter=0);\n+  cache_length_field_sequence_number = sequence_nr_length_field\n+}\n+packet_length = XOR_TO_LE(cache_length_field_sequence_number[aad_length_field_pos - aad_length_field_pos+3], ciphertext[0-3])\n+\n+sequence_nr_payload++;\n+aad_length_field_pos += 3; //skip 3 bytes in keystream\n+if (aad_length_field_pos + 3 > 64) { //if we are outside of the 64byte keystream...\n+  aad_length_field_pos = 0; // reset at position 0\n+  sequence_nr_length_field++; // increase length field sequence number\n+}\n+</pre>\n+\n+Once the entire packet has been received, the MAC MUST be checked before decryption. A per-packet Poly1305 key is generated as described above and the MAC tag is calculated using Poly1305 with this key over the ciphertext of the packet length and the payload together. The calculated MAC is then compared in constant time with the one appended to the packet and the packet decrypted using ChaCha20 as described above (with K_2, the packet sequence number as nonce and a starting block counter of 1).\n+\n+Detection of an invalid MAC MUST lead to immediate connection termination.\n+\n+To send a packet, first encode the 3 byte length and encrypt it using K_1 as described above. Encrypt the packet payload (using K_2) and append it to the encrypted length. Finally, calculate a MAC tag and append it.\n+\n+The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on the receive channel.\n+\n+The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages on the send channel.\n+\n+Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast, therefore it is very likely that encrypted messages will not require additional CPU cycles per byte when compared to the current unencrypted p2p message format (ChaCha20/Poly1305 versus double SHA256).\n+\n+The initial packet sequence numbers are 0.\n+\n+K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for encryption nor may it be used to encrypt more than 2^70 bytes under the same {key, nonce}.\n+\n+K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce, position-in-keystream} for encryption nor may it be used to encrypt more than 2^70 bytes under the same {key, nonce}.\n+\n+We use message sequence numbers for both communication directions.\n+\n+<pre>\n+ ------------------------------------------------------------------------------------------\n+ | Initiator                          Responder                                           |\n+ |                                                                                        |\n+ | AEAD() = ChaCha20Poly1305Bitcoin()                                                     |\n+ | MSG_A_CIPH = AEAD(k=K_1_A, K_2_A, payload_nonce=0, aad_nonce=0, aad_pos=0, msg)        |\n+ |                                                                                        |\n+ |                         --- MSG_CIPH --->                                              |\n+ |                                                                                        |\n+ |                                    msg   := AEAD(k=K_1_A,K_2_A, n=0, ..., MSG_A_CIPH)  |\n+ |                                                                                        |\n+ ------------------------------------------------------------------------------------------\n+</pre>\n+\n+==== AEAD Test Vectors ====\n+\n+<pre>\n+message   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+k1 (DATA) 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+k2 (AAD)  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+\n+AAD keystream\n+76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28 bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7 da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37 6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86\n+\n+ciphertext\n+76 b8 e0 9f 07 e7 be 55 51 38 7a 98 ba 97 7c 73 2d 08 0d cb 0f 29 a0 48 e3 65 69 12 c6 53 3e 32\n+\n+MAC\n+d2 fc 11 82 9c 1b 6c 1d f1 f5 51 cd 61 31 ff 08\n+</pre>\n+\n+<pre>\n+message   01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+k1 (DATA) 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+k2 (AAD)  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+\n+AAD keystream\n+76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28 bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7 da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37 6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86\n+\n+ciphertext\n+77 b8 e0 9f 07 e7 be 55 51 38 7a 98 ba 97 7c 73 2d 08 0d cb 0f 29 a0 48 e3 65 69 12 c6 53 3e 32\n+\n+MAC\n+ba f0 c8 5b 6d ff 86 02 b0 6c f5 2a 6a ef c6 2e\n+</pre>\n+\n+<pre>\n+message\n+ff 00 00 f1 95 e6 69 82 10 5f fb 64 0b b7 75 7f 57 9d a3 16 02 fc 93 ec 01 ac 56 f8 5a c3 c1 34 a4 54 7b 73 3b 46 41 30 42 c9 44 00 49 17 69 05 d3 be 59 ea 1c 53 f1 59 16 15 5c 2b e8 24 1a 38 00 8b 9a 26 bc 35 94 1e 24 44 17 7c 8a de 66 89 de 95 26 49 86 d9 58 89 fb 60 e8 46 29 c9 bd 9a 5a cb 1c c1 18 be 56 3e b9 b3 a4 a4 72 f8 2e 09 a7 e7 78 49 2b 56 2e f7 13 0e 88 df e0 31 c7 9d b9 d4 f7 c7 a8 99 15 1b 9a 47 50 32 b6 3f c3 85 24 5f e0 54 e3 dd 5a 97 a5 f5 76 fe 06 40 25 d3 ce 04 2c 56 6a b2 c5 07 b1 38 db 85 3e 3d 69 59 66 09 96 54 6c c9 c4 a6 ea fd c7 77 c0 40 d7 0e af 46 f7 6d ad 39 79 e5 c5 36 0c 33 17 16 6a 1c 89 4c 94 a3 71 87 6a 94 df 76 28 fe 4e aa f2 cc b2 7d 5a aa e0 ad 7a d0 f9 d4 b6 ad 3b 54 09 87 46 d4 52 4d 38 40 7a 6d eb 3a b7 8f ab 78 c9\n+\n+k1 (DATA) 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f\n+k2 (AAD)  ff 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f\n+\n+AAD keystream\n+c6 40 c1 71 1e 3e e9 04 ac 35 c5 7a b9 79 1c 8a 1c 40 86 03 a9 0b 77 a8 3b 54 f6 c8 44 cb 4b 06 d9 4e 7f c6 c8 00 e1 65 ac d6 61 47 e8 0e c4 5a 56 7f 6c e6 6d 05 ec 0c ae 67 9d ce eb 89 00 17\n+\n+ciphertext\n+39 40 c1 e9 2d a4 58 2f f6 f9 2a 77 6a eb 14 d0 14 d3 84 ee b3 0f 66 0d ac f7 0a 14 a2 3f d3 1e 91 21 27 01 33 4e 2c e1 ac f5 19 9d c8 4f 4d 61 dd be 65 71 bc a5 af 87 4b 4c 92 26 c2 6e 65 09 95 d1 57 64 4e 18 48 b9 6e d6 c2 10 2d 54 89 a0 50 e7 1d 29 a5 a6 6e ce 11 de 5f b5 c9 55 8d 54 da 28 fe 45 b0 bc 4d b4 e5 b8 80 30 bf c4 a3 52 b4 b7 06 8e cc f6 56 ba e7 ad 6a 35 61 53 15 fc 7c 49 d4 20 03 88 d5 ec a6 7c 2e 82 2e 06 93 36 c6 9b 40 db 67 e0 f3 c8 12 09 c5 0f 32 16 a4 b8 9f b3 ae 1b 98 4b 78 51 a2 ec 6f 68 ab 12 b1 01 ab 12 0e 1e a7 31 3b b9 3b 5a 0f 71 18 5c 7f ea 01 7d db 92 76 98 61 c2 9d ba 4f bc 43 22 80 d5 df f2 1b 36 d1 c4 c7 90 12 8b 22 69 99 50 bb 18 bf 74 c4 48 cd fe 54 7d 8e d4 f6 57 d8 00 5f dc 0c d7 a0 50 c2 d4 60 50 a4 4c 43 76 35 58 58 \n+\n+MAC\n+98 1f be 8b 18 42 88 27 6e 7a 93 ea bc 89 9c 4a\n+</pre>\n+\n+\n+=== v2 Messages Structure ===\n+\n+{|class=\"wikitable\"\n+! Field Size !! Description !! Data type !! Comments\n+|-\n+| 3 || length & flag || 23 + 1 bits || Encrypted length of ciphertext payload (not counting the MAC tag) in number of bytes (only 2^23 is usable, most significant bit is the rekey-flag)\n+|-\n+| 1-13 || encrypted message-type || variable || ASCII message-type (or one byte message-type-ID)\n+|-\n+| ? || encrypted payload || ? || The actual data\n+|-\n+| 16 || MAC tag || ? || 128bit MAC-tag\n+|}\n+\n+Encrypted messages do not have the 4byte network magic.\n+\n+The maximum message size is 2^23 (8,388,608) bytes. Future communication MAY exceed this limit and thus MUST be split into different messages.",
      "path": "bip-0324.mediawiki",
      "position": 290,
      "original_position": 290,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To make it clear that this is not xor, one could spell out \"to the power of\".",
      "created_at": "2020-10-31T22:37:55Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515548098",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 290,
      "original_line": 290,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548147",
      "pull_request_review_id": 521173701,
      "id": 515548147,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0ODE0Nw==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).\n+\n+ChaCha20 is a stream cipher designed by Daniel Bernstein and described in <ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.\n+\n+Poly1305 <ref>[http://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>, also by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit integrity tag given a message and a single-use 256 bit secret key.\n+\n+The chacha20-poly1305@bitcoin combines these two primitives into an authenticated encryption mode. The construction used is based on that proposed for TLS by Adam Langley in <ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs in the layout of data passed to the MAC and in the addition of encryption of the packet lengths.\n+\n+==== Detailed Construction ====\n+\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as output from the key exchange. Each key (K_1 and K_2) are used by two separate instances of chacha20.\n+\n+The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3 byte packet length field and has its own sequence number. The second instance, keyed by K_2, is used in conjunction with poly1305 to build an AEAD (Authenticated Encryption with Associated Data) that is used to encrypt and authenticate the entire packet.\n+\n+Two separate cipher instances are used here so as to keep the packet lengths confidential (best effort; for passive observing) but not create an oracle for the packet payload cipher by decrypting and using the packet length prior to checking the MAC. By using an independently-keyed cipher instance to encrypt the length, an active attacker seeking to exploit the packet input handling as a decryption oracle can learn nothing about the payload contents or its MAC (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers can still obtain the message length (ex. active ciphertext bit flipping or traffic shemantics analysis)\n+\n+The AEAD is constructed as follows: for each packet, generate a Poly1305 key by taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20 block counter of zero. The K_2 ChaCha20 block counter is then set to the little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance is used for encryption of the packet payload.\n+\n+==== Packet Handling ====\n+\n+When receiving a packet, the length must be decrypted first. When 3 bytes of ciphertext length have been received, they may be decrypted.\n+\n+A ChaCha20 round always calculates 64bytes which is sufficient to encrypt a 3 bytes length field 21 times (21*3 = 63). The length field sequence number can thus be used 21 times (keystream caching).\n+\n+The length field must be enc-/decrypted with the ChaCha20 keystream keyed with K_1 defined by block counter 0, the length field sequence number in little endian and a keystream position from 0 to 60.\n+\n+Pseudo code example:\n+<pre>\n+// init\n+sequence_nr_payload = 0; //payload sequence number\n+sequence_nr_length_field = 0; //length field sequence number (will be reused)\n+aad_length_field_pos = 0; //position in the length field cipher instance keystream chunk\n+\n+...\n+\n+// actual encryption\n+if cache_length_field_sequence_number != sequence_nr_length_field {\n+  cache_keystream_64_bytes = ChaCha20(key=K_1, iv=little_endian(sequence_nr_length_field), counter=0);\n+  cache_length_field_sequence_number = sequence_nr_length_field\n+}\n+packet_length = XOR_TO_LE(cache_length_field_sequence_number[aad_length_field_pos - aad_length_field_pos+3], ciphertext[0-3])\n+\n+sequence_nr_payload++;\n+aad_length_field_pos += 3; //skip 3 bytes in keystream\n+if (aad_length_field_pos + 3 > 64) { //if we are outside of the 64byte keystream...\n+  aad_length_field_pos = 0; // reset at position 0\n+  sequence_nr_length_field++; // increase length field sequence number\n+}\n+</pre>\n+\n+Once the entire packet has been received, the MAC MUST be checked before decryption. A per-packet Poly1305 key is generated as described above and the MAC tag is calculated using Poly1305 with this key over the ciphertext of the packet length and the payload together. The calculated MAC is then compared in constant time with the one appended to the packet and the packet decrypted using ChaCha20 as described above (with K_2, the packet sequence number as nonce and a starting block counter of 1).\n+\n+Detection of an invalid MAC MUST lead to immediate connection termination.\n+\n+To send a packet, first encode the 3 byte length and encrypt it using K_1 as described above. Encrypt the packet payload (using K_2) and append it to the encrypted length. Finally, calculate a MAC tag and append it.\n+\n+The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on the receive channel.\n+\n+The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages on the send channel.\n+\n+Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast, therefore it is very likely that encrypted messages will not require additional CPU cycles per byte when compared to the current unencrypted p2p message format (ChaCha20/Poly1305 versus double SHA256).\n+\n+The initial packet sequence numbers are 0.\n+\n+K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for encryption nor may it be used to encrypt more than 2^70 bytes under the same {key, nonce}.\n+\n+K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce, position-in-keystream} for encryption nor may it be used to encrypt more than 2^70 bytes under the same {key, nonce}.\n+\n+We use message sequence numbers for both communication directions.\n+\n+<pre>\n+ ------------------------------------------------------------------------------------------\n+ | Initiator                          Responder                                           |\n+ |                                                                                        |\n+ | AEAD() = ChaCha20Poly1305Bitcoin()                                                     |\n+ | MSG_A_CIPH = AEAD(k=K_1_A, K_2_A, payload_nonce=0, aad_nonce=0, aad_pos=0, msg)        |\n+ |                                                                                        |\n+ |                         --- MSG_CIPH --->                                              |\n+ |                                                                                        |\n+ |                                    msg   := AEAD(k=K_1_A,K_2_A, n=0, ..., MSG_A_CIPH)  |\n+ |                                                                                        |\n+ ------------------------------------------------------------------------------------------\n+</pre>\n+\n+==== AEAD Test Vectors ====\n+\n+<pre>\n+message   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+k1 (DATA) 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+k2 (AAD)  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+\n+AAD keystream\n+76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28 bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7 da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37 6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86\n+\n+ciphertext\n+76 b8 e0 9f 07 e7 be 55 51 38 7a 98 ba 97 7c 73 2d 08 0d cb 0f 29 a0 48 e3 65 69 12 c6 53 3e 32\n+\n+MAC\n+d2 fc 11 82 9c 1b 6c 1d f1 f5 51 cd 61 31 ff 08\n+</pre>\n+\n+<pre>\n+message   01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+k1 (DATA) 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+k2 (AAD)  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+\n+AAD keystream\n+76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28 bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7 da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37 6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86\n+\n+ciphertext\n+77 b8 e0 9f 07 e7 be 55 51 38 7a 98 ba 97 7c 73 2d 08 0d cb 0f 29 a0 48 e3 65 69 12 c6 53 3e 32\n+\n+MAC\n+ba f0 c8 5b 6d ff 86 02 b0 6c f5 2a 6a ef c6 2e\n+</pre>\n+\n+<pre>\n+message\n+ff 00 00 f1 95 e6 69 82 10 5f fb 64 0b b7 75 7f 57 9d a3 16 02 fc 93 ec 01 ac 56 f8 5a c3 c1 34 a4 54 7b 73 3b 46 41 30 42 c9 44 00 49 17 69 05 d3 be 59 ea 1c 53 f1 59 16 15 5c 2b e8 24 1a 38 00 8b 9a 26 bc 35 94 1e 24 44 17 7c 8a de 66 89 de 95 26 49 86 d9 58 89 fb 60 e8 46 29 c9 bd 9a 5a cb 1c c1 18 be 56 3e b9 b3 a4 a4 72 f8 2e 09 a7 e7 78 49 2b 56 2e f7 13 0e 88 df e0 31 c7 9d b9 d4 f7 c7 a8 99 15 1b 9a 47 50 32 b6 3f c3 85 24 5f e0 54 e3 dd 5a 97 a5 f5 76 fe 06 40 25 d3 ce 04 2c 56 6a b2 c5 07 b1 38 db 85 3e 3d 69 59 66 09 96 54 6c c9 c4 a6 ea fd c7 77 c0 40 d7 0e af 46 f7 6d ad 39 79 e5 c5 36 0c 33 17 16 6a 1c 89 4c 94 a3 71 87 6a 94 df 76 28 fe 4e aa f2 cc b2 7d 5a aa e0 ad 7a d0 f9 d4 b6 ad 3b 54 09 87 46 d4 52 4d 38 40 7a 6d eb 3a b7 8f ab 78 c9\n+\n+k1 (DATA) 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f\n+k2 (AAD)  ff 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f\n+\n+AAD keystream\n+c6 40 c1 71 1e 3e e9 04 ac 35 c5 7a b9 79 1c 8a 1c 40 86 03 a9 0b 77 a8 3b 54 f6 c8 44 cb 4b 06 d9 4e 7f c6 c8 00 e1 65 ac d6 61 47 e8 0e c4 5a 56 7f 6c e6 6d 05 ec 0c ae 67 9d ce eb 89 00 17\n+\n+ciphertext\n+39 40 c1 e9 2d a4 58 2f f6 f9 2a 77 6a eb 14 d0 14 d3 84 ee b3 0f 66 0d ac f7 0a 14 a2 3f d3 1e 91 21 27 01 33 4e 2c e1 ac f5 19 9d c8 4f 4d 61 dd be 65 71 bc a5 af 87 4b 4c 92 26 c2 6e 65 09 95 d1 57 64 4e 18 48 b9 6e d6 c2 10 2d 54 89 a0 50 e7 1d 29 a5 a6 6e ce 11 de 5f b5 c9 55 8d 54 da 28 fe 45 b0 bc 4d b4 e5 b8 80 30 bf c4 a3 52 b4 b7 06 8e cc f6 56 ba e7 ad 6a 35 61 53 15 fc 7c 49 d4 20 03 88 d5 ec a6 7c 2e 82 2e 06 93 36 c6 9b 40 db 67 e0 f3 c8 12 09 c5 0f 32 16 a4 b8 9f b3 ae 1b 98 4b 78 51 a2 ec 6f 68 ab 12 b1 01 ab 12 0e 1e a7 31 3b b9 3b 5a 0f 71 18 5c 7f ea 01 7d db 92 76 98 61 c2 9d ba 4f bc 43 22 80 d5 df f2 1b 36 d1 c4 c7 90 12 8b 22 69 99 50 bb 18 bf 74 c4 48 cd fe 54 7d 8e d4 f6 57 d8 00 5f dc 0c d7 a0 50 c2 d4 60 50 a4 4c 43 76 35 58 58 \n+\n+MAC\n+98 1f be 8b 18 42 88 27 6e 7a 93 ea bc 89 9c 4a\n+</pre>\n+\n+\n+=== v2 Messages Structure ===\n+\n+{|class=\"wikitable\"\n+! Field Size !! Description !! Data type !! Comments\n+|-\n+| 3 || length & flag || 23 + 1 bits || Encrypted length of ciphertext payload (not counting the MAC tag) in number of bytes (only 2^23 is usable, most significant bit is the rekey-flag)\n+|-\n+| 1-13 || encrypted message-type || variable || ASCII message-type (or one byte message-type-ID)\n+|-\n+| ? || encrypted payload || ? || The actual data\n+|-\n+| 16 || MAC tag || ? || 128bit MAC-tag\n+|}\n+\n+Encrypted messages do not have the 4byte network magic.\n+\n+The maximum message size is 2^23 (8,388,608) bytes. Future communication MAY exceed this limit and thus MUST be split into different messages.\n+\n+Decrypting and processing the message MUST take place only AFTER successful authentication (MAC verification).\n+\n+The 4byte sha256 checksum is no longer required because the AEAD (MAC).\n+\n+Both peers MUST keep track of the message sequence numbers (uint32) of sent and received messages for building a 64-bit symmetric cipher IV.\n+\n+The message-type field MUST start with a byte that defines the length of the ASCII message-type string up to 12 chars (1 to 12) or a message-type-ID (see below).\n+\n+==== Message-Type-ID ====\n+\n+To save valuable bandwidth, the v2 message format supports message-type-IDs. The ID/string mapping is a peer to peer arrangement and MAY be negotiated between the initiating and responding peer. A peer conforming to this proposal MUST support message-type-IDs based on the table below and SHOULD use message-type-IDs for outgoing messages.\n+\n+{|class=\"wikitable\"\n+! Number !! Message Type\n+|-\n+| 13 || ADDR\n+|-\n+| 14 || BLOCK\n+|-\n+| 15 || BLOCKTXN\n+|-\n+| 16 || CMPCTBLOCK\n+|-\n+| 17 || FEEFILTER\n+|-\n+| 18 || FILTERADD\n+|-\n+| 19 || FILTERCLEAR\n+|-\n+| 20 || FILTERLOAD\n+|-\n+| 21 || GETADDR\n+|-\n+| 22 || GETBLOCKS\n+|-\n+| 23 || GETBLOCKTXN\n+|-\n+| 24 || GETDATA\n+|-\n+| 25 || GETHEADERS\n+|-\n+| 26 || HEADERS\n+|-\n+| 27 || INV\n+|-\n+| 28 || MEMPOOL\n+|-\n+| 29 || MERKLEBLOCK\n+|-\n+| 30 || NOTFOUND\n+|-\n+| 31 || PING\n+|-\n+| 32 || PONG\n+|-\n+| 33 || REJECT\n+|-\n+| 34 || SENDCMPCT\n+|-\n+| 35 || SENDHEADERS\n+|-\n+| 36 || TX\n+|-\n+| 37 || VERACK\n+|-\n+| 38 || VERSION\n+|-\n+| 39 || GETCFILTERS\n+|-\n+| 40 || CFILTER\n+|-\n+| 41 || GETCFHEADERS\n+|-\n+| 42 || CFHEADERS\n+|-\n+| 43 || GETCFCHECKPT\n+|-\n+| 44 || CFCHECKPT\n+|-\n+| 45 || WTXIDRELAY\n+|-\n+|}\n+\n+==== Length comparisons between v1 and v2 messages ====\n+\n+<pre>\n+v1 in: 4(Magic)+12(Message-Type)+4(MessageSize)+4(Checksum)+37(Payload) == 61\n+v2 inv: 3(MessageSize&Flag)+1(Message-Type)+37(Payload)+16(MAC) == 57\n+(93.44%)\n+</pre>\n+\n+<pre>\n+v1 ping: 4(Magic)+12(Message-Type)+4(MessageSize)+4(Checksum)+8(Payload) == 32\n+v2 pong: 3(MessageSize&Flag)+1(Message-Type)+8(Payload)+16(MAC) == 28\n+(87.5%)\n+</pre>\n+\n+<pre>\n+v1 block: 4(Magic)+12(Message-Type)+4(MessageSize)+4(Checksum)+1’048’576(Payload) = 1’048’600\n+v2 block: 3(MessageSize&Flag)+1(Message-Type)+1’048’576(Payload)+16(MAC) = 1’048’596\n+(99.9996%)\n+</pre>\n+\n+=== Re-Keying ===\n+\n+Re-keying can be signaled by setting the most significant bit in the length field before encryption. A peer signaling a rekey MUST use the next key for encrypted messages AFTER the message where the signaling has been done.\n+\n+A peer identifying a rekey by checking the most significant bit in the envelope length must use the next key to decrypt messages AFTER the message where the signaling has been detected.\n+\n+The next symmetric cipher key MUST be calculated by <code>SHA256(SHA256(session ID || old_symmetric_cipher_key))</code> and the packet sequence numbers of the corresponding encryption direction must be set to 0.\n+\n+Re-Keying interval is a peer policy with a minimum timespan of 10 seconds.\n+\n+The Re-Keying must be done after every 1GB of data sent (recommended by RFC4253 SSH Transport) or if the last rekey was more than an hour ago.\n+\n+Peers calculate the counterparty limits and MUST disconnect immediately if a violation of the limits has been detected.\n+\n+=== Test Vectors ===",
      "path": "bip-0324.mediawiki",
      "position": 409,
      "original_position": 409,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "why not put this in a CSV file so that it can easily be tested?",
      "created_at": "2020-10-31T22:38:48Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515548147",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548147"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 409,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548245",
      "pull_request_review_id": 521173701,
      "id": 515548245,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0ODI0NQ==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.",
      "path": "bip-0324.mediawiki",
      "position": 18,
      "original_position": 18,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe link to the section \"Length comparisons between v1 and v2 messages\" as a reference for the inefficiency.",
      "created_at": "2020-10-31T22:39:34Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515548245",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548245"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 18,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548284",
      "pull_request_review_id": 521173701,
      "id": 515548284,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0ODI4NA==",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+<pre>\n+  BIP: 324\n+  Layer: Peer Services\n+  Title: Version 2 Peer-to-Peer Message Transport Protocol\n+  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2019-03-08\n+  License: PD\n+</pre>\n+\n+== Abstract ==\n+\n+This BIP describes a new Bitcoin peer to peer transport protocol with opportunistic encryption.\n+\n+== Motivation ==\n+\n+The current peer-to-peer protocol is partially inefficient and in plaintext.\n+\n+With the current unencrypted message transport, BGP hijack, block delay attacks and message tampering are inexpensive and can be executed covertly (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A. Zohar, L.Vanbever]</ref>.\n+\n+Adding opportunistic encryption introduces a high risk for attackers of being detected. Peer operators can compare encryption session IDs or use other form of authentication schemes <ref name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki BIP150]</ref> to identify an attack.\n+\n+Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power would be required for encrypting and authenticating a peer-to-peer message with ChaCha20 & Poly1305.\n+\n+Additionally, this BIP describes a way to identify data which has been manipulated by peers (intercepting, then blocking or tampering with messages).\n+\n+Encrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most of those solutions require significant technical experience in setting up a secure channel and are therefore not widely deployed.\n+\n+== Specification ==\n+\n+<blockquote>\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n+\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\n+interpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n+</blockquote>\n+\n+A peer that supports the message transport protocol as defined in this proposal MUST accept encryption requests from all peers.\n+\n+Both communication directions share the same shared-secret but have different symmetric cipher keys.\n+\n+The encryption handshake MUST happen before sending any other messages to the responding peer.\n+\n+If the responding peer closes the connection after sending the handshake request, the initiating peer MAY try to connect again with the v1 peer-to-peer transport protocol. Such reconnects allow an attacker to \"downgrade\" the encryption to plaintext communication and thus, accepting v1 connections MUST not be done when the Bitcoin peer-to-peer network has almost entirely embraced v2 communication.\n+\n+\n+=== NODE_P2P_V2 ===\n+\n+Peers supporting the transport protocol after this proposal MUST signal <code>NODE_P2P_V2</code>\n+<pre>\n+NODE_P2P_V2 = (1 << 11)\n+</pre>\n+\n+A peer usually learns an address along with the expected service flags which MAY be used to filter possible outbound peers.\n+\n+A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication specified in this proposal.\n+\n+Peers MAY only make outbound connections to peers supporting <code>NODE_P2P_V2</code>.\n+\n+=== Handshake ===\n+\n+<pre>\n+ ----------------------------------------------------------------------------------------\n+ | Initiator                             Responder                                      |\n+ |                                                                                      |\n+ | x, X         := SECP256k1_KEYGEN()                                                   |\n+ | CLIENT_HDATA := X                                                                    |\n+ |                                                                                      |\n+ |               --- CLIENT_HDATA --->                                                  |\n+ |                                                                                      |\n+ |                                       y, Y           := SECP256k1_KEYGEN()           |\n+ |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n+ |                                       SERVER_HDATA   := Y                            |\n+ |                                                                                      |\n+ |               <-- SERVER_HDATA ----                                                  |\n+ |                                                                                      |\n+ | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n+ ----------------------------------------------------------------------------------------\n+</pre>\n+\n+To request encrypted communication (only possible if yet no other messages have been sent or received), the initiating peer generates an EC secp256k1 ephemeral key and sends the corresponding 32-byte public key to the responding peer and waits for the remote 32-byte public key from the counterparty.\n+\n+ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the public key from the generated ephemeral key is an EVEN public key (starting with 0x03), its public key SHOULD be negated and then recalculated.\n+Only using ODD public keys makes it more complex to identify the handshake based on analyzing the traffic.\n+\n+The handshake request and response message are raw 32byte payloads containing no header, length or checksum (the pure 32byte payload) and MUST be sent before anything else.\n+\n+Public keys starting with the 4-byte network magic are forbidden and MUST lead to local regeneration of an ephemeral-key.\n+\n+Pseudocode for the ephemeral-key generation\n+<pre>\n+do {\n+    ecdh_key.MakeNewKey();\n+    if (ecdh_key.GetPubKey()[0] == 3) {\n+        ecdh_key.Negate();\n+    }\n+} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n+</pre>\n+\n+Once a peer has received the public key from its counterparty, the shared secret MUST be calculated by using secp256k1 ECDH.\n+\n+Private keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the counterparty's public key. This key-exchange is based on the discrete log problem and thus not sufficiently strong against known forms of possible quantum computer algorithms. Adding an additional quantum resistant key exchange like NewHope is possible but out of scope for this proposal.\n+\n+After a successful handshake, messages MUST use the \"v2 messages structure\". Non-encrypted v1 messages from the initiating peer MUST lead to an immediate connection termination.\n+\n+After a successful handshake, both peers MUST wipe the ephemeral-session-key from memory and/or persistence storage.\n+\n+A peer not supporting this proposal will not perform the described handshake and thus send a v1 version message.\n+Peers supporting this BIP MAY optionally allow unencrypted v1 communication by detecting a v1 version message by the initial 11-byte sequence of <code>4byte net magic || \"version\"</code>.\n+\n+=== Symmetric Encryption Cipher Keys ===\n+\n+Once the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the symmetric encryption cipher keys MUST be derived with HKDF <ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the following specification:\n+\n+1. HKDF extraction\n+<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY||NETWORK_MAGIC\", ikm=ECDH_KEY)</code>.\n+\n+2. Derive Key_1_A (K_1 communication direction A)\n+<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n+\n+2. Derive Key_2_A (K_2 communication direction A)\n+<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n+\n+3. Derive Key_1_B (K_1 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n+\n+3. Derive Key_2_B (K_2 communication direction B)\n+<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n+\n+=== Session ID ===\n+\n+Both parties MUST also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for authenticating the encryption-session (identity check).\n+\n+The session-id MUST be presented to the user on request.\n+\n+=== ChaCha20-Poly1305@Bitcoin Cipher Suite ===\n+\n+==== Background ====\n+\n+ChaCha20-Poly1305@Bitcoin AEAD is almost identical to the openSSH version <ref>[https://github.com/jhcloos/openssh-chacha-poly1305/blob/master/PROTOCOL.chacha20poly1305]</ref>. The only difference to the @openSSH version is that the @Bitcoin version has a 3 byte package length (instead 4) and reuses the remaining bytes of the ChaCha20 round (21 length field encryption per ChaCha20 round; 21 x 3 < 64).\n+\n+ChaCha20 is a stream cipher designed by Daniel Bernstein and described in <ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.\n+\n+Poly1305 <ref>[http://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>, also by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit integrity tag given a message and a single-use 256 bit secret key.\n+\n+The chacha20-poly1305@bitcoin combines these two primitives into an authenticated encryption mode. The construction used is based on that proposed for TLS by Adam Langley in <ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs in the layout of data passed to the MAC and in the addition of encryption of the packet lengths.\n+\n+==== Detailed Construction ====\n+\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as output from the key exchange. Each key (K_1 and K_2) are used by two separate instances of chacha20.\n+\n+The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3 byte packet length field and has its own sequence number. The second instance, keyed by K_2, is used in conjunction with poly1305 to build an AEAD (Authenticated Encryption with Associated Data) that is used to encrypt and authenticate the entire packet.\n+\n+Two separate cipher instances are used here so as to keep the packet lengths confidential (best effort; for passive observing) but not create an oracle for the packet payload cipher by decrypting and using the packet length prior to checking the MAC. By using an independently-keyed cipher instance to encrypt the length, an active attacker seeking to exploit the packet input handling as a decryption oracle can learn nothing about the payload contents or its MAC (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers can still obtain the message length (ex. active ciphertext bit flipping or traffic shemantics analysis)\n+\n+The AEAD is constructed as follows: for each packet, generate a Poly1305 key by taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20 block counter of zero. The K_2 ChaCha20 block counter is then set to the little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance is used for encryption of the packet payload.\n+\n+==== Packet Handling ====\n+\n+When receiving a packet, the length must be decrypted first. When 3 bytes of ciphertext length have been received, they may be decrypted.\n+\n+A ChaCha20 round always calculates 64bytes which is sufficient to encrypt a 3 bytes length field 21 times (21*3 = 63). The length field sequence number can thus be used 21 times (keystream caching).\n+\n+The length field must be enc-/decrypted with the ChaCha20 keystream keyed with K_1 defined by block counter 0, the length field sequence number in little endian and a keystream position from 0 to 60.\n+\n+Pseudo code example:\n+<pre>\n+// init\n+sequence_nr_payload = 0; //payload sequence number\n+sequence_nr_length_field = 0; //length field sequence number (will be reused)\n+aad_length_field_pos = 0; //position in the length field cipher instance keystream chunk\n+\n+...\n+\n+// actual encryption\n+if cache_length_field_sequence_number != sequence_nr_length_field {\n+  cache_keystream_64_bytes = ChaCha20(key=K_1, iv=little_endian(sequence_nr_length_field), counter=0);\n+  cache_length_field_sequence_number = sequence_nr_length_field\n+}\n+packet_length = XOR_TO_LE(cache_length_field_sequence_number[aad_length_field_pos - aad_length_field_pos+3], ciphertext[0-3])\n+\n+sequence_nr_payload++;\n+aad_length_field_pos += 3; //skip 3 bytes in keystream\n+if (aad_length_field_pos + 3 > 64) { //if we are outside of the 64byte keystream...\n+  aad_length_field_pos = 0; // reset at position 0\n+  sequence_nr_length_field++; // increase length field sequence number\n+}\n+</pre>\n+\n+Once the entire packet has been received, the MAC MUST be checked before decryption. A per-packet Poly1305 key is generated as described above and the MAC tag is calculated using Poly1305 with this key over the ciphertext of the packet length and the payload together. The calculated MAC is then compared in constant time with the one appended to the packet and the packet decrypted using ChaCha20 as described above (with K_2, the packet sequence number as nonce and a starting block counter of 1).\n+\n+Detection of an invalid MAC MUST lead to immediate connection termination.\n+\n+To send a packet, first encode the 3 byte length and encrypt it using K_1 as described above. Encrypt the packet payload (using K_2) and append it to the encrypted length. Finally, calculate a MAC tag and append it.\n+\n+The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on the receive channel.\n+\n+The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages on the send channel.\n+\n+Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast, therefore it is very likely that encrypted messages will not require additional CPU cycles per byte when compared to the current unencrypted p2p message format (ChaCha20/Poly1305 versus double SHA256).\n+\n+The initial packet sequence numbers are 0.\n+\n+K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for encryption nor may it be used to encrypt more than 2^70 bytes under the same {key, nonce}.\n+\n+K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce, position-in-keystream} for encryption nor may it be used to encrypt more than 2^70 bytes under the same {key, nonce}.\n+\n+We use message sequence numbers for both communication directions.\n+\n+<pre>\n+ ------------------------------------------------------------------------------------------\n+ | Initiator                          Responder                                           |\n+ |                                                                                        |\n+ | AEAD() = ChaCha20Poly1305Bitcoin()                                                     |\n+ | MSG_A_CIPH = AEAD(k=K_1_A, K_2_A, payload_nonce=0, aad_nonce=0, aad_pos=0, msg)        |\n+ |                                                                                        |\n+ |                         --- MSG_CIPH --->                                              |\n+ |                                                                                        |\n+ |                                    msg   := AEAD(k=K_1_A,K_2_A, n=0, ..., MSG_A_CIPH)  |\n+ |                                                                                        |\n+ ------------------------------------------------------------------------------------------\n+</pre>\n+\n+==== AEAD Test Vectors ====",
      "path": "bip-0324.mediawiki",
      "position": 224,
      "original_position": 224,
      "commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "original_commit_id": "2d331e8a897abdd09fc3af8e352bb0b74f2cbc93",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "These could be in a CSV file.",
      "created_at": "2020-10-31T22:39:55Z",
      "updated_at": "2020-10-31T22:40:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1024#discussion_r515548284",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/515548284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1024"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    }
  ]
}